// This file is generated. Do not edit
// @generated

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;
use super::Security::TokenProto;
use super::Security::GetDelegationTokenRequestProto;
use super::Security::GetDelegationTokenResponseProto;
use super::Security::RenewDelegationTokenRequestProto;
use super::Security::RenewDelegationTokenResponseProto;
use super::Security::CancelDelegationTokenRequestProto;
use super::Security::CancelDelegationTokenResponseProto;
use super::hdfs::ExtendedBlockProto;
use super::hdfs::DatanodeIDProto;
use super::hdfs::DatanodeLocalInfoProto;
use super::hdfs::DatanodeInfosProto;
use super::hdfs::DatanodeInfoProto;
use super::hdfs::DatanodeStorageProto;
use super::hdfs::StorageReportProto;
use super::hdfs::ContentSummaryProto;
use super::hdfs::StorageTypeQuotaInfosProto;
use super::hdfs::StorageTypeQuotaInfoProto;
use super::hdfs::CorruptFileBlocksProto;
use super::hdfs::FsPermissionProto;
use super::hdfs::StorageTypesProto;
use super::hdfs::BlockStoragePolicyProto;
use super::hdfs::StorageUuidsProto;
use super::hdfs::LocatedBlockProto;
use super::hdfs::DataEncryptionKeyProto;
use super::hdfs::FileEncryptionInfoProto;
use super::hdfs::PerFileEncryptionInfoProto;
use super::hdfs::ZoneEncryptionInfoProto;
use super::hdfs::CipherOptionProto;
use super::hdfs::LocatedBlocksProto;
use super::hdfs::HdfsFileStatusProto;
use super::hdfs::FsServerDefaultsProto;
use super::hdfs::DirectoryListingProto;
use super::hdfs::SnapshottableDirectoryStatusProto;
use super::hdfs::SnapshottableDirectoryListingProto;
use super::hdfs::SnapshotDiffReportEntryProto;
use super::hdfs::SnapshotDiffReportProto;
use super::hdfs::StorageInfoProto;
use super::hdfs::NamenodeRegistrationProto;
use super::hdfs::CheckpointSignatureProto;
use super::hdfs::NamenodeCommandProto;
use super::hdfs::CheckpointCommandProto;
use super::hdfs::BlockProto;
use super::hdfs::BlockWithLocationsProto;
use super::hdfs::BlocksWithLocationsProto;
use super::hdfs::RemoteEditLogProto;
use super::hdfs::RemoteEditLogManifestProto;
use super::hdfs::NamespaceInfoProto;
use super::hdfs::BlockKeyProto;
use super::hdfs::ExportedBlockKeysProto;
use super::hdfs::RecoveringBlockProto;
use super::hdfs::VersionRequestProto;
use super::hdfs::VersionResponseProto;
use super::hdfs::SnapshotInfoProto;
use super::hdfs::RollingUpgradeStatusProto;
use super::hdfs::StorageTypeProto;
use super::hdfs::CipherSuiteProto;
use super::hdfs::CryptoProtocolVersionProto;
use super::hdfs::ChecksumTypeProto;
use super::hdfs::ReplicaStateProto;
use super::acl::AclEntryProto;
use super::acl::AclEntryProto_FsActionProto;
use super::acl::AclStatusProto;
use super::acl::AclEditLogProto;
use super::acl::ModifyAclEntriesRequestProto;
use super::acl::ModifyAclEntriesResponseProto;
use super::acl::RemoveAclRequestProto;
use super::acl::RemoveAclResponseProto;
use super::acl::RemoveAclEntriesRequestProto;
use super::acl::RemoveAclEntriesResponseProto;
use super::acl::RemoveDefaultAclRequestProto;
use super::acl::RemoveDefaultAclResponseProto;
use super::acl::SetAclRequestProto;
use super::acl::SetAclResponseProto;
use super::acl::GetAclStatusRequestProto;
use super::acl::GetAclStatusResponseProto;
use super::xattr::XAttrProto;
use super::xattr::XAttrEditLogProto;
use super::xattr::SetXAttrRequestProto;
use super::xattr::SetXAttrResponseProto;
use super::xattr::GetXAttrsRequestProto;
use super::xattr::GetXAttrsResponseProto;
use super::xattr::ListXAttrsRequestProto;
use super::xattr::ListXAttrsResponseProto;
use super::xattr::RemoveXAttrRequestProto;
use super::xattr::RemoveXAttrResponseProto;
use super::xattr::XAttrSetFlagProto;
use super::encryption::CreateEncryptionZoneRequestProto;
use super::encryption::CreateEncryptionZoneResponseProto;
use super::encryption::ListEncryptionZonesRequestProto;
use super::encryption::EncryptionZoneProto;
use super::encryption::ListEncryptionZonesResponseProto;
use super::encryption::GetEZForPathRequestProto;
use super::encryption::GetEZForPathResponseProto;
use super::inotify::EventProto;
use super::inotify::EventBatchProto;
use super::inotify::CreateEventProto;
use super::inotify::CloseEventProto;
use super::inotify::AppendEventProto;
use super::inotify::RenameEventProto;
use super::inotify::MetadataUpdateEventProto;
use super::inotify::UnlinkEventProto;
use super::inotify::EventsListProto;
use super::inotify::EventType;
use super::inotify::INodeType;
use super::inotify::MetadataUpdateType;

#[derive(Clone,Default)]
pub struct GetBlockLocationsRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    offset: ::std::option::Option<u64>,
    length: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetBlockLocationsRequestProto {
    pub fn new() -> GetBlockLocationsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetBlockLocationsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetBlockLocationsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlockLocationsRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetBlockLocationsRequestProto {
                    src: ::protobuf::SingularField::none(),
                    offset: ::std::option::Option::None,
                    length: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required uint64 offset = 2;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    pub fn get_offset<'a>(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    // required uint64 length = 3;

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }

    pub fn get_length<'a>(&self) -> u64 {
        self.length.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetBlockLocationsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.offset.is_none() {
            return false;
        };
        if self.length.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.length = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.offset.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.length.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.offset {
            try!(os.write_uint64(2, v));
        };
        if let Some(v) = self.length {
            try!(os.write_uint64(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetBlockLocationsRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetBlockLocationsRequestProto {
    fn new() -> GetBlockLocationsRequestProto {
        GetBlockLocationsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetBlockLocationsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    GetBlockLocationsRequestProto::has_src,
                    GetBlockLocationsRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "offset",
                    GetBlockLocationsRequestProto::has_offset,
                    GetBlockLocationsRequestProto::get_offset,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "length",
                    GetBlockLocationsRequestProto::has_length,
                    GetBlockLocationsRequestProto::get_length,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlockLocationsRequestProto>(
                    "GetBlockLocationsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetBlockLocationsRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_offset();
        self.clear_length();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetBlockLocationsRequestProto {
    fn eq(&self, other: &GetBlockLocationsRequestProto) -> bool {
        self.src == other.src &&
        self.offset == other.offset &&
        self.length == other.length &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetBlockLocationsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetBlockLocationsResponseProto {
    // message fields
    locations: ::protobuf::SingularPtrField<LocatedBlocksProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetBlockLocationsResponseProto {
    pub fn new() -> GetBlockLocationsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetBlockLocationsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetBlockLocationsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlockLocationsResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetBlockLocationsResponseProto {
                    locations: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .hadoop.hdfs.LocatedBlocksProto locations = 1;

    pub fn clear_locations(&mut self) {
        self.locations.clear();
    }

    pub fn has_locations(&self) -> bool {
        self.locations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locations(&mut self, v: LocatedBlocksProto) {
        self.locations = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locations<'a>(&'a mut self) -> &'a mut LocatedBlocksProto {
        if self.locations.is_none() {
            self.locations.set_default();
        };
        self.locations.as_mut().unwrap()
    }

    // Take field
    pub fn take_locations(&mut self) -> LocatedBlocksProto {
        self.locations.take().unwrap_or_else(|| LocatedBlocksProto::new())
    }

    pub fn get_locations<'a>(&'a self) -> &'a LocatedBlocksProto {
        self.locations.as_ref().unwrap_or_else(|| LocatedBlocksProto::default_instance())
    }
}

impl ::protobuf::Message for GetBlockLocationsResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.locations.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.locations.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.locations.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetBlockLocationsResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetBlockLocationsResponseProto {
    fn new() -> GetBlockLocationsResponseProto {
        GetBlockLocationsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetBlockLocationsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "locations",
                    GetBlockLocationsResponseProto::has_locations,
                    GetBlockLocationsResponseProto::get_locations,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlockLocationsResponseProto>(
                    "GetBlockLocationsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetBlockLocationsResponseProto {
    fn clear(&mut self) {
        self.clear_locations();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetBlockLocationsResponseProto {
    fn eq(&self, other: &GetBlockLocationsResponseProto) -> bool {
        self.locations == other.locations &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetBlockLocationsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetServerDefaultsRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetServerDefaultsRequestProto {
    pub fn new() -> GetServerDefaultsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetServerDefaultsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetServerDefaultsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetServerDefaultsRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetServerDefaultsRequestProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for GetServerDefaultsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetServerDefaultsRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetServerDefaultsRequestProto {
    fn new() -> GetServerDefaultsRequestProto {
        GetServerDefaultsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetServerDefaultsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetServerDefaultsRequestProto>(
                    "GetServerDefaultsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetServerDefaultsRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetServerDefaultsRequestProto {
    fn eq(&self, other: &GetServerDefaultsRequestProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetServerDefaultsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetServerDefaultsResponseProto {
    // message fields
    serverDefaults: ::protobuf::SingularPtrField<FsServerDefaultsProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetServerDefaultsResponseProto {
    pub fn new() -> GetServerDefaultsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetServerDefaultsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetServerDefaultsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetServerDefaultsResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetServerDefaultsResponseProto {
                    serverDefaults: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.FsServerDefaultsProto serverDefaults = 1;

    pub fn clear_serverDefaults(&mut self) {
        self.serverDefaults.clear();
    }

    pub fn has_serverDefaults(&self) -> bool {
        self.serverDefaults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverDefaults(&mut self, v: FsServerDefaultsProto) {
        self.serverDefaults = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverDefaults<'a>(&'a mut self) -> &'a mut FsServerDefaultsProto {
        if self.serverDefaults.is_none() {
            self.serverDefaults.set_default();
        };
        self.serverDefaults.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverDefaults(&mut self) -> FsServerDefaultsProto {
        self.serverDefaults.take().unwrap_or_else(|| FsServerDefaultsProto::new())
    }

    pub fn get_serverDefaults<'a>(&'a self) -> &'a FsServerDefaultsProto {
        self.serverDefaults.as_ref().unwrap_or_else(|| FsServerDefaultsProto::default_instance())
    }
}

impl ::protobuf::Message for GetServerDefaultsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.serverDefaults.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.serverDefaults.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.serverDefaults.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.serverDefaults.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetServerDefaultsResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetServerDefaultsResponseProto {
    fn new() -> GetServerDefaultsResponseProto {
        GetServerDefaultsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetServerDefaultsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "serverDefaults",
                    GetServerDefaultsResponseProto::has_serverDefaults,
                    GetServerDefaultsResponseProto::get_serverDefaults,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetServerDefaultsResponseProto>(
                    "GetServerDefaultsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetServerDefaultsResponseProto {
    fn clear(&mut self) {
        self.clear_serverDefaults();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetServerDefaultsResponseProto {
    fn eq(&self, other: &GetServerDefaultsResponseProto) -> bool {
        self.serverDefaults == other.serverDefaults &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetServerDefaultsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CreateRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    masked: ::protobuf::SingularPtrField<FsPermissionProto>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    createFlag: ::std::option::Option<u32>,
    createParent: ::std::option::Option<bool>,
    replication: ::std::option::Option<u32>,
    blockSize: ::std::option::Option<u64>,
    cryptoProtocolVersion: ::std::vec::Vec<CryptoProtocolVersionProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CreateRequestProto {
    pub fn new() -> CreateRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateRequestProto,
        };
        unsafe {
            instance.get(|| {
                CreateRequestProto {
                    src: ::protobuf::SingularField::none(),
                    masked: ::protobuf::SingularPtrField::none(),
                    clientName: ::protobuf::SingularField::none(),
                    createFlag: ::std::option::Option::None,
                    createParent: ::std::option::Option::None,
                    replication: ::std::option::Option::None,
                    blockSize: ::std::option::Option::None,
                    cryptoProtocolVersion: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .hadoop.hdfs.FsPermissionProto masked = 2;

    pub fn clear_masked(&mut self) {
        self.masked.clear();
    }

    pub fn has_masked(&self) -> bool {
        self.masked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masked(&mut self, v: FsPermissionProto) {
        self.masked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masked<'a>(&'a mut self) -> &'a mut FsPermissionProto {
        if self.masked.is_none() {
            self.masked.set_default();
        };
        self.masked.as_mut().unwrap()
    }

    // Take field
    pub fn take_masked(&mut self) -> FsPermissionProto {
        self.masked.take().unwrap_or_else(|| FsPermissionProto::new())
    }

    pub fn get_masked<'a>(&'a self) -> &'a FsPermissionProto {
        self.masked.as_ref().unwrap_or_else(|| FsPermissionProto::default_instance())
    }

    // required string clientName = 3;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        };
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName<'a>(&'a self) -> &'a str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required uint32 createFlag = 4;

    pub fn clear_createFlag(&mut self) {
        self.createFlag = ::std::option::Option::None;
    }

    pub fn has_createFlag(&self) -> bool {
        self.createFlag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createFlag(&mut self, v: u32) {
        self.createFlag = ::std::option::Option::Some(v);
    }

    pub fn get_createFlag<'a>(&self) -> u32 {
        self.createFlag.unwrap_or(0)
    }

    // required bool createParent = 5;

    pub fn clear_createParent(&mut self) {
        self.createParent = ::std::option::Option::None;
    }

    pub fn has_createParent(&self) -> bool {
        self.createParent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createParent(&mut self, v: bool) {
        self.createParent = ::std::option::Option::Some(v);
    }

    pub fn get_createParent<'a>(&self) -> bool {
        self.createParent.unwrap_or(false)
    }

    // required uint32 replication = 6;

    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    pub fn get_replication<'a>(&self) -> u32 {
        self.replication.unwrap_or(0)
    }

    // required uint64 blockSize = 7;

    pub fn clear_blockSize(&mut self) {
        self.blockSize = ::std::option::Option::None;
    }

    pub fn has_blockSize(&self) -> bool {
        self.blockSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockSize(&mut self, v: u64) {
        self.blockSize = ::std::option::Option::Some(v);
    }

    pub fn get_blockSize<'a>(&self) -> u64 {
        self.blockSize.unwrap_or(0)
    }

    // repeated .hadoop.hdfs.CryptoProtocolVersionProto cryptoProtocolVersion = 8;

    pub fn clear_cryptoProtocolVersion(&mut self) {
        self.cryptoProtocolVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_cryptoProtocolVersion(&mut self, v: ::std::vec::Vec<CryptoProtocolVersionProto>) {
        self.cryptoProtocolVersion = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cryptoProtocolVersion<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<CryptoProtocolVersionProto> {
        &mut self.cryptoProtocolVersion
    }

    // Take field
    pub fn take_cryptoProtocolVersion(&mut self) -> ::std::vec::Vec<CryptoProtocolVersionProto> {
        ::std::mem::replace(&mut self.cryptoProtocolVersion, ::std::vec::Vec::new())
    }

    pub fn get_cryptoProtocolVersion<'a>(&'a self) -> &'a [CryptoProtocolVersionProto] {
        &self.cryptoProtocolVersion
    }
}

impl ::protobuf::Message for CreateRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.masked.is_none() {
            return false;
        };
        if self.clientName.is_none() {
            return false;
        };
        if self.createFlag.is_none() {
            return false;
        };
        if self.createParent.is_none() {
            return false;
        };
        if self.replication.is_none() {
            return false;
        };
        if self.blockSize.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.masked.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.clientName.set_default();
                    try!(is.read_string_into(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.createFlag = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.createParent = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.replication = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.blockSize = ::std::option::Option::Some(tmp);
                },
                8 => {
                    try!(::protobuf::rt::read_repeated_enum_into(wire_type, is, &mut self.cryptoProtocolVersion));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.masked.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.clientName.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.createFlag.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.createParent.is_some() {
            my_size += 2;
        };
        for value in self.replication.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.blockSize.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cryptoProtocolVersion.iter() {
            my_size += ::protobuf::rt::enum_size(8, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.masked.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.clientName.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.createFlag {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.createParent {
            try!(os.write_bool(5, v));
        };
        if let Some(v) = self.replication {
            try!(os.write_uint32(6, v));
        };
        if let Some(v) = self.blockSize {
            try!(os.write_uint64(7, v));
        };
        for v in self.cryptoProtocolVersion.iter() {
            try!(os.write_enum(8, *v as i32));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CreateRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateRequestProto {
    fn new() -> CreateRequestProto {
        CreateRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    CreateRequestProto::has_src,
                    CreateRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "masked",
                    CreateRequestProto::has_masked,
                    CreateRequestProto::get_masked,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "clientName",
                    CreateRequestProto::has_clientName,
                    CreateRequestProto::get_clientName,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "createFlag",
                    CreateRequestProto::has_createFlag,
                    CreateRequestProto::get_createFlag,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "createParent",
                    CreateRequestProto::has_createParent,
                    CreateRequestProto::get_createParent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "replication",
                    CreateRequestProto::has_replication,
                    CreateRequestProto::get_replication,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "blockSize",
                    CreateRequestProto::has_blockSize,
                    CreateRequestProto::get_blockSize,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_enum_accessor(
                    "cryptoProtocolVersion",
                    CreateRequestProto::get_cryptoProtocolVersion,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateRequestProto>(
                    "CreateRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_masked();
        self.clear_clientName();
        self.clear_createFlag();
        self.clear_createParent();
        self.clear_replication();
        self.clear_blockSize();
        self.clear_cryptoProtocolVersion();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CreateRequestProto {
    fn eq(&self, other: &CreateRequestProto) -> bool {
        self.src == other.src &&
        self.masked == other.masked &&
        self.clientName == other.clientName &&
        self.createFlag == other.createFlag &&
        self.createParent == other.createParent &&
        self.replication == other.replication &&
        self.blockSize == other.blockSize &&
        self.cryptoProtocolVersion == other.cryptoProtocolVersion &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CreateRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CreateResponseProto {
    // message fields
    fs: ::protobuf::SingularPtrField<HdfsFileStatusProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CreateResponseProto {
    pub fn new() -> CreateResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateResponseProto,
        };
        unsafe {
            instance.get(|| {
                CreateResponseProto {
                    fs: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;

    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs<'a>(&'a mut self) -> &'a mut HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        };
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| HdfsFileStatusProto::new())
    }

    pub fn get_fs<'a>(&'a self) -> &'a HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| HdfsFileStatusProto::default_instance())
    }
}

impl ::protobuf::Message for CreateResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.fs.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.fs.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fs.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CreateResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateResponseProto {
    fn new() -> CreateResponseProto {
        CreateResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "fs",
                    CreateResponseProto::has_fs,
                    CreateResponseProto::get_fs,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateResponseProto>(
                    "CreateResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateResponseProto {
    fn clear(&mut self) {
        self.clear_fs();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CreateResponseProto {
    fn eq(&self, other: &CreateResponseProto) -> bool {
        self.fs == other.fs &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CreateResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct AppendRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    flag: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl AppendRequestProto {
    pub fn new() -> AppendRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AppendRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AppendRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AppendRequestProto,
        };
        unsafe {
            instance.get(|| {
                AppendRequestProto {
                    src: ::protobuf::SingularField::none(),
                    clientName: ::protobuf::SingularField::none(),
                    flag: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string clientName = 2;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        };
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName<'a>(&'a self) -> &'a str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 flag = 3;

    pub fn clear_flag(&mut self) {
        self.flag = ::std::option::Option::None;
    }

    pub fn has_flag(&self) -> bool {
        self.flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flag(&mut self, v: u32) {
        self.flag = ::std::option::Option::Some(v);
    }

    pub fn get_flag<'a>(&self) -> u32 {
        self.flag.unwrap_or(0)
    }
}

impl ::protobuf::Message for AppendRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.clientName.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.clientName.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.flag = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.clientName.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.flag.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.clientName.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.flag {
            try!(os.write_uint32(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<AppendRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AppendRequestProto {
    fn new() -> AppendRequestProto {
        AppendRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AppendRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    AppendRequestProto::has_src,
                    AppendRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "clientName",
                    AppendRequestProto::has_clientName,
                    AppendRequestProto::get_clientName,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "flag",
                    AppendRequestProto::has_flag,
                    AppendRequestProto::get_flag,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppendRequestProto>(
                    "AppendRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AppendRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_clientName();
        self.clear_flag();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for AppendRequestProto {
    fn eq(&self, other: &AppendRequestProto) -> bool {
        self.src == other.src &&
        self.clientName == other.clientName &&
        self.flag == other.flag &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for AppendRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct AppendResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<LocatedBlockProto>,
    stat: ::protobuf::SingularPtrField<HdfsFileStatusProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl AppendResponseProto {
    pub fn new() -> AppendResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AppendResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AppendResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AppendResponseProto,
        };
        unsafe {
            instance.get(|| {
                AppendResponseProto {
                    block: ::protobuf::SingularPtrField::none(),
                    stat: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .hadoop.hdfs.LocatedBlockProto block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block<'a>(&'a mut self) -> &'a mut LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        };
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> LocatedBlockProto {
        self.block.take().unwrap_or_else(|| LocatedBlockProto::new())
    }

    pub fn get_block<'a>(&'a self) -> &'a LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| LocatedBlockProto::default_instance())
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto stat = 2;

    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: HdfsFileStatusProto) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat<'a>(&'a mut self) -> &'a mut HdfsFileStatusProto {
        if self.stat.is_none() {
            self.stat.set_default();
        };
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> HdfsFileStatusProto {
        self.stat.take().unwrap_or_else(|| HdfsFileStatusProto::new())
    }

    pub fn get_stat<'a>(&'a self) -> &'a HdfsFileStatusProto {
        self.stat.as_ref().unwrap_or_else(|| HdfsFileStatusProto::default_instance())
    }
}

impl ::protobuf::Message for AppendResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.block.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.stat.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.block.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.stat.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.block.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.stat.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<AppendResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AppendResponseProto {
    fn new() -> AppendResponseProto {
        AppendResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AppendResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "block",
                    AppendResponseProto::has_block,
                    AppendResponseProto::get_block,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "stat",
                    AppendResponseProto::has_stat,
                    AppendResponseProto::get_stat,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppendResponseProto>(
                    "AppendResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AppendResponseProto {
    fn clear(&mut self) {
        self.clear_block();
        self.clear_stat();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for AppendResponseProto {
    fn eq(&self, other: &AppendResponseProto) -> bool {
        self.block == other.block &&
        self.stat == other.stat &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for AppendResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetReplicationRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    replication: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetReplicationRequestProto {
    pub fn new() -> SetReplicationRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetReplicationRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetReplicationRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetReplicationRequestProto,
        };
        unsafe {
            instance.get(|| {
                SetReplicationRequestProto {
                    src: ::protobuf::SingularField::none(),
                    replication: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required uint32 replication = 2;

    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    pub fn get_replication<'a>(&self) -> u32 {
        self.replication.unwrap_or(0)
    }
}

impl ::protobuf::Message for SetReplicationRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.replication.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.replication = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.replication.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.replication {
            try!(os.write_uint32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetReplicationRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetReplicationRequestProto {
    fn new() -> SetReplicationRequestProto {
        SetReplicationRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetReplicationRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    SetReplicationRequestProto::has_src,
                    SetReplicationRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "replication",
                    SetReplicationRequestProto::has_replication,
                    SetReplicationRequestProto::get_replication,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetReplicationRequestProto>(
                    "SetReplicationRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetReplicationRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_replication();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetReplicationRequestProto {
    fn eq(&self, other: &SetReplicationRequestProto) -> bool {
        self.src == other.src &&
        self.replication == other.replication &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetReplicationRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetReplicationResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetReplicationResponseProto {
    pub fn new() -> SetReplicationResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetReplicationResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetReplicationResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetReplicationResponseProto,
        };
        unsafe {
            instance.get(|| {
                SetReplicationResponseProto {
                    result: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result<'a>(&self) -> bool {
        self.result.unwrap_or(false)
    }
}

impl ::protobuf::Message for SetReplicationResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            try!(os.write_bool(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetReplicationResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetReplicationResponseProto {
    fn new() -> SetReplicationResponseProto {
        SetReplicationResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetReplicationResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "result",
                    SetReplicationResponseProto::has_result,
                    SetReplicationResponseProto::get_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetReplicationResponseProto>(
                    "SetReplicationResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetReplicationResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetReplicationResponseProto {
    fn eq(&self, other: &SetReplicationResponseProto) -> bool {
        self.result == other.result &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetReplicationResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetStoragePolicyRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    policyName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetStoragePolicyRequestProto {
    pub fn new() -> SetStoragePolicyRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetStoragePolicyRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetStoragePolicyRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetStoragePolicyRequestProto,
        };
        unsafe {
            instance.get(|| {
                SetStoragePolicyRequestProto {
                    src: ::protobuf::SingularField::none(),
                    policyName: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string policyName = 2;

    pub fn clear_policyName(&mut self) {
        self.policyName.clear();
    }

    pub fn has_policyName(&self) -> bool {
        self.policyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policyName(&mut self, v: ::std::string::String) {
        self.policyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policyName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.policyName.is_none() {
            self.policyName.set_default();
        };
        self.policyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_policyName(&mut self) -> ::std::string::String {
        self.policyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_policyName<'a>(&'a self) -> &'a str {
        match self.policyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for SetStoragePolicyRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.policyName.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.policyName.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.policyName.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.policyName.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetStoragePolicyRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetStoragePolicyRequestProto {
    fn new() -> SetStoragePolicyRequestProto {
        SetStoragePolicyRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetStoragePolicyRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    SetStoragePolicyRequestProto::has_src,
                    SetStoragePolicyRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "policyName",
                    SetStoragePolicyRequestProto::has_policyName,
                    SetStoragePolicyRequestProto::get_policyName,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetStoragePolicyRequestProto>(
                    "SetStoragePolicyRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetStoragePolicyRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_policyName();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetStoragePolicyRequestProto {
    fn eq(&self, other: &SetStoragePolicyRequestProto) -> bool {
        self.src == other.src &&
        self.policyName == other.policyName &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetStoragePolicyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetStoragePolicyResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetStoragePolicyResponseProto {
    pub fn new() -> SetStoragePolicyResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetStoragePolicyResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetStoragePolicyResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetStoragePolicyResponseProto,
        };
        unsafe {
            instance.get(|| {
                SetStoragePolicyResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for SetStoragePolicyResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetStoragePolicyResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetStoragePolicyResponseProto {
    fn new() -> SetStoragePolicyResponseProto {
        SetStoragePolicyResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetStoragePolicyResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetStoragePolicyResponseProto>(
                    "SetStoragePolicyResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetStoragePolicyResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetStoragePolicyResponseProto {
    fn eq(&self, other: &SetStoragePolicyResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetStoragePolicyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetStoragePoliciesRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetStoragePoliciesRequestProto {
    pub fn new() -> GetStoragePoliciesRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetStoragePoliciesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetStoragePoliciesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetStoragePoliciesRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetStoragePoliciesRequestProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for GetStoragePoliciesRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetStoragePoliciesRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetStoragePoliciesRequestProto {
    fn new() -> GetStoragePoliciesRequestProto {
        GetStoragePoliciesRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetStoragePoliciesRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetStoragePoliciesRequestProto>(
                    "GetStoragePoliciesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetStoragePoliciesRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetStoragePoliciesRequestProto {
    fn eq(&self, other: &GetStoragePoliciesRequestProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetStoragePoliciesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetStoragePoliciesResponseProto {
    // message fields
    policies: ::protobuf::RepeatedField<BlockStoragePolicyProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetStoragePoliciesResponseProto {
    pub fn new() -> GetStoragePoliciesResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetStoragePoliciesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetStoragePoliciesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetStoragePoliciesResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetStoragePoliciesResponseProto {
                    policies: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .hadoop.hdfs.BlockStoragePolicyProto policies = 1;

    pub fn clear_policies(&mut self) {
        self.policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_policies(&mut self, v: ::protobuf::RepeatedField<BlockStoragePolicyProto>) {
        self.policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policies<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<BlockStoragePolicyProto> {
        &mut self.policies
    }

    // Take field
    pub fn take_policies(&mut self) -> ::protobuf::RepeatedField<BlockStoragePolicyProto> {
        ::std::mem::replace(&mut self.policies, ::protobuf::RepeatedField::new())
    }

    pub fn get_policies<'a>(&'a self) -> &'a [BlockStoragePolicyProto] {
        &self.policies
    }
}

impl ::protobuf::Message for GetStoragePoliciesResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.policies));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.policies.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.policies.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetStoragePoliciesResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetStoragePoliciesResponseProto {
    fn new() -> GetStoragePoliciesResponseProto {
        GetStoragePoliciesResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetStoragePoliciesResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "policies",
                    GetStoragePoliciesResponseProto::get_policies,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetStoragePoliciesResponseProto>(
                    "GetStoragePoliciesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetStoragePoliciesResponseProto {
    fn clear(&mut self) {
        self.clear_policies();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetStoragePoliciesResponseProto {
    fn eq(&self, other: &GetStoragePoliciesResponseProto) -> bool {
        self.policies == other.policies &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetStoragePoliciesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetPermissionRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    permission: ::protobuf::SingularPtrField<FsPermissionProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetPermissionRequestProto {
    pub fn new() -> SetPermissionRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetPermissionRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetPermissionRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPermissionRequestProto,
        };
        unsafe {
            instance.get(|| {
                SetPermissionRequestProto {
                    src: ::protobuf::SingularField::none(),
                    permission: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .hadoop.hdfs.FsPermissionProto permission = 2;

    pub fn clear_permission(&mut self) {
        self.permission.clear();
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: FsPermissionProto) {
        self.permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission<'a>(&'a mut self) -> &'a mut FsPermissionProto {
        if self.permission.is_none() {
            self.permission.set_default();
        };
        self.permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission(&mut self) -> FsPermissionProto {
        self.permission.take().unwrap_or_else(|| FsPermissionProto::new())
    }

    pub fn get_permission<'a>(&'a self) -> &'a FsPermissionProto {
        self.permission.as_ref().unwrap_or_else(|| FsPermissionProto::default_instance())
    }
}

impl ::protobuf::Message for SetPermissionRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.permission.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.permission.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.permission.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.permission.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetPermissionRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetPermissionRequestProto {
    fn new() -> SetPermissionRequestProto {
        SetPermissionRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetPermissionRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    SetPermissionRequestProto::has_src,
                    SetPermissionRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "permission",
                    SetPermissionRequestProto::has_permission,
                    SetPermissionRequestProto::get_permission,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetPermissionRequestProto>(
                    "SetPermissionRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetPermissionRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_permission();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetPermissionRequestProto {
    fn eq(&self, other: &SetPermissionRequestProto) -> bool {
        self.src == other.src &&
        self.permission == other.permission &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetPermissionRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetPermissionResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetPermissionResponseProto {
    pub fn new() -> SetPermissionResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetPermissionResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetPermissionResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPermissionResponseProto,
        };
        unsafe {
            instance.get(|| {
                SetPermissionResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for SetPermissionResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetPermissionResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetPermissionResponseProto {
    fn new() -> SetPermissionResponseProto {
        SetPermissionResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetPermissionResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetPermissionResponseProto>(
                    "SetPermissionResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetPermissionResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetPermissionResponseProto {
    fn eq(&self, other: &SetPermissionResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetPermissionResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetOwnerRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    username: ::protobuf::SingularField<::std::string::String>,
    groupname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetOwnerRequestProto {
    pub fn new() -> SetOwnerRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetOwnerRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetOwnerRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetOwnerRequestProto,
        };
        unsafe {
            instance.get(|| {
                SetOwnerRequestProto {
                    src: ::protobuf::SingularField::none(),
                    username: ::protobuf::SingularField::none(),
                    groupname: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string username = 2;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.username.is_none() {
            self.username.set_default();
        };
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_username<'a>(&'a self) -> &'a str {
        match self.username.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string groupname = 3;

    pub fn clear_groupname(&mut self) {
        self.groupname.clear();
    }

    pub fn has_groupname(&self) -> bool {
        self.groupname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupname(&mut self, v: ::std::string::String) {
        self.groupname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.groupname.is_none() {
            self.groupname.set_default();
        };
        self.groupname.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupname(&mut self) -> ::std::string::String {
        self.groupname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_groupname<'a>(&'a self) -> &'a str {
        match self.groupname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for SetOwnerRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.username.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.groupname.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.username.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.groupname.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.username.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.groupname.as_ref() {
            try!(os.write_string(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetOwnerRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetOwnerRequestProto {
    fn new() -> SetOwnerRequestProto {
        SetOwnerRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetOwnerRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    SetOwnerRequestProto::has_src,
                    SetOwnerRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "username",
                    SetOwnerRequestProto::has_username,
                    SetOwnerRequestProto::get_username,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "groupname",
                    SetOwnerRequestProto::has_groupname,
                    SetOwnerRequestProto::get_groupname,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetOwnerRequestProto>(
                    "SetOwnerRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetOwnerRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_username();
        self.clear_groupname();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetOwnerRequestProto {
    fn eq(&self, other: &SetOwnerRequestProto) -> bool {
        self.src == other.src &&
        self.username == other.username &&
        self.groupname == other.groupname &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetOwnerRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetOwnerResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetOwnerResponseProto {
    pub fn new() -> SetOwnerResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetOwnerResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetOwnerResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetOwnerResponseProto,
        };
        unsafe {
            instance.get(|| {
                SetOwnerResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for SetOwnerResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetOwnerResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetOwnerResponseProto {
    fn new() -> SetOwnerResponseProto {
        SetOwnerResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetOwnerResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetOwnerResponseProto>(
                    "SetOwnerResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetOwnerResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetOwnerResponseProto {
    fn eq(&self, other: &SetOwnerResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetOwnerResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct AbandonBlockRequestProto {
    // message fields
    b: ::protobuf::SingularPtrField<ExtendedBlockProto>,
    src: ::protobuf::SingularField<::std::string::String>,
    holder: ::protobuf::SingularField<::std::string::String>,
    fileId: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl AbandonBlockRequestProto {
    pub fn new() -> AbandonBlockRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AbandonBlockRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AbandonBlockRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AbandonBlockRequestProto,
        };
        unsafe {
            instance.get(|| {
                AbandonBlockRequestProto {
                    b: ::protobuf::SingularPtrField::none(),
                    src: ::protobuf::SingularField::none(),
                    holder: ::protobuf::SingularField::none(),
                    fileId: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.ExtendedBlockProto b = 1;

    pub fn clear_b(&mut self) {
        self.b.clear();
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: ExtendedBlockProto) {
        self.b = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_b<'a>(&'a mut self) -> &'a mut ExtendedBlockProto {
        if self.b.is_none() {
            self.b.set_default();
        };
        self.b.as_mut().unwrap()
    }

    // Take field
    pub fn take_b(&mut self) -> ExtendedBlockProto {
        self.b.take().unwrap_or_else(|| ExtendedBlockProto::new())
    }

    pub fn get_b<'a>(&'a self) -> &'a ExtendedBlockProto {
        self.b.as_ref().unwrap_or_else(|| ExtendedBlockProto::default_instance())
    }

    // required string src = 2;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string holder = 3;

    pub fn clear_holder(&mut self) {
        self.holder.clear();
    }

    pub fn has_holder(&self) -> bool {
        self.holder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_holder(&mut self, v: ::std::string::String) {
        self.holder = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.holder.is_none() {
            self.holder.set_default();
        };
        self.holder.as_mut().unwrap()
    }

    // Take field
    pub fn take_holder(&mut self) -> ::std::string::String {
        self.holder.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_holder<'a>(&'a self) -> &'a str {
        match self.holder.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint64 fileId = 4;

    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    pub fn get_fileId<'a>(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
}

impl ::protobuf::Message for AbandonBlockRequestProto {
    fn is_initialized(&self) -> bool {
        if self.b.is_none() {
            return false;
        };
        if self.src.is_none() {
            return false;
        };
        if self.holder.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.b.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.holder.set_default();
                    try!(is.read_string_into(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.b.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.holder.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.fileId.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.b.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.holder.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.fileId {
            try!(os.write_uint64(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<AbandonBlockRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AbandonBlockRequestProto {
    fn new() -> AbandonBlockRequestProto {
        AbandonBlockRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AbandonBlockRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "b",
                    AbandonBlockRequestProto::has_b,
                    AbandonBlockRequestProto::get_b,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    AbandonBlockRequestProto::has_src,
                    AbandonBlockRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "holder",
                    AbandonBlockRequestProto::has_holder,
                    AbandonBlockRequestProto::get_holder,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "fileId",
                    AbandonBlockRequestProto::has_fileId,
                    AbandonBlockRequestProto::get_fileId,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AbandonBlockRequestProto>(
                    "AbandonBlockRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AbandonBlockRequestProto {
    fn clear(&mut self) {
        self.clear_b();
        self.clear_src();
        self.clear_holder();
        self.clear_fileId();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for AbandonBlockRequestProto {
    fn eq(&self, other: &AbandonBlockRequestProto) -> bool {
        self.b == other.b &&
        self.src == other.src &&
        self.holder == other.holder &&
        self.fileId == other.fileId &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for AbandonBlockRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct AbandonBlockResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl AbandonBlockResponseProto {
    pub fn new() -> AbandonBlockResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AbandonBlockResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AbandonBlockResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AbandonBlockResponseProto,
        };
        unsafe {
            instance.get(|| {
                AbandonBlockResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for AbandonBlockResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<AbandonBlockResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AbandonBlockResponseProto {
    fn new() -> AbandonBlockResponseProto {
        AbandonBlockResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AbandonBlockResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AbandonBlockResponseProto>(
                    "AbandonBlockResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AbandonBlockResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for AbandonBlockResponseProto {
    fn eq(&self, other: &AbandonBlockResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for AbandonBlockResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct AddBlockRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    previous: ::protobuf::SingularPtrField<ExtendedBlockProto>,
    excludeNodes: ::protobuf::RepeatedField<DatanodeInfoProto>,
    fileId: ::std::option::Option<u64>,
    favoredNodes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl AddBlockRequestProto {
    pub fn new() -> AddBlockRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddBlockRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AddBlockRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddBlockRequestProto,
        };
        unsafe {
            instance.get(|| {
                AddBlockRequestProto {
                    src: ::protobuf::SingularField::none(),
                    clientName: ::protobuf::SingularField::none(),
                    previous: ::protobuf::SingularPtrField::none(),
                    excludeNodes: ::protobuf::RepeatedField::new(),
                    fileId: ::std::option::Option::None,
                    favoredNodes: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string clientName = 2;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        };
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName<'a>(&'a self) -> &'a str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .hadoop.hdfs.ExtendedBlockProto previous = 3;

    pub fn clear_previous(&mut self) {
        self.previous.clear();
    }

    pub fn has_previous(&self) -> bool {
        self.previous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous(&mut self, v: ExtendedBlockProto) {
        self.previous = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_previous<'a>(&'a mut self) -> &'a mut ExtendedBlockProto {
        if self.previous.is_none() {
            self.previous.set_default();
        };
        self.previous.as_mut().unwrap()
    }

    // Take field
    pub fn take_previous(&mut self) -> ExtendedBlockProto {
        self.previous.take().unwrap_or_else(|| ExtendedBlockProto::new())
    }

    pub fn get_previous<'a>(&'a self) -> &'a ExtendedBlockProto {
        self.previous.as_ref().unwrap_or_else(|| ExtendedBlockProto::default_instance())
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto excludeNodes = 4;

    pub fn clear_excludeNodes(&mut self) {
        self.excludeNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludeNodes(&mut self, v: ::protobuf::RepeatedField<DatanodeInfoProto>) {
        self.excludeNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludeNodes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<DatanodeInfoProto> {
        &mut self.excludeNodes
    }

    // Take field
    pub fn take_excludeNodes(&mut self) -> ::protobuf::RepeatedField<DatanodeInfoProto> {
        ::std::mem::replace(&mut self.excludeNodes, ::protobuf::RepeatedField::new())
    }

    pub fn get_excludeNodes<'a>(&'a self) -> &'a [DatanodeInfoProto] {
        &self.excludeNodes
    }

    // optional uint64 fileId = 5;

    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    pub fn get_fileId<'a>(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }

    // repeated string favoredNodes = 6;

    pub fn clear_favoredNodes(&mut self) {
        self.favoredNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_favoredNodes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.favoredNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_favoredNodes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.favoredNodes
    }

    // Take field
    pub fn take_favoredNodes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.favoredNodes, ::protobuf::RepeatedField::new())
    }

    pub fn get_favoredNodes<'a>(&'a self) -> &'a [::std::string::String] {
        &self.favoredNodes
    }
}

impl ::protobuf::Message for AddBlockRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.clientName.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.clientName.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.previous.set_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.excludeNodes));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                6 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.favoredNodes));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.clientName.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.previous.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.excludeNodes.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.fileId.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.favoredNodes.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.clientName.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.previous.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.excludeNodes.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.fileId {
            try!(os.write_uint64(5, v));
        };
        for v in self.favoredNodes.iter() {
            try!(os.write_string(6, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<AddBlockRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddBlockRequestProto {
    fn new() -> AddBlockRequestProto {
        AddBlockRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddBlockRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    AddBlockRequestProto::has_src,
                    AddBlockRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "clientName",
                    AddBlockRequestProto::has_clientName,
                    AddBlockRequestProto::get_clientName,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "previous",
                    AddBlockRequestProto::has_previous,
                    AddBlockRequestProto::get_previous,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "excludeNodes",
                    AddBlockRequestProto::get_excludeNodes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "fileId",
                    AddBlockRequestProto::has_fileId,
                    AddBlockRequestProto::get_fileId,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "favoredNodes",
                    AddBlockRequestProto::get_favoredNodes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddBlockRequestProto>(
                    "AddBlockRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddBlockRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_clientName();
        self.clear_previous();
        self.clear_excludeNodes();
        self.clear_fileId();
        self.clear_favoredNodes();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for AddBlockRequestProto {
    fn eq(&self, other: &AddBlockRequestProto) -> bool {
        self.src == other.src &&
        self.clientName == other.clientName &&
        self.previous == other.previous &&
        self.excludeNodes == other.excludeNodes &&
        self.fileId == other.fileId &&
        self.favoredNodes == other.favoredNodes &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for AddBlockRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct AddBlockResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<LocatedBlockProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl AddBlockResponseProto {
    pub fn new() -> AddBlockResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddBlockResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AddBlockResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddBlockResponseProto,
        };
        unsafe {
            instance.get(|| {
                AddBlockResponseProto {
                    block: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block<'a>(&'a mut self) -> &'a mut LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        };
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> LocatedBlockProto {
        self.block.take().unwrap_or_else(|| LocatedBlockProto::new())
    }

    pub fn get_block<'a>(&'a self) -> &'a LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| LocatedBlockProto::default_instance())
    }
}

impl ::protobuf::Message for AddBlockResponseProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.block.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.block.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.block.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<AddBlockResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddBlockResponseProto {
    fn new() -> AddBlockResponseProto {
        AddBlockResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddBlockResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "block",
                    AddBlockResponseProto::has_block,
                    AddBlockResponseProto::get_block,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddBlockResponseProto>(
                    "AddBlockResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddBlockResponseProto {
    fn clear(&mut self) {
        self.clear_block();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for AddBlockResponseProto {
    fn eq(&self, other: &AddBlockResponseProto) -> bool {
        self.block == other.block &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for AddBlockResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetAdditionalDatanodeRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    blk: ::protobuf::SingularPtrField<ExtendedBlockProto>,
    existings: ::protobuf::RepeatedField<DatanodeInfoProto>,
    excludes: ::protobuf::RepeatedField<DatanodeInfoProto>,
    numAdditionalNodes: ::std::option::Option<u32>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    existingStorageUuids: ::protobuf::RepeatedField<::std::string::String>,
    fileId: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetAdditionalDatanodeRequestProto {
    pub fn new() -> GetAdditionalDatanodeRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetAdditionalDatanodeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetAdditionalDatanodeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAdditionalDatanodeRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetAdditionalDatanodeRequestProto {
                    src: ::protobuf::SingularField::none(),
                    blk: ::protobuf::SingularPtrField::none(),
                    existings: ::protobuf::RepeatedField::new(),
                    excludes: ::protobuf::RepeatedField::new(),
                    numAdditionalNodes: ::std::option::Option::None,
                    clientName: ::protobuf::SingularField::none(),
                    existingStorageUuids: ::protobuf::RepeatedField::new(),
                    fileId: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .hadoop.hdfs.ExtendedBlockProto blk = 2;

    pub fn clear_blk(&mut self) {
        self.blk.clear();
    }

    pub fn has_blk(&self) -> bool {
        self.blk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blk(&mut self, v: ExtendedBlockProto) {
        self.blk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blk<'a>(&'a mut self) -> &'a mut ExtendedBlockProto {
        if self.blk.is_none() {
            self.blk.set_default();
        };
        self.blk.as_mut().unwrap()
    }

    // Take field
    pub fn take_blk(&mut self) -> ExtendedBlockProto {
        self.blk.take().unwrap_or_else(|| ExtendedBlockProto::new())
    }

    pub fn get_blk<'a>(&'a self) -> &'a ExtendedBlockProto {
        self.blk.as_ref().unwrap_or_else(|| ExtendedBlockProto::default_instance())
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto existings = 3;

    pub fn clear_existings(&mut self) {
        self.existings.clear();
    }

    // Param is passed by value, moved
    pub fn set_existings(&mut self, v: ::protobuf::RepeatedField<DatanodeInfoProto>) {
        self.existings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_existings<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<DatanodeInfoProto> {
        &mut self.existings
    }

    // Take field
    pub fn take_existings(&mut self) -> ::protobuf::RepeatedField<DatanodeInfoProto> {
        ::std::mem::replace(&mut self.existings, ::protobuf::RepeatedField::new())
    }

    pub fn get_existings<'a>(&'a self) -> &'a [DatanodeInfoProto] {
        &self.existings
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto excludes = 4;

    pub fn clear_excludes(&mut self) {
        self.excludes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludes(&mut self, v: ::protobuf::RepeatedField<DatanodeInfoProto>) {
        self.excludes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<DatanodeInfoProto> {
        &mut self.excludes
    }

    // Take field
    pub fn take_excludes(&mut self) -> ::protobuf::RepeatedField<DatanodeInfoProto> {
        ::std::mem::replace(&mut self.excludes, ::protobuf::RepeatedField::new())
    }

    pub fn get_excludes<'a>(&'a self) -> &'a [DatanodeInfoProto] {
        &self.excludes
    }

    // required uint32 numAdditionalNodes = 5;

    pub fn clear_numAdditionalNodes(&mut self) {
        self.numAdditionalNodes = ::std::option::Option::None;
    }

    pub fn has_numAdditionalNodes(&self) -> bool {
        self.numAdditionalNodes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numAdditionalNodes(&mut self, v: u32) {
        self.numAdditionalNodes = ::std::option::Option::Some(v);
    }

    pub fn get_numAdditionalNodes<'a>(&self) -> u32 {
        self.numAdditionalNodes.unwrap_or(0)
    }

    // required string clientName = 6;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        };
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName<'a>(&'a self) -> &'a str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string existingStorageUuids = 7;

    pub fn clear_existingStorageUuids(&mut self) {
        self.existingStorageUuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_existingStorageUuids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.existingStorageUuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_existingStorageUuids<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.existingStorageUuids
    }

    // Take field
    pub fn take_existingStorageUuids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.existingStorageUuids, ::protobuf::RepeatedField::new())
    }

    pub fn get_existingStorageUuids<'a>(&'a self) -> &'a [::std::string::String] {
        &self.existingStorageUuids
    }

    // optional uint64 fileId = 8;

    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    pub fn get_fileId<'a>(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
}

impl ::protobuf::Message for GetAdditionalDatanodeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.blk.is_none() {
            return false;
        };
        if self.numAdditionalNodes.is_none() {
            return false;
        };
        if self.clientName.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.blk.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.existings));
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.excludes));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.numAdditionalNodes = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.clientName.set_default();
                    try!(is.read_string_into(tmp))
                },
                7 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.existingStorageUuids));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.blk.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.existings.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.excludes.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.numAdditionalNodes.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.clientName.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in self.existingStorageUuids.iter() {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in self.fileId.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.blk.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.existings.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.excludes.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.numAdditionalNodes {
            try!(os.write_uint32(5, v));
        };
        if let Some(v) = self.clientName.as_ref() {
            try!(os.write_string(6, &v));
        };
        for v in self.existingStorageUuids.iter() {
            try!(os.write_string(7, &v));
        };
        if let Some(v) = self.fileId {
            try!(os.write_uint64(8, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetAdditionalDatanodeRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetAdditionalDatanodeRequestProto {
    fn new() -> GetAdditionalDatanodeRequestProto {
        GetAdditionalDatanodeRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetAdditionalDatanodeRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    GetAdditionalDatanodeRequestProto::has_src,
                    GetAdditionalDatanodeRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "blk",
                    GetAdditionalDatanodeRequestProto::has_blk,
                    GetAdditionalDatanodeRequestProto::get_blk,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "existings",
                    GetAdditionalDatanodeRequestProto::get_existings,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "excludes",
                    GetAdditionalDatanodeRequestProto::get_excludes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "numAdditionalNodes",
                    GetAdditionalDatanodeRequestProto::has_numAdditionalNodes,
                    GetAdditionalDatanodeRequestProto::get_numAdditionalNodes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "clientName",
                    GetAdditionalDatanodeRequestProto::has_clientName,
                    GetAdditionalDatanodeRequestProto::get_clientName,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "existingStorageUuids",
                    GetAdditionalDatanodeRequestProto::get_existingStorageUuids,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "fileId",
                    GetAdditionalDatanodeRequestProto::has_fileId,
                    GetAdditionalDatanodeRequestProto::get_fileId,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAdditionalDatanodeRequestProto>(
                    "GetAdditionalDatanodeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetAdditionalDatanodeRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_blk();
        self.clear_existings();
        self.clear_excludes();
        self.clear_numAdditionalNodes();
        self.clear_clientName();
        self.clear_existingStorageUuids();
        self.clear_fileId();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetAdditionalDatanodeRequestProto {
    fn eq(&self, other: &GetAdditionalDatanodeRequestProto) -> bool {
        self.src == other.src &&
        self.blk == other.blk &&
        self.existings == other.existings &&
        self.excludes == other.excludes &&
        self.numAdditionalNodes == other.numAdditionalNodes &&
        self.clientName == other.clientName &&
        self.existingStorageUuids == other.existingStorageUuids &&
        self.fileId == other.fileId &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetAdditionalDatanodeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetAdditionalDatanodeResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<LocatedBlockProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetAdditionalDatanodeResponseProto {
    pub fn new() -> GetAdditionalDatanodeResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetAdditionalDatanodeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetAdditionalDatanodeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAdditionalDatanodeResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetAdditionalDatanodeResponseProto {
                    block: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block<'a>(&'a mut self) -> &'a mut LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        };
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> LocatedBlockProto {
        self.block.take().unwrap_or_else(|| LocatedBlockProto::new())
    }

    pub fn get_block<'a>(&'a self) -> &'a LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| LocatedBlockProto::default_instance())
    }
}

impl ::protobuf::Message for GetAdditionalDatanodeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.block.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.block.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.block.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetAdditionalDatanodeResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetAdditionalDatanodeResponseProto {
    fn new() -> GetAdditionalDatanodeResponseProto {
        GetAdditionalDatanodeResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetAdditionalDatanodeResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "block",
                    GetAdditionalDatanodeResponseProto::has_block,
                    GetAdditionalDatanodeResponseProto::get_block,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAdditionalDatanodeResponseProto>(
                    "GetAdditionalDatanodeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetAdditionalDatanodeResponseProto {
    fn clear(&mut self) {
        self.clear_block();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetAdditionalDatanodeResponseProto {
    fn eq(&self, other: &GetAdditionalDatanodeResponseProto) -> bool {
        self.block == other.block &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetAdditionalDatanodeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CompleteRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    last: ::protobuf::SingularPtrField<ExtendedBlockProto>,
    fileId: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CompleteRequestProto {
    pub fn new() -> CompleteRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CompleteRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CompleteRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompleteRequestProto,
        };
        unsafe {
            instance.get(|| {
                CompleteRequestProto {
                    src: ::protobuf::SingularField::none(),
                    clientName: ::protobuf::SingularField::none(),
                    last: ::protobuf::SingularPtrField::none(),
                    fileId: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string clientName = 2;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        };
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName<'a>(&'a self) -> &'a str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .hadoop.hdfs.ExtendedBlockProto last = 3;

    pub fn clear_last(&mut self) {
        self.last.clear();
    }

    pub fn has_last(&self) -> bool {
        self.last.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last(&mut self, v: ExtendedBlockProto) {
        self.last = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last<'a>(&'a mut self) -> &'a mut ExtendedBlockProto {
        if self.last.is_none() {
            self.last.set_default();
        };
        self.last.as_mut().unwrap()
    }

    // Take field
    pub fn take_last(&mut self) -> ExtendedBlockProto {
        self.last.take().unwrap_or_else(|| ExtendedBlockProto::new())
    }

    pub fn get_last<'a>(&'a self) -> &'a ExtendedBlockProto {
        self.last.as_ref().unwrap_or_else(|| ExtendedBlockProto::default_instance())
    }

    // optional uint64 fileId = 4;

    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    pub fn get_fileId<'a>(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
}

impl ::protobuf::Message for CompleteRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.clientName.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.clientName.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.last.set_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.clientName.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.last.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.fileId.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.clientName.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.last.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.fileId {
            try!(os.write_uint64(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CompleteRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CompleteRequestProto {
    fn new() -> CompleteRequestProto {
        CompleteRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CompleteRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    CompleteRequestProto::has_src,
                    CompleteRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "clientName",
                    CompleteRequestProto::has_clientName,
                    CompleteRequestProto::get_clientName,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "last",
                    CompleteRequestProto::has_last,
                    CompleteRequestProto::get_last,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "fileId",
                    CompleteRequestProto::has_fileId,
                    CompleteRequestProto::get_fileId,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompleteRequestProto>(
                    "CompleteRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CompleteRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_clientName();
        self.clear_last();
        self.clear_fileId();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CompleteRequestProto {
    fn eq(&self, other: &CompleteRequestProto) -> bool {
        self.src == other.src &&
        self.clientName == other.clientName &&
        self.last == other.last &&
        self.fileId == other.fileId &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CompleteRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CompleteResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CompleteResponseProto {
    pub fn new() -> CompleteResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CompleteResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CompleteResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompleteResponseProto,
        };
        unsafe {
            instance.get(|| {
                CompleteResponseProto {
                    result: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result<'a>(&self) -> bool {
        self.result.unwrap_or(false)
    }
}

impl ::protobuf::Message for CompleteResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            try!(os.write_bool(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CompleteResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CompleteResponseProto {
    fn new() -> CompleteResponseProto {
        CompleteResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CompleteResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "result",
                    CompleteResponseProto::has_result,
                    CompleteResponseProto::get_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompleteResponseProto>(
                    "CompleteResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CompleteResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CompleteResponseProto {
    fn eq(&self, other: &CompleteResponseProto) -> bool {
        self.result == other.result &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CompleteResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ReportBadBlocksRequestProto {
    // message fields
    blocks: ::protobuf::RepeatedField<LocatedBlockProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ReportBadBlocksRequestProto {
    pub fn new() -> ReportBadBlocksRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReportBadBlocksRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ReportBadBlocksRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReportBadBlocksRequestProto,
        };
        unsafe {
            instance.get(|| {
                ReportBadBlocksRequestProto {
                    blocks: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .hadoop.hdfs.LocatedBlockProto blocks = 1;

    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<LocatedBlockProto>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<LocatedBlockProto> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<LocatedBlockProto> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    pub fn get_blocks<'a>(&'a self) -> &'a [LocatedBlockProto] {
        &self.blocks
    }
}

impl ::protobuf::Message for ReportBadBlocksRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.blocks.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.blocks.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ReportBadBlocksRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReportBadBlocksRequestProto {
    fn new() -> ReportBadBlocksRequestProto {
        ReportBadBlocksRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReportBadBlocksRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "blocks",
                    ReportBadBlocksRequestProto::get_blocks,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReportBadBlocksRequestProto>(
                    "ReportBadBlocksRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReportBadBlocksRequestProto {
    fn clear(&mut self) {
        self.clear_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ReportBadBlocksRequestProto {
    fn eq(&self, other: &ReportBadBlocksRequestProto) -> bool {
        self.blocks == other.blocks &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ReportBadBlocksRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ReportBadBlocksResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ReportBadBlocksResponseProto {
    pub fn new() -> ReportBadBlocksResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReportBadBlocksResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ReportBadBlocksResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReportBadBlocksResponseProto,
        };
        unsafe {
            instance.get(|| {
                ReportBadBlocksResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for ReportBadBlocksResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ReportBadBlocksResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReportBadBlocksResponseProto {
    fn new() -> ReportBadBlocksResponseProto {
        ReportBadBlocksResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReportBadBlocksResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ReportBadBlocksResponseProto>(
                    "ReportBadBlocksResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReportBadBlocksResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ReportBadBlocksResponseProto {
    fn eq(&self, other: &ReportBadBlocksResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ReportBadBlocksResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ConcatRequestProto {
    // message fields
    trg: ::protobuf::SingularField<::std::string::String>,
    srcs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ConcatRequestProto {
    pub fn new() -> ConcatRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ConcatRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ConcatRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConcatRequestProto,
        };
        unsafe {
            instance.get(|| {
                ConcatRequestProto {
                    trg: ::protobuf::SingularField::none(),
                    srcs: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string trg = 1;

    pub fn clear_trg(&mut self) {
        self.trg.clear();
    }

    pub fn has_trg(&self) -> bool {
        self.trg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trg(&mut self, v: ::std::string::String) {
        self.trg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trg<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.trg.is_none() {
            self.trg.set_default();
        };
        self.trg.as_mut().unwrap()
    }

    // Take field
    pub fn take_trg(&mut self) -> ::std::string::String {
        self.trg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_trg<'a>(&'a self) -> &'a str {
        match self.trg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string srcs = 2;

    pub fn clear_srcs(&mut self) {
        self.srcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_srcs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.srcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_srcs<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.srcs
    }

    // Take field
    pub fn take_srcs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.srcs, ::protobuf::RepeatedField::new())
    }

    pub fn get_srcs<'a>(&'a self) -> &'a [::std::string::String] {
        &self.srcs
    }
}

impl ::protobuf::Message for ConcatRequestProto {
    fn is_initialized(&self) -> bool {
        if self.trg.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.trg.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.srcs));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.trg.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.srcs.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.trg.as_ref() {
            try!(os.write_string(1, &v));
        };
        for v in self.srcs.iter() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ConcatRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ConcatRequestProto {
    fn new() -> ConcatRequestProto {
        ConcatRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ConcatRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "trg",
                    ConcatRequestProto::has_trg,
                    ConcatRequestProto::get_trg,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "srcs",
                    ConcatRequestProto::get_srcs,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConcatRequestProto>(
                    "ConcatRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ConcatRequestProto {
    fn clear(&mut self) {
        self.clear_trg();
        self.clear_srcs();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ConcatRequestProto {
    fn eq(&self, other: &ConcatRequestProto) -> bool {
        self.trg == other.trg &&
        self.srcs == other.srcs &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ConcatRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ConcatResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ConcatResponseProto {
    pub fn new() -> ConcatResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ConcatResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ConcatResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConcatResponseProto,
        };
        unsafe {
            instance.get(|| {
                ConcatResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for ConcatResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ConcatResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ConcatResponseProto {
    fn new() -> ConcatResponseProto {
        ConcatResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ConcatResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ConcatResponseProto>(
                    "ConcatResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ConcatResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ConcatResponseProto {
    fn eq(&self, other: &ConcatResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ConcatResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct TruncateRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    newLength: ::std::option::Option<u64>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl TruncateRequestProto {
    pub fn new() -> TruncateRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TruncateRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<TruncateRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TruncateRequestProto,
        };
        unsafe {
            instance.get(|| {
                TruncateRequestProto {
                    src: ::protobuf::SingularField::none(),
                    newLength: ::std::option::Option::None,
                    clientName: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required uint64 newLength = 2;

    pub fn clear_newLength(&mut self) {
        self.newLength = ::std::option::Option::None;
    }

    pub fn has_newLength(&self) -> bool {
        self.newLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newLength(&mut self, v: u64) {
        self.newLength = ::std::option::Option::Some(v);
    }

    pub fn get_newLength<'a>(&self) -> u64 {
        self.newLength.unwrap_or(0)
    }

    // required string clientName = 3;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        };
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName<'a>(&'a self) -> &'a str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TruncateRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.newLength.is_none() {
            return false;
        };
        if self.clientName.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.newLength = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.clientName.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.newLength.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.clientName.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.newLength {
            try!(os.write_uint64(2, v));
        };
        if let Some(v) = self.clientName.as_ref() {
            try!(os.write_string(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<TruncateRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TruncateRequestProto {
    fn new() -> TruncateRequestProto {
        TruncateRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<TruncateRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    TruncateRequestProto::has_src,
                    TruncateRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "newLength",
                    TruncateRequestProto::has_newLength,
                    TruncateRequestProto::get_newLength,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "clientName",
                    TruncateRequestProto::has_clientName,
                    TruncateRequestProto::get_clientName,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TruncateRequestProto>(
                    "TruncateRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TruncateRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_newLength();
        self.clear_clientName();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for TruncateRequestProto {
    fn eq(&self, other: &TruncateRequestProto) -> bool {
        self.src == other.src &&
        self.newLength == other.newLength &&
        self.clientName == other.clientName &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for TruncateRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct TruncateResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl TruncateResponseProto {
    pub fn new() -> TruncateResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TruncateResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<TruncateResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TruncateResponseProto,
        };
        unsafe {
            instance.get(|| {
                TruncateResponseProto {
                    result: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result<'a>(&self) -> bool {
        self.result.unwrap_or(false)
    }
}

impl ::protobuf::Message for TruncateResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            try!(os.write_bool(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<TruncateResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TruncateResponseProto {
    fn new() -> TruncateResponseProto {
        TruncateResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<TruncateResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "result",
                    TruncateResponseProto::has_result,
                    TruncateResponseProto::get_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TruncateResponseProto>(
                    "TruncateResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TruncateResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for TruncateResponseProto {
    fn eq(&self, other: &TruncateResponseProto) -> bool {
        self.result == other.result &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for TruncateResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RenameRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    dst: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RenameRequestProto {
    pub fn new() -> RenameRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenameRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameRequestProto,
        };
        unsafe {
            instance.get(|| {
                RenameRequestProto {
                    src: ::protobuf::SingularField::none(),
                    dst: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string dst = 2;

    pub fn clear_dst(&mut self) {
        self.dst.clear();
    }

    pub fn has_dst(&self) -> bool {
        self.dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst(&mut self, v: ::std::string::String) {
        self.dst = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.dst.is_none() {
            self.dst.set_default();
        };
        self.dst.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst(&mut self) -> ::std::string::String {
        self.dst.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_dst<'a>(&'a self) -> &'a str {
        match self.dst.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RenameRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.dst.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.dst.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.dst.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.dst.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RenameRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenameRequestProto {
    fn new() -> RenameRequestProto {
        RenameRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenameRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    RenameRequestProto::has_src,
                    RenameRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "dst",
                    RenameRequestProto::has_dst,
                    RenameRequestProto::get_dst,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenameRequestProto>(
                    "RenameRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenameRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_dst();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RenameRequestProto {
    fn eq(&self, other: &RenameRequestProto) -> bool {
        self.src == other.src &&
        self.dst == other.dst &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RenameRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RenameResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RenameResponseProto {
    pub fn new() -> RenameResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenameResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameResponseProto,
        };
        unsafe {
            instance.get(|| {
                RenameResponseProto {
                    result: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result<'a>(&self) -> bool {
        self.result.unwrap_or(false)
    }
}

impl ::protobuf::Message for RenameResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            try!(os.write_bool(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RenameResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenameResponseProto {
    fn new() -> RenameResponseProto {
        RenameResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenameResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "result",
                    RenameResponseProto::has_result,
                    RenameResponseProto::get_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenameResponseProto>(
                    "RenameResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenameResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RenameResponseProto {
    fn eq(&self, other: &RenameResponseProto) -> bool {
        self.result == other.result &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RenameResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Rename2RequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    dst: ::protobuf::SingularField<::std::string::String>,
    overwriteDest: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Rename2RequestProto {
    pub fn new() -> Rename2RequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Rename2RequestProto {
        static mut instance: ::protobuf::lazy::Lazy<Rename2RequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Rename2RequestProto,
        };
        unsafe {
            instance.get(|| {
                Rename2RequestProto {
                    src: ::protobuf::SingularField::none(),
                    dst: ::protobuf::SingularField::none(),
                    overwriteDest: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string dst = 2;

    pub fn clear_dst(&mut self) {
        self.dst.clear();
    }

    pub fn has_dst(&self) -> bool {
        self.dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst(&mut self, v: ::std::string::String) {
        self.dst = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.dst.is_none() {
            self.dst.set_default();
        };
        self.dst.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst(&mut self) -> ::std::string::String {
        self.dst.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_dst<'a>(&'a self) -> &'a str {
        match self.dst.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required bool overwriteDest = 3;

    pub fn clear_overwriteDest(&mut self) {
        self.overwriteDest = ::std::option::Option::None;
    }

    pub fn has_overwriteDest(&self) -> bool {
        self.overwriteDest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwriteDest(&mut self, v: bool) {
        self.overwriteDest = ::std::option::Option::Some(v);
    }

    pub fn get_overwriteDest<'a>(&self) -> bool {
        self.overwriteDest.unwrap_or(false)
    }
}

impl ::protobuf::Message for Rename2RequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.dst.is_none() {
            return false;
        };
        if self.overwriteDest.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.dst.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.overwriteDest = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.dst.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.overwriteDest.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.dst.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.overwriteDest {
            try!(os.write_bool(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Rename2RequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Rename2RequestProto {
    fn new() -> Rename2RequestProto {
        Rename2RequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<Rename2RequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    Rename2RequestProto::has_src,
                    Rename2RequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "dst",
                    Rename2RequestProto::has_dst,
                    Rename2RequestProto::get_dst,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "overwriteDest",
                    Rename2RequestProto::has_overwriteDest,
                    Rename2RequestProto::get_overwriteDest,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Rename2RequestProto>(
                    "Rename2RequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Rename2RequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_dst();
        self.clear_overwriteDest();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Rename2RequestProto {
    fn eq(&self, other: &Rename2RequestProto) -> bool {
        self.src == other.src &&
        self.dst == other.dst &&
        self.overwriteDest == other.overwriteDest &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Rename2RequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Rename2ResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Rename2ResponseProto {
    pub fn new() -> Rename2ResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Rename2ResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<Rename2ResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Rename2ResponseProto,
        };
        unsafe {
            instance.get(|| {
                Rename2ResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for Rename2ResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Rename2ResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Rename2ResponseProto {
    fn new() -> Rename2ResponseProto {
        Rename2ResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<Rename2ResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Rename2ResponseProto>(
                    "Rename2ResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Rename2ResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Rename2ResponseProto {
    fn eq(&self, other: &Rename2ResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Rename2ResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct DeleteRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    recursive: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl DeleteRequestProto {
    pub fn new() -> DeleteRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeleteRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteRequestProto,
        };
        unsafe {
            instance.get(|| {
                DeleteRequestProto {
                    src: ::protobuf::SingularField::none(),
                    recursive: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required bool recursive = 2;

    pub fn clear_recursive(&mut self) {
        self.recursive = ::std::option::Option::None;
    }

    pub fn has_recursive(&self) -> bool {
        self.recursive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recursive(&mut self, v: bool) {
        self.recursive = ::std::option::Option::Some(v);
    }

    pub fn get_recursive<'a>(&self) -> bool {
        self.recursive.unwrap_or(false)
    }
}

impl ::protobuf::Message for DeleteRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.recursive.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.recursive = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.recursive.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.recursive {
            try!(os.write_bool(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<DeleteRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeleteRequestProto {
    fn new() -> DeleteRequestProto {
        DeleteRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeleteRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    DeleteRequestProto::has_src,
                    DeleteRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "recursive",
                    DeleteRequestProto::has_recursive,
                    DeleteRequestProto::get_recursive,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteRequestProto>(
                    "DeleteRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeleteRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_recursive();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for DeleteRequestProto {
    fn eq(&self, other: &DeleteRequestProto) -> bool {
        self.src == other.src &&
        self.recursive == other.recursive &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for DeleteRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct DeleteResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl DeleteResponseProto {
    pub fn new() -> DeleteResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeleteResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteResponseProto,
        };
        unsafe {
            instance.get(|| {
                DeleteResponseProto {
                    result: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result<'a>(&self) -> bool {
        self.result.unwrap_or(false)
    }
}

impl ::protobuf::Message for DeleteResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            try!(os.write_bool(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<DeleteResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeleteResponseProto {
    fn new() -> DeleteResponseProto {
        DeleteResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeleteResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "result",
                    DeleteResponseProto::has_result,
                    DeleteResponseProto::get_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteResponseProto>(
                    "DeleteResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeleteResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for DeleteResponseProto {
    fn eq(&self, other: &DeleteResponseProto) -> bool {
        self.result == other.result &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for DeleteResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct MkdirsRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    masked: ::protobuf::SingularPtrField<FsPermissionProto>,
    createParent: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl MkdirsRequestProto {
    pub fn new() -> MkdirsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MkdirsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<MkdirsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MkdirsRequestProto,
        };
        unsafe {
            instance.get(|| {
                MkdirsRequestProto {
                    src: ::protobuf::SingularField::none(),
                    masked: ::protobuf::SingularPtrField::none(),
                    createParent: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .hadoop.hdfs.FsPermissionProto masked = 2;

    pub fn clear_masked(&mut self) {
        self.masked.clear();
    }

    pub fn has_masked(&self) -> bool {
        self.masked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masked(&mut self, v: FsPermissionProto) {
        self.masked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masked<'a>(&'a mut self) -> &'a mut FsPermissionProto {
        if self.masked.is_none() {
            self.masked.set_default();
        };
        self.masked.as_mut().unwrap()
    }

    // Take field
    pub fn take_masked(&mut self) -> FsPermissionProto {
        self.masked.take().unwrap_or_else(|| FsPermissionProto::new())
    }

    pub fn get_masked<'a>(&'a self) -> &'a FsPermissionProto {
        self.masked.as_ref().unwrap_or_else(|| FsPermissionProto::default_instance())
    }

    // required bool createParent = 3;

    pub fn clear_createParent(&mut self) {
        self.createParent = ::std::option::Option::None;
    }

    pub fn has_createParent(&self) -> bool {
        self.createParent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createParent(&mut self, v: bool) {
        self.createParent = ::std::option::Option::Some(v);
    }

    pub fn get_createParent<'a>(&self) -> bool {
        self.createParent.unwrap_or(false)
    }
}

impl ::protobuf::Message for MkdirsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.masked.is_none() {
            return false;
        };
        if self.createParent.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.masked.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.createParent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.masked.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.createParent.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.masked.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.createParent {
            try!(os.write_bool(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<MkdirsRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MkdirsRequestProto {
    fn new() -> MkdirsRequestProto {
        MkdirsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<MkdirsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    MkdirsRequestProto::has_src,
                    MkdirsRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "masked",
                    MkdirsRequestProto::has_masked,
                    MkdirsRequestProto::get_masked,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "createParent",
                    MkdirsRequestProto::has_createParent,
                    MkdirsRequestProto::get_createParent,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MkdirsRequestProto>(
                    "MkdirsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MkdirsRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_masked();
        self.clear_createParent();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for MkdirsRequestProto {
    fn eq(&self, other: &MkdirsRequestProto) -> bool {
        self.src == other.src &&
        self.masked == other.masked &&
        self.createParent == other.createParent &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for MkdirsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct MkdirsResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl MkdirsResponseProto {
    pub fn new() -> MkdirsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MkdirsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<MkdirsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MkdirsResponseProto,
        };
        unsafe {
            instance.get(|| {
                MkdirsResponseProto {
                    result: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result<'a>(&self) -> bool {
        self.result.unwrap_or(false)
    }
}

impl ::protobuf::Message for MkdirsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            try!(os.write_bool(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<MkdirsResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MkdirsResponseProto {
    fn new() -> MkdirsResponseProto {
        MkdirsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<MkdirsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "result",
                    MkdirsResponseProto::has_result,
                    MkdirsResponseProto::get_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MkdirsResponseProto>(
                    "MkdirsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MkdirsResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for MkdirsResponseProto {
    fn eq(&self, other: &MkdirsResponseProto) -> bool {
        self.result == other.result &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for MkdirsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetListingRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    startAfter: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    needLocation: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetListingRequestProto {
    pub fn new() -> GetListingRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetListingRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetListingRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetListingRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetListingRequestProto {
                    src: ::protobuf::SingularField::none(),
                    startAfter: ::protobuf::SingularField::none(),
                    needLocation: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required bytes startAfter = 2;

    pub fn clear_startAfter(&mut self) {
        self.startAfter.clear();
    }

    pub fn has_startAfter(&self) -> bool {
        self.startAfter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startAfter(&mut self, v: ::std::vec::Vec<u8>) {
        self.startAfter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startAfter<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.startAfter.is_none() {
            self.startAfter.set_default();
        };
        self.startAfter.as_mut().unwrap()
    }

    // Take field
    pub fn take_startAfter(&mut self) -> ::std::vec::Vec<u8> {
        self.startAfter.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_startAfter<'a>(&'a self) -> &'a [u8] {
        match self.startAfter.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // required bool needLocation = 3;

    pub fn clear_needLocation(&mut self) {
        self.needLocation = ::std::option::Option::None;
    }

    pub fn has_needLocation(&self) -> bool {
        self.needLocation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needLocation(&mut self, v: bool) {
        self.needLocation = ::std::option::Option::Some(v);
    }

    pub fn get_needLocation<'a>(&self) -> bool {
        self.needLocation.unwrap_or(false)
    }
}

impl ::protobuf::Message for GetListingRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.startAfter.is_none() {
            return false;
        };
        if self.needLocation.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.startAfter.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.needLocation = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.startAfter.iter() {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if self.needLocation.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.startAfter.as_ref() {
            try!(os.write_bytes(2, &v));
        };
        if let Some(v) = self.needLocation {
            try!(os.write_bool(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetListingRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetListingRequestProto {
    fn new() -> GetListingRequestProto {
        GetListingRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetListingRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    GetListingRequestProto::has_src,
                    GetListingRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "startAfter",
                    GetListingRequestProto::has_startAfter,
                    GetListingRequestProto::get_startAfter,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "needLocation",
                    GetListingRequestProto::has_needLocation,
                    GetListingRequestProto::get_needLocation,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetListingRequestProto>(
                    "GetListingRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetListingRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_startAfter();
        self.clear_needLocation();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetListingRequestProto {
    fn eq(&self, other: &GetListingRequestProto) -> bool {
        self.src == other.src &&
        self.startAfter == other.startAfter &&
        self.needLocation == other.needLocation &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetListingRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetListingResponseProto {
    // message fields
    dirList: ::protobuf::SingularPtrField<DirectoryListingProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetListingResponseProto {
    pub fn new() -> GetListingResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetListingResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetListingResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetListingResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetListingResponseProto {
                    dirList: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .hadoop.hdfs.DirectoryListingProto dirList = 1;

    pub fn clear_dirList(&mut self) {
        self.dirList.clear();
    }

    pub fn has_dirList(&self) -> bool {
        self.dirList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirList(&mut self, v: DirectoryListingProto) {
        self.dirList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dirList<'a>(&'a mut self) -> &'a mut DirectoryListingProto {
        if self.dirList.is_none() {
            self.dirList.set_default();
        };
        self.dirList.as_mut().unwrap()
    }

    // Take field
    pub fn take_dirList(&mut self) -> DirectoryListingProto {
        self.dirList.take().unwrap_or_else(|| DirectoryListingProto::new())
    }

    pub fn get_dirList<'a>(&'a self) -> &'a DirectoryListingProto {
        self.dirList.as_ref().unwrap_or_else(|| DirectoryListingProto::default_instance())
    }
}

impl ::protobuf::Message for GetListingResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.dirList.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.dirList.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dirList.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetListingResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetListingResponseProto {
    fn new() -> GetListingResponseProto {
        GetListingResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetListingResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "dirList",
                    GetListingResponseProto::has_dirList,
                    GetListingResponseProto::get_dirList,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetListingResponseProto>(
                    "GetListingResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetListingResponseProto {
    fn clear(&mut self) {
        self.clear_dirList();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetListingResponseProto {
    fn eq(&self, other: &GetListingResponseProto) -> bool {
        self.dirList == other.dirList &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetListingResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetSnapshottableDirListingRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetSnapshottableDirListingRequestProto {
    pub fn new() -> GetSnapshottableDirListingRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetSnapshottableDirListingRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshottableDirListingRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshottableDirListingRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetSnapshottableDirListingRequestProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for GetSnapshottableDirListingRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetSnapshottableDirListingRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetSnapshottableDirListingRequestProto {
    fn new() -> GetSnapshottableDirListingRequestProto {
        GetSnapshottableDirListingRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetSnapshottableDirListingRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshottableDirListingRequestProto>(
                    "GetSnapshottableDirListingRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetSnapshottableDirListingRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetSnapshottableDirListingRequestProto {
    fn eq(&self, other: &GetSnapshottableDirListingRequestProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetSnapshottableDirListingRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetSnapshottableDirListingResponseProto {
    // message fields
    snapshottableDirList: ::protobuf::SingularPtrField<SnapshottableDirectoryListingProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetSnapshottableDirListingResponseProto {
    pub fn new() -> GetSnapshottableDirListingResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetSnapshottableDirListingResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshottableDirListingResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshottableDirListingResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetSnapshottableDirListingResponseProto {
                    snapshottableDirList: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .hadoop.hdfs.SnapshottableDirectoryListingProto snapshottableDirList = 1;

    pub fn clear_snapshottableDirList(&mut self) {
        self.snapshottableDirList.clear();
    }

    pub fn has_snapshottableDirList(&self) -> bool {
        self.snapshottableDirList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshottableDirList(&mut self, v: SnapshottableDirectoryListingProto) {
        self.snapshottableDirList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshottableDirList<'a>(&'a mut self) -> &'a mut SnapshottableDirectoryListingProto {
        if self.snapshottableDirList.is_none() {
            self.snapshottableDirList.set_default();
        };
        self.snapshottableDirList.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshottableDirList(&mut self) -> SnapshottableDirectoryListingProto {
        self.snapshottableDirList.take().unwrap_or_else(|| SnapshottableDirectoryListingProto::new())
    }

    pub fn get_snapshottableDirList<'a>(&'a self) -> &'a SnapshottableDirectoryListingProto {
        self.snapshottableDirList.as_ref().unwrap_or_else(|| SnapshottableDirectoryListingProto::default_instance())
    }
}

impl ::protobuf::Message for GetSnapshottableDirListingResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.snapshottableDirList.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.snapshottableDirList.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.snapshottableDirList.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetSnapshottableDirListingResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetSnapshottableDirListingResponseProto {
    fn new() -> GetSnapshottableDirListingResponseProto {
        GetSnapshottableDirListingResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetSnapshottableDirListingResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "snapshottableDirList",
                    GetSnapshottableDirListingResponseProto::has_snapshottableDirList,
                    GetSnapshottableDirListingResponseProto::get_snapshottableDirList,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshottableDirListingResponseProto>(
                    "GetSnapshottableDirListingResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetSnapshottableDirListingResponseProto {
    fn clear(&mut self) {
        self.clear_snapshottableDirList();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetSnapshottableDirListingResponseProto {
    fn eq(&self, other: &GetSnapshottableDirListingResponseProto) -> bool {
        self.snapshottableDirList == other.snapshottableDirList &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetSnapshottableDirListingResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetSnapshotDiffReportRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    fromSnapshot: ::protobuf::SingularField<::std::string::String>,
    toSnapshot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetSnapshotDiffReportRequestProto {
    pub fn new() -> GetSnapshotDiffReportRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetSnapshotDiffReportRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshotDiffReportRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshotDiffReportRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetSnapshotDiffReportRequestProto {
                    snapshotRoot: ::protobuf::SingularField::none(),
                    fromSnapshot: ::protobuf::SingularField::none(),
                    toSnapshot: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        };
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot<'a>(&'a self) -> &'a str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string fromSnapshot = 2;

    pub fn clear_fromSnapshot(&mut self) {
        self.fromSnapshot.clear();
    }

    pub fn has_fromSnapshot(&self) -> bool {
        self.fromSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromSnapshot(&mut self, v: ::std::string::String) {
        self.fromSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromSnapshot<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.fromSnapshot.is_none() {
            self.fromSnapshot.set_default();
        };
        self.fromSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_fromSnapshot(&mut self) -> ::std::string::String {
        self.fromSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fromSnapshot<'a>(&'a self) -> &'a str {
        match self.fromSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string toSnapshot = 3;

    pub fn clear_toSnapshot(&mut self) {
        self.toSnapshot.clear();
    }

    pub fn has_toSnapshot(&self) -> bool {
        self.toSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toSnapshot(&mut self, v: ::std::string::String) {
        self.toSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toSnapshot<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.toSnapshot.is_none() {
            self.toSnapshot.set_default();
        };
        self.toSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_toSnapshot(&mut self) -> ::std::string::String {
        self.toSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_toSnapshot<'a>(&'a self) -> &'a str {
        match self.toSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for GetSnapshotDiffReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        };
        if self.fromSnapshot.is_none() {
            return false;
        };
        if self.toSnapshot.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.snapshotRoot.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.fromSnapshot.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.toSnapshot.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.snapshotRoot.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.fromSnapshot.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.toSnapshot.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.snapshotRoot.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.fromSnapshot.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.toSnapshot.as_ref() {
            try!(os.write_string(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetSnapshotDiffReportRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetSnapshotDiffReportRequestProto {
    fn new() -> GetSnapshotDiffReportRequestProto {
        GetSnapshotDiffReportRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetSnapshotDiffReportRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "snapshotRoot",
                    GetSnapshotDiffReportRequestProto::has_snapshotRoot,
                    GetSnapshotDiffReportRequestProto::get_snapshotRoot,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "fromSnapshot",
                    GetSnapshotDiffReportRequestProto::has_fromSnapshot,
                    GetSnapshotDiffReportRequestProto::get_fromSnapshot,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "toSnapshot",
                    GetSnapshotDiffReportRequestProto::has_toSnapshot,
                    GetSnapshotDiffReportRequestProto::get_toSnapshot,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshotDiffReportRequestProto>(
                    "GetSnapshotDiffReportRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetSnapshotDiffReportRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.clear_fromSnapshot();
        self.clear_toSnapshot();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetSnapshotDiffReportRequestProto {
    fn eq(&self, other: &GetSnapshotDiffReportRequestProto) -> bool {
        self.snapshotRoot == other.snapshotRoot &&
        self.fromSnapshot == other.fromSnapshot &&
        self.toSnapshot == other.toSnapshot &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetSnapshotDiffReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetSnapshotDiffReportResponseProto {
    // message fields
    diffReport: ::protobuf::SingularPtrField<SnapshotDiffReportProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetSnapshotDiffReportResponseProto {
    pub fn new() -> GetSnapshotDiffReportResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetSnapshotDiffReportResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshotDiffReportResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshotDiffReportResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetSnapshotDiffReportResponseProto {
                    diffReport: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.SnapshotDiffReportProto diffReport = 1;

    pub fn clear_diffReport(&mut self) {
        self.diffReport.clear();
    }

    pub fn has_diffReport(&self) -> bool {
        self.diffReport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diffReport(&mut self, v: SnapshotDiffReportProto) {
        self.diffReport = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_diffReport<'a>(&'a mut self) -> &'a mut SnapshotDiffReportProto {
        if self.diffReport.is_none() {
            self.diffReport.set_default();
        };
        self.diffReport.as_mut().unwrap()
    }

    // Take field
    pub fn take_diffReport(&mut self) -> SnapshotDiffReportProto {
        self.diffReport.take().unwrap_or_else(|| SnapshotDiffReportProto::new())
    }

    pub fn get_diffReport<'a>(&'a self) -> &'a SnapshotDiffReportProto {
        self.diffReport.as_ref().unwrap_or_else(|| SnapshotDiffReportProto::default_instance())
    }
}

impl ::protobuf::Message for GetSnapshotDiffReportResponseProto {
    fn is_initialized(&self) -> bool {
        if self.diffReport.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.diffReport.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.diffReport.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.diffReport.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetSnapshotDiffReportResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetSnapshotDiffReportResponseProto {
    fn new() -> GetSnapshotDiffReportResponseProto {
        GetSnapshotDiffReportResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetSnapshotDiffReportResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "diffReport",
                    GetSnapshotDiffReportResponseProto::has_diffReport,
                    GetSnapshotDiffReportResponseProto::get_diffReport,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshotDiffReportResponseProto>(
                    "GetSnapshotDiffReportResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetSnapshotDiffReportResponseProto {
    fn clear(&mut self) {
        self.clear_diffReport();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetSnapshotDiffReportResponseProto {
    fn eq(&self, other: &GetSnapshotDiffReportResponseProto) -> bool {
        self.diffReport == other.diffReport &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetSnapshotDiffReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RenewLeaseRequestProto {
    // message fields
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RenewLeaseRequestProto {
    pub fn new() -> RenewLeaseRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenewLeaseRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RenewLeaseRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenewLeaseRequestProto,
        };
        unsafe {
            instance.get(|| {
                RenewLeaseRequestProto {
                    clientName: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string clientName = 1;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        };
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName<'a>(&'a self) -> &'a str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RenewLeaseRequestProto {
    fn is_initialized(&self) -> bool {
        if self.clientName.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.clientName.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.clientName.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.clientName.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RenewLeaseRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenewLeaseRequestProto {
    fn new() -> RenewLeaseRequestProto {
        RenewLeaseRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenewLeaseRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "clientName",
                    RenewLeaseRequestProto::has_clientName,
                    RenewLeaseRequestProto::get_clientName,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenewLeaseRequestProto>(
                    "RenewLeaseRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenewLeaseRequestProto {
    fn clear(&mut self) {
        self.clear_clientName();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RenewLeaseRequestProto {
    fn eq(&self, other: &RenewLeaseRequestProto) -> bool {
        self.clientName == other.clientName &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RenewLeaseRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RenewLeaseResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RenewLeaseResponseProto {
    pub fn new() -> RenewLeaseResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenewLeaseResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RenewLeaseResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenewLeaseResponseProto,
        };
        unsafe {
            instance.get(|| {
                RenewLeaseResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for RenewLeaseResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RenewLeaseResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenewLeaseResponseProto {
    fn new() -> RenewLeaseResponseProto {
        RenewLeaseResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenewLeaseResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RenewLeaseResponseProto>(
                    "RenewLeaseResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenewLeaseResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RenewLeaseResponseProto {
    fn eq(&self, other: &RenewLeaseResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RenewLeaseResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RecoverLeaseRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RecoverLeaseRequestProto {
    pub fn new() -> RecoverLeaseRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RecoverLeaseRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RecoverLeaseRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RecoverLeaseRequestProto,
        };
        unsafe {
            instance.get(|| {
                RecoverLeaseRequestProto {
                    src: ::protobuf::SingularField::none(),
                    clientName: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string clientName = 2;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        };
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName<'a>(&'a self) -> &'a str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RecoverLeaseRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.clientName.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.clientName.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.clientName.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.clientName.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RecoverLeaseRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RecoverLeaseRequestProto {
    fn new() -> RecoverLeaseRequestProto {
        RecoverLeaseRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RecoverLeaseRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    RecoverLeaseRequestProto::has_src,
                    RecoverLeaseRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "clientName",
                    RecoverLeaseRequestProto::has_clientName,
                    RecoverLeaseRequestProto::get_clientName,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RecoverLeaseRequestProto>(
                    "RecoverLeaseRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RecoverLeaseRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_clientName();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RecoverLeaseRequestProto {
    fn eq(&self, other: &RecoverLeaseRequestProto) -> bool {
        self.src == other.src &&
        self.clientName == other.clientName &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RecoverLeaseRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RecoverLeaseResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RecoverLeaseResponseProto {
    pub fn new() -> RecoverLeaseResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RecoverLeaseResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RecoverLeaseResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RecoverLeaseResponseProto,
        };
        unsafe {
            instance.get(|| {
                RecoverLeaseResponseProto {
                    result: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result<'a>(&self) -> bool {
        self.result.unwrap_or(false)
    }
}

impl ::protobuf::Message for RecoverLeaseResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            try!(os.write_bool(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RecoverLeaseResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RecoverLeaseResponseProto {
    fn new() -> RecoverLeaseResponseProto {
        RecoverLeaseResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RecoverLeaseResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "result",
                    RecoverLeaseResponseProto::has_result,
                    RecoverLeaseResponseProto::get_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RecoverLeaseResponseProto>(
                    "RecoverLeaseResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RecoverLeaseResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RecoverLeaseResponseProto {
    fn eq(&self, other: &RecoverLeaseResponseProto) -> bool {
        self.result == other.result &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RecoverLeaseResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetFsStatusRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetFsStatusRequestProto {
    pub fn new() -> GetFsStatusRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFsStatusRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFsStatusRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFsStatusRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetFsStatusRequestProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for GetFsStatusRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetFsStatusRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFsStatusRequestProto {
    fn new() -> GetFsStatusRequestProto {
        GetFsStatusRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFsStatusRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetFsStatusRequestProto>(
                    "GetFsStatusRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFsStatusRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetFsStatusRequestProto {
    fn eq(&self, other: &GetFsStatusRequestProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetFsStatusRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetFsStatsResponseProto {
    // message fields
    capacity: ::std::option::Option<u64>,
    used: ::std::option::Option<u64>,
    remaining: ::std::option::Option<u64>,
    under_replicated: ::std::option::Option<u64>,
    corrupt_blocks: ::std::option::Option<u64>,
    missing_blocks: ::std::option::Option<u64>,
    missing_repl_one_blocks: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetFsStatsResponseProto {
    pub fn new() -> GetFsStatsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFsStatsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFsStatsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFsStatsResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetFsStatsResponseProto {
                    capacity: ::std::option::Option::None,
                    used: ::std::option::Option::None,
                    remaining: ::std::option::Option::None,
                    under_replicated: ::std::option::Option::None,
                    corrupt_blocks: ::std::option::Option::None,
                    missing_blocks: ::std::option::Option::None,
                    missing_repl_one_blocks: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required uint64 capacity = 1;

    pub fn clear_capacity(&mut self) {
        self.capacity = ::std::option::Option::None;
    }

    pub fn has_capacity(&self) -> bool {
        self.capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: u64) {
        self.capacity = ::std::option::Option::Some(v);
    }

    pub fn get_capacity<'a>(&self) -> u64 {
        self.capacity.unwrap_or(0)
    }

    // required uint64 used = 2;

    pub fn clear_used(&mut self) {
        self.used = ::std::option::Option::None;
    }

    pub fn has_used(&self) -> bool {
        self.used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_used(&mut self, v: u64) {
        self.used = ::std::option::Option::Some(v);
    }

    pub fn get_used<'a>(&self) -> u64 {
        self.used.unwrap_or(0)
    }

    // required uint64 remaining = 3;

    pub fn clear_remaining(&mut self) {
        self.remaining = ::std::option::Option::None;
    }

    pub fn has_remaining(&self) -> bool {
        self.remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remaining(&mut self, v: u64) {
        self.remaining = ::std::option::Option::Some(v);
    }

    pub fn get_remaining<'a>(&self) -> u64 {
        self.remaining.unwrap_or(0)
    }

    // required uint64 under_replicated = 4;

    pub fn clear_under_replicated(&mut self) {
        self.under_replicated = ::std::option::Option::None;
    }

    pub fn has_under_replicated(&self) -> bool {
        self.under_replicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_under_replicated(&mut self, v: u64) {
        self.under_replicated = ::std::option::Option::Some(v);
    }

    pub fn get_under_replicated<'a>(&self) -> u64 {
        self.under_replicated.unwrap_or(0)
    }

    // required uint64 corrupt_blocks = 5;

    pub fn clear_corrupt_blocks(&mut self) {
        self.corrupt_blocks = ::std::option::Option::None;
    }

    pub fn has_corrupt_blocks(&self) -> bool {
        self.corrupt_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt_blocks(&mut self, v: u64) {
        self.corrupt_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_corrupt_blocks<'a>(&self) -> u64 {
        self.corrupt_blocks.unwrap_or(0)
    }

    // required uint64 missing_blocks = 6;

    pub fn clear_missing_blocks(&mut self) {
        self.missing_blocks = ::std::option::Option::None;
    }

    pub fn has_missing_blocks(&self) -> bool {
        self.missing_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_blocks(&mut self, v: u64) {
        self.missing_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_missing_blocks<'a>(&self) -> u64 {
        self.missing_blocks.unwrap_or(0)
    }

    // optional uint64 missing_repl_one_blocks = 7;

    pub fn clear_missing_repl_one_blocks(&mut self) {
        self.missing_repl_one_blocks = ::std::option::Option::None;
    }

    pub fn has_missing_repl_one_blocks(&self) -> bool {
        self.missing_repl_one_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_repl_one_blocks(&mut self, v: u64) {
        self.missing_repl_one_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_missing_repl_one_blocks<'a>(&self) -> u64 {
        self.missing_repl_one_blocks.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetFsStatsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.capacity.is_none() {
            return false;
        };
        if self.used.is_none() {
            return false;
        };
        if self.remaining.is_none() {
            return false;
        };
        if self.under_replicated.is_none() {
            return false;
        };
        if self.corrupt_blocks.is_none() {
            return false;
        };
        if self.missing_blocks.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.capacity = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.used = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.remaining = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.under_replicated = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.corrupt_blocks = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.missing_blocks = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.missing_repl_one_blocks = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.capacity.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.used.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.remaining.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.under_replicated.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.corrupt_blocks.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.missing_blocks.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.missing_repl_one_blocks.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.capacity {
            try!(os.write_uint64(1, v));
        };
        if let Some(v) = self.used {
            try!(os.write_uint64(2, v));
        };
        if let Some(v) = self.remaining {
            try!(os.write_uint64(3, v));
        };
        if let Some(v) = self.under_replicated {
            try!(os.write_uint64(4, v));
        };
        if let Some(v) = self.corrupt_blocks {
            try!(os.write_uint64(5, v));
        };
        if let Some(v) = self.missing_blocks {
            try!(os.write_uint64(6, v));
        };
        if let Some(v) = self.missing_repl_one_blocks {
            try!(os.write_uint64(7, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetFsStatsResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFsStatsResponseProto {
    fn new() -> GetFsStatsResponseProto {
        GetFsStatsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFsStatsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "capacity",
                    GetFsStatsResponseProto::has_capacity,
                    GetFsStatsResponseProto::get_capacity,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "used",
                    GetFsStatsResponseProto::has_used,
                    GetFsStatsResponseProto::get_used,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "remaining",
                    GetFsStatsResponseProto::has_remaining,
                    GetFsStatsResponseProto::get_remaining,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "under_replicated",
                    GetFsStatsResponseProto::has_under_replicated,
                    GetFsStatsResponseProto::get_under_replicated,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "corrupt_blocks",
                    GetFsStatsResponseProto::has_corrupt_blocks,
                    GetFsStatsResponseProto::get_corrupt_blocks,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "missing_blocks",
                    GetFsStatsResponseProto::has_missing_blocks,
                    GetFsStatsResponseProto::get_missing_blocks,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "missing_repl_one_blocks",
                    GetFsStatsResponseProto::has_missing_repl_one_blocks,
                    GetFsStatsResponseProto::get_missing_repl_one_blocks,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFsStatsResponseProto>(
                    "GetFsStatsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFsStatsResponseProto {
    fn clear(&mut self) {
        self.clear_capacity();
        self.clear_used();
        self.clear_remaining();
        self.clear_under_replicated();
        self.clear_corrupt_blocks();
        self.clear_missing_blocks();
        self.clear_missing_repl_one_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetFsStatsResponseProto {
    fn eq(&self, other: &GetFsStatsResponseProto) -> bool {
        self.capacity == other.capacity &&
        self.used == other.used &&
        self.remaining == other.remaining &&
        self.under_replicated == other.under_replicated &&
        self.corrupt_blocks == other.corrupt_blocks &&
        self.missing_blocks == other.missing_blocks &&
        self.missing_repl_one_blocks == other.missing_repl_one_blocks &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetFsStatsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetDatanodeReportRequestProto {
    // message fields
    field_type: ::std::option::Option<DatanodeReportTypeProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetDatanodeReportRequestProto {
    pub fn new() -> GetDatanodeReportRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDatanodeReportRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeReportRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeReportRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetDatanodeReportRequestProto {
                    field_type: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.DatanodeReportTypeProto type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DatanodeReportTypeProto) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> DatanodeReportTypeProto {
        self.field_type.unwrap_or(DatanodeReportTypeProto::ALL)
    }
}

impl ::protobuf::Message for GetDatanodeReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v as i32));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetDatanodeReportRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDatanodeReportRequestProto {
    fn new() -> GetDatanodeReportRequestProto {
        GetDatanodeReportRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDatanodeReportRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "field_type",
                    GetDatanodeReportRequestProto::has_field_type,
                    GetDatanodeReportRequestProto::get_field_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeReportRequestProto>(
                    "GetDatanodeReportRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDatanodeReportRequestProto {
    fn clear(&mut self) {
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetDatanodeReportRequestProto {
    fn eq(&self, other: &GetDatanodeReportRequestProto) -> bool {
        self.field_type == other.field_type &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetDatanodeReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetDatanodeReportResponseProto {
    // message fields
    di: ::protobuf::RepeatedField<DatanodeInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetDatanodeReportResponseProto {
    pub fn new() -> GetDatanodeReportResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDatanodeReportResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeReportResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeReportResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetDatanodeReportResponseProto {
                    di: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto di = 1;

    pub fn clear_di(&mut self) {
        self.di.clear();
    }

    // Param is passed by value, moved
    pub fn set_di(&mut self, v: ::protobuf::RepeatedField<DatanodeInfoProto>) {
        self.di = v;
    }

    // Mutable pointer to the field.
    pub fn mut_di<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<DatanodeInfoProto> {
        &mut self.di
    }

    // Take field
    pub fn take_di(&mut self) -> ::protobuf::RepeatedField<DatanodeInfoProto> {
        ::std::mem::replace(&mut self.di, ::protobuf::RepeatedField::new())
    }

    pub fn get_di<'a>(&'a self) -> &'a [DatanodeInfoProto] {
        &self.di
    }
}

impl ::protobuf::Message for GetDatanodeReportResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.di));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.di.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.di.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetDatanodeReportResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDatanodeReportResponseProto {
    fn new() -> GetDatanodeReportResponseProto {
        GetDatanodeReportResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDatanodeReportResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "di",
                    GetDatanodeReportResponseProto::get_di,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeReportResponseProto>(
                    "GetDatanodeReportResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDatanodeReportResponseProto {
    fn clear(&mut self) {
        self.clear_di();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetDatanodeReportResponseProto {
    fn eq(&self, other: &GetDatanodeReportResponseProto) -> bool {
        self.di == other.di &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetDatanodeReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetDatanodeStorageReportRequestProto {
    // message fields
    field_type: ::std::option::Option<DatanodeReportTypeProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetDatanodeStorageReportRequestProto {
    pub fn new() -> GetDatanodeStorageReportRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDatanodeStorageReportRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeStorageReportRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeStorageReportRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetDatanodeStorageReportRequestProto {
                    field_type: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.DatanodeReportTypeProto type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DatanodeReportTypeProto) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> DatanodeReportTypeProto {
        self.field_type.unwrap_or(DatanodeReportTypeProto::ALL)
    }
}

impl ::protobuf::Message for GetDatanodeStorageReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v as i32));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetDatanodeStorageReportRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDatanodeStorageReportRequestProto {
    fn new() -> GetDatanodeStorageReportRequestProto {
        GetDatanodeStorageReportRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDatanodeStorageReportRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "field_type",
                    GetDatanodeStorageReportRequestProto::has_field_type,
                    GetDatanodeStorageReportRequestProto::get_field_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeStorageReportRequestProto>(
                    "GetDatanodeStorageReportRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDatanodeStorageReportRequestProto {
    fn clear(&mut self) {
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetDatanodeStorageReportRequestProto {
    fn eq(&self, other: &GetDatanodeStorageReportRequestProto) -> bool {
        self.field_type == other.field_type &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetDatanodeStorageReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct DatanodeStorageReportProto {
    // message fields
    datanodeInfo: ::protobuf::SingularPtrField<DatanodeInfoProto>,
    storageReports: ::protobuf::RepeatedField<StorageReportProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl DatanodeStorageReportProto {
    pub fn new() -> DatanodeStorageReportProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DatanodeStorageReportProto {
        static mut instance: ::protobuf::lazy::Lazy<DatanodeStorageReportProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DatanodeStorageReportProto,
        };
        unsafe {
            instance.get(|| {
                DatanodeStorageReportProto {
                    datanodeInfo: ::protobuf::SingularPtrField::none(),
                    storageReports: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.DatanodeInfoProto datanodeInfo = 1;

    pub fn clear_datanodeInfo(&mut self) {
        self.datanodeInfo.clear();
    }

    pub fn has_datanodeInfo(&self) -> bool {
        self.datanodeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datanodeInfo(&mut self, v: DatanodeInfoProto) {
        self.datanodeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datanodeInfo<'a>(&'a mut self) -> &'a mut DatanodeInfoProto {
        if self.datanodeInfo.is_none() {
            self.datanodeInfo.set_default();
        };
        self.datanodeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_datanodeInfo(&mut self) -> DatanodeInfoProto {
        self.datanodeInfo.take().unwrap_or_else(|| DatanodeInfoProto::new())
    }

    pub fn get_datanodeInfo<'a>(&'a self) -> &'a DatanodeInfoProto {
        self.datanodeInfo.as_ref().unwrap_or_else(|| DatanodeInfoProto::default_instance())
    }

    // repeated .hadoop.hdfs.StorageReportProto storageReports = 2;

    pub fn clear_storageReports(&mut self) {
        self.storageReports.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageReports(&mut self, v: ::protobuf::RepeatedField<StorageReportProto>) {
        self.storageReports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageReports<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<StorageReportProto> {
        &mut self.storageReports
    }

    // Take field
    pub fn take_storageReports(&mut self) -> ::protobuf::RepeatedField<StorageReportProto> {
        ::std::mem::replace(&mut self.storageReports, ::protobuf::RepeatedField::new())
    }

    pub fn get_storageReports<'a>(&'a self) -> &'a [StorageReportProto] {
        &self.storageReports
    }
}

impl ::protobuf::Message for DatanodeStorageReportProto {
    fn is_initialized(&self) -> bool {
        if self.datanodeInfo.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.datanodeInfo.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.storageReports));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.datanodeInfo.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.storageReports.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.datanodeInfo.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.storageReports.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<DatanodeStorageReportProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DatanodeStorageReportProto {
    fn new() -> DatanodeStorageReportProto {
        DatanodeStorageReportProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DatanodeStorageReportProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "datanodeInfo",
                    DatanodeStorageReportProto::has_datanodeInfo,
                    DatanodeStorageReportProto::get_datanodeInfo,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "storageReports",
                    DatanodeStorageReportProto::get_storageReports,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DatanodeStorageReportProto>(
                    "DatanodeStorageReportProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DatanodeStorageReportProto {
    fn clear(&mut self) {
        self.clear_datanodeInfo();
        self.clear_storageReports();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for DatanodeStorageReportProto {
    fn eq(&self, other: &DatanodeStorageReportProto) -> bool {
        self.datanodeInfo == other.datanodeInfo &&
        self.storageReports == other.storageReports &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for DatanodeStorageReportProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetDatanodeStorageReportResponseProto {
    // message fields
    datanodeStorageReports: ::protobuf::RepeatedField<DatanodeStorageReportProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetDatanodeStorageReportResponseProto {
    pub fn new() -> GetDatanodeStorageReportResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDatanodeStorageReportResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeStorageReportResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeStorageReportResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetDatanodeStorageReportResponseProto {
                    datanodeStorageReports: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .hadoop.hdfs.DatanodeStorageReportProto datanodeStorageReports = 1;

    pub fn clear_datanodeStorageReports(&mut self) {
        self.datanodeStorageReports.clear();
    }

    // Param is passed by value, moved
    pub fn set_datanodeStorageReports(&mut self, v: ::protobuf::RepeatedField<DatanodeStorageReportProto>) {
        self.datanodeStorageReports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_datanodeStorageReports<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<DatanodeStorageReportProto> {
        &mut self.datanodeStorageReports
    }

    // Take field
    pub fn take_datanodeStorageReports(&mut self) -> ::protobuf::RepeatedField<DatanodeStorageReportProto> {
        ::std::mem::replace(&mut self.datanodeStorageReports, ::protobuf::RepeatedField::new())
    }

    pub fn get_datanodeStorageReports<'a>(&'a self) -> &'a [DatanodeStorageReportProto] {
        &self.datanodeStorageReports
    }
}

impl ::protobuf::Message for GetDatanodeStorageReportResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.datanodeStorageReports));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.datanodeStorageReports.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.datanodeStorageReports.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetDatanodeStorageReportResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDatanodeStorageReportResponseProto {
    fn new() -> GetDatanodeStorageReportResponseProto {
        GetDatanodeStorageReportResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDatanodeStorageReportResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "datanodeStorageReports",
                    GetDatanodeStorageReportResponseProto::get_datanodeStorageReports,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeStorageReportResponseProto>(
                    "GetDatanodeStorageReportResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDatanodeStorageReportResponseProto {
    fn clear(&mut self) {
        self.clear_datanodeStorageReports();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetDatanodeStorageReportResponseProto {
    fn eq(&self, other: &GetDatanodeStorageReportResponseProto) -> bool {
        self.datanodeStorageReports == other.datanodeStorageReports &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetDatanodeStorageReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetPreferredBlockSizeRequestProto {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetPreferredBlockSizeRequestProto {
    pub fn new() -> GetPreferredBlockSizeRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetPreferredBlockSizeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetPreferredBlockSizeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPreferredBlockSizeRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetPreferredBlockSizeRequestProto {
                    filename: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string filename = 1;

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        };
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_filename<'a>(&'a self) -> &'a str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for GetPreferredBlockSizeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.filename.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.filename.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.filename.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.filename.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetPreferredBlockSizeRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetPreferredBlockSizeRequestProto {
    fn new() -> GetPreferredBlockSizeRequestProto {
        GetPreferredBlockSizeRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetPreferredBlockSizeRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "filename",
                    GetPreferredBlockSizeRequestProto::has_filename,
                    GetPreferredBlockSizeRequestProto::get_filename,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPreferredBlockSizeRequestProto>(
                    "GetPreferredBlockSizeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetPreferredBlockSizeRequestProto {
    fn clear(&mut self) {
        self.clear_filename();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetPreferredBlockSizeRequestProto {
    fn eq(&self, other: &GetPreferredBlockSizeRequestProto) -> bool {
        self.filename == other.filename &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetPreferredBlockSizeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetPreferredBlockSizeResponseProto {
    // message fields
    bsize: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetPreferredBlockSizeResponseProto {
    pub fn new() -> GetPreferredBlockSizeResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetPreferredBlockSizeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetPreferredBlockSizeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPreferredBlockSizeResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetPreferredBlockSizeResponseProto {
                    bsize: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required uint64 bsize = 1;

    pub fn clear_bsize(&mut self) {
        self.bsize = ::std::option::Option::None;
    }

    pub fn has_bsize(&self) -> bool {
        self.bsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bsize(&mut self, v: u64) {
        self.bsize = ::std::option::Option::Some(v);
    }

    pub fn get_bsize<'a>(&self) -> u64 {
        self.bsize.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetPreferredBlockSizeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.bsize.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.bsize = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.bsize.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bsize {
            try!(os.write_uint64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetPreferredBlockSizeResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetPreferredBlockSizeResponseProto {
    fn new() -> GetPreferredBlockSizeResponseProto {
        GetPreferredBlockSizeResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetPreferredBlockSizeResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "bsize",
                    GetPreferredBlockSizeResponseProto::has_bsize,
                    GetPreferredBlockSizeResponseProto::get_bsize,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPreferredBlockSizeResponseProto>(
                    "GetPreferredBlockSizeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetPreferredBlockSizeResponseProto {
    fn clear(&mut self) {
        self.clear_bsize();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetPreferredBlockSizeResponseProto {
    fn eq(&self, other: &GetPreferredBlockSizeResponseProto) -> bool {
        self.bsize == other.bsize &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetPreferredBlockSizeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetSafeModeRequestProto {
    // message fields
    action: ::std::option::Option<SafeModeActionProto>,
    checked: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetSafeModeRequestProto {
    pub fn new() -> SetSafeModeRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetSafeModeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetSafeModeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetSafeModeRequestProto,
        };
        unsafe {
            instance.get(|| {
                SetSafeModeRequestProto {
                    action: ::std::option::Option::None,
                    checked: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.SafeModeActionProto action = 1;

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: SafeModeActionProto) {
        self.action = ::std::option::Option::Some(v);
    }

    pub fn get_action<'a>(&self) -> SafeModeActionProto {
        self.action.unwrap_or(SafeModeActionProto::SAFEMODE_LEAVE)
    }

    // optional bool checked = 2;

    pub fn clear_checked(&mut self) {
        self.checked = ::std::option::Option::None;
    }

    pub fn has_checked(&self) -> bool {
        self.checked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checked(&mut self, v: bool) {
        self.checked = ::std::option::Option::Some(v);
    }

    pub fn get_checked<'a>(&self) -> bool {
        self.checked.unwrap_or(false)
    }
}

impl ::protobuf::Message for SetSafeModeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.action = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.checked = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.action.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        if self.checked.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            try!(os.write_enum(1, v as i32));
        };
        if let Some(v) = self.checked {
            try!(os.write_bool(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetSafeModeRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetSafeModeRequestProto {
    fn new() -> SetSafeModeRequestProto {
        SetSafeModeRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetSafeModeRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "action",
                    SetSafeModeRequestProto::has_action,
                    SetSafeModeRequestProto::get_action,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "checked",
                    SetSafeModeRequestProto::has_checked,
                    SetSafeModeRequestProto::get_checked,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetSafeModeRequestProto>(
                    "SetSafeModeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetSafeModeRequestProto {
    fn clear(&mut self) {
        self.clear_action();
        self.clear_checked();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetSafeModeRequestProto {
    fn eq(&self, other: &SetSafeModeRequestProto) -> bool {
        self.action == other.action &&
        self.checked == other.checked &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetSafeModeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetSafeModeResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetSafeModeResponseProto {
    pub fn new() -> SetSafeModeResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetSafeModeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetSafeModeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetSafeModeResponseProto,
        };
        unsafe {
            instance.get(|| {
                SetSafeModeResponseProto {
                    result: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result<'a>(&self) -> bool {
        self.result.unwrap_or(false)
    }
}

impl ::protobuf::Message for SetSafeModeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            try!(os.write_bool(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetSafeModeResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetSafeModeResponseProto {
    fn new() -> SetSafeModeResponseProto {
        SetSafeModeResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetSafeModeResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "result",
                    SetSafeModeResponseProto::has_result,
                    SetSafeModeResponseProto::get_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetSafeModeResponseProto>(
                    "SetSafeModeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetSafeModeResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetSafeModeResponseProto {
    fn eq(&self, other: &SetSafeModeResponseProto) -> bool {
        self.result == other.result &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetSafeModeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SaveNamespaceRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SaveNamespaceRequestProto {
    pub fn new() -> SaveNamespaceRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SaveNamespaceRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SaveNamespaceRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SaveNamespaceRequestProto,
        };
        unsafe {
            instance.get(|| {
                SaveNamespaceRequestProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for SaveNamespaceRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SaveNamespaceRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SaveNamespaceRequestProto {
    fn new() -> SaveNamespaceRequestProto {
        SaveNamespaceRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SaveNamespaceRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SaveNamespaceRequestProto>(
                    "SaveNamespaceRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SaveNamespaceRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SaveNamespaceRequestProto {
    fn eq(&self, other: &SaveNamespaceRequestProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SaveNamespaceRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SaveNamespaceResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SaveNamespaceResponseProto {
    pub fn new() -> SaveNamespaceResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SaveNamespaceResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SaveNamespaceResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SaveNamespaceResponseProto,
        };
        unsafe {
            instance.get(|| {
                SaveNamespaceResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for SaveNamespaceResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SaveNamespaceResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SaveNamespaceResponseProto {
    fn new() -> SaveNamespaceResponseProto {
        SaveNamespaceResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SaveNamespaceResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SaveNamespaceResponseProto>(
                    "SaveNamespaceResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SaveNamespaceResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SaveNamespaceResponseProto {
    fn eq(&self, other: &SaveNamespaceResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SaveNamespaceResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RollEditsRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RollEditsRequestProto {
    pub fn new() -> RollEditsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RollEditsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RollEditsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollEditsRequestProto,
        };
        unsafe {
            instance.get(|| {
                RollEditsRequestProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for RollEditsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RollEditsRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RollEditsRequestProto {
    fn new() -> RollEditsRequestProto {
        RollEditsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RollEditsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RollEditsRequestProto>(
                    "RollEditsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RollEditsRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RollEditsRequestProto {
    fn eq(&self, other: &RollEditsRequestProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RollEditsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RollEditsResponseProto {
    // message fields
    newSegmentTxId: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RollEditsResponseProto {
    pub fn new() -> RollEditsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RollEditsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RollEditsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollEditsResponseProto,
        };
        unsafe {
            instance.get(|| {
                RollEditsResponseProto {
                    newSegmentTxId: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required uint64 newSegmentTxId = 1;

    pub fn clear_newSegmentTxId(&mut self) {
        self.newSegmentTxId = ::std::option::Option::None;
    }

    pub fn has_newSegmentTxId(&self) -> bool {
        self.newSegmentTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newSegmentTxId(&mut self, v: u64) {
        self.newSegmentTxId = ::std::option::Option::Some(v);
    }

    pub fn get_newSegmentTxId<'a>(&self) -> u64 {
        self.newSegmentTxId.unwrap_or(0)
    }
}

impl ::protobuf::Message for RollEditsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.newSegmentTxId.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.newSegmentTxId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.newSegmentTxId.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.newSegmentTxId {
            try!(os.write_uint64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RollEditsResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RollEditsResponseProto {
    fn new() -> RollEditsResponseProto {
        RollEditsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RollEditsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "newSegmentTxId",
                    RollEditsResponseProto::has_newSegmentTxId,
                    RollEditsResponseProto::get_newSegmentTxId,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollEditsResponseProto>(
                    "RollEditsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RollEditsResponseProto {
    fn clear(&mut self) {
        self.clear_newSegmentTxId();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RollEditsResponseProto {
    fn eq(&self, other: &RollEditsResponseProto) -> bool {
        self.newSegmentTxId == other.newSegmentTxId &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RollEditsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RestoreFailedStorageRequestProto {
    // message fields
    arg: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RestoreFailedStorageRequestProto {
    pub fn new() -> RestoreFailedStorageRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RestoreFailedStorageRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RestoreFailedStorageRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RestoreFailedStorageRequestProto,
        };
        unsafe {
            instance.get(|| {
                RestoreFailedStorageRequestProto {
                    arg: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string arg = 1;

    pub fn clear_arg(&mut self) {
        self.arg.clear();
    }

    pub fn has_arg(&self) -> bool {
        self.arg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arg(&mut self, v: ::std::string::String) {
        self.arg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arg<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.arg.is_none() {
            self.arg.set_default();
        };
        self.arg.as_mut().unwrap()
    }

    // Take field
    pub fn take_arg(&mut self) -> ::std::string::String {
        self.arg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_arg<'a>(&'a self) -> &'a str {
        match self.arg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RestoreFailedStorageRequestProto {
    fn is_initialized(&self) -> bool {
        if self.arg.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.arg.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.arg.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.arg.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RestoreFailedStorageRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RestoreFailedStorageRequestProto {
    fn new() -> RestoreFailedStorageRequestProto {
        RestoreFailedStorageRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RestoreFailedStorageRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "arg",
                    RestoreFailedStorageRequestProto::has_arg,
                    RestoreFailedStorageRequestProto::get_arg,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RestoreFailedStorageRequestProto>(
                    "RestoreFailedStorageRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RestoreFailedStorageRequestProto {
    fn clear(&mut self) {
        self.clear_arg();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RestoreFailedStorageRequestProto {
    fn eq(&self, other: &RestoreFailedStorageRequestProto) -> bool {
        self.arg == other.arg &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RestoreFailedStorageRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RestoreFailedStorageResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RestoreFailedStorageResponseProto {
    pub fn new() -> RestoreFailedStorageResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RestoreFailedStorageResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RestoreFailedStorageResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RestoreFailedStorageResponseProto,
        };
        unsafe {
            instance.get(|| {
                RestoreFailedStorageResponseProto {
                    result: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result<'a>(&self) -> bool {
        self.result.unwrap_or(false)
    }
}

impl ::protobuf::Message for RestoreFailedStorageResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            try!(os.write_bool(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RestoreFailedStorageResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RestoreFailedStorageResponseProto {
    fn new() -> RestoreFailedStorageResponseProto {
        RestoreFailedStorageResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RestoreFailedStorageResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "result",
                    RestoreFailedStorageResponseProto::has_result,
                    RestoreFailedStorageResponseProto::get_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RestoreFailedStorageResponseProto>(
                    "RestoreFailedStorageResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RestoreFailedStorageResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RestoreFailedStorageResponseProto {
    fn eq(&self, other: &RestoreFailedStorageResponseProto) -> bool {
        self.result == other.result &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RestoreFailedStorageResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RefreshNodesRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RefreshNodesRequestProto {
    pub fn new() -> RefreshNodesRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RefreshNodesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RefreshNodesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RefreshNodesRequestProto,
        };
        unsafe {
            instance.get(|| {
                RefreshNodesRequestProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for RefreshNodesRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RefreshNodesRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RefreshNodesRequestProto {
    fn new() -> RefreshNodesRequestProto {
        RefreshNodesRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RefreshNodesRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RefreshNodesRequestProto>(
                    "RefreshNodesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RefreshNodesRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RefreshNodesRequestProto {
    fn eq(&self, other: &RefreshNodesRequestProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RefreshNodesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RefreshNodesResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RefreshNodesResponseProto {
    pub fn new() -> RefreshNodesResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RefreshNodesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RefreshNodesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RefreshNodesResponseProto,
        };
        unsafe {
            instance.get(|| {
                RefreshNodesResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for RefreshNodesResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RefreshNodesResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RefreshNodesResponseProto {
    fn new() -> RefreshNodesResponseProto {
        RefreshNodesResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RefreshNodesResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RefreshNodesResponseProto>(
                    "RefreshNodesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RefreshNodesResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RefreshNodesResponseProto {
    fn eq(&self, other: &RefreshNodesResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RefreshNodesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct FinalizeUpgradeRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl FinalizeUpgradeRequestProto {
    pub fn new() -> FinalizeUpgradeRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FinalizeUpgradeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<FinalizeUpgradeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FinalizeUpgradeRequestProto,
        };
        unsafe {
            instance.get(|| {
                FinalizeUpgradeRequestProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for FinalizeUpgradeRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<FinalizeUpgradeRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FinalizeUpgradeRequestProto {
    fn new() -> FinalizeUpgradeRequestProto {
        FinalizeUpgradeRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<FinalizeUpgradeRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FinalizeUpgradeRequestProto>(
                    "FinalizeUpgradeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FinalizeUpgradeRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for FinalizeUpgradeRequestProto {
    fn eq(&self, other: &FinalizeUpgradeRequestProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for FinalizeUpgradeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct FinalizeUpgradeResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl FinalizeUpgradeResponseProto {
    pub fn new() -> FinalizeUpgradeResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FinalizeUpgradeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<FinalizeUpgradeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FinalizeUpgradeResponseProto,
        };
        unsafe {
            instance.get(|| {
                FinalizeUpgradeResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for FinalizeUpgradeResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<FinalizeUpgradeResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FinalizeUpgradeResponseProto {
    fn new() -> FinalizeUpgradeResponseProto {
        FinalizeUpgradeResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<FinalizeUpgradeResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FinalizeUpgradeResponseProto>(
                    "FinalizeUpgradeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FinalizeUpgradeResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for FinalizeUpgradeResponseProto {
    fn eq(&self, other: &FinalizeUpgradeResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for FinalizeUpgradeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RollingUpgradeRequestProto {
    // message fields
    action: ::std::option::Option<RollingUpgradeActionProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RollingUpgradeRequestProto {
    pub fn new() -> RollingUpgradeRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RollingUpgradeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RollingUpgradeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollingUpgradeRequestProto,
        };
        unsafe {
            instance.get(|| {
                RollingUpgradeRequestProto {
                    action: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.RollingUpgradeActionProto action = 1;

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: RollingUpgradeActionProto) {
        self.action = ::std::option::Option::Some(v);
    }

    pub fn get_action<'a>(&self) -> RollingUpgradeActionProto {
        self.action.unwrap_or(RollingUpgradeActionProto::QUERY)
    }
}

impl ::protobuf::Message for RollingUpgradeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.action = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.action.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            try!(os.write_enum(1, v as i32));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RollingUpgradeRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RollingUpgradeRequestProto {
    fn new() -> RollingUpgradeRequestProto {
        RollingUpgradeRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RollingUpgradeRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "action",
                    RollingUpgradeRequestProto::has_action,
                    RollingUpgradeRequestProto::get_action,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollingUpgradeRequestProto>(
                    "RollingUpgradeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RollingUpgradeRequestProto {
    fn clear(&mut self) {
        self.clear_action();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RollingUpgradeRequestProto {
    fn eq(&self, other: &RollingUpgradeRequestProto) -> bool {
        self.action == other.action &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RollingUpgradeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RollingUpgradeInfoProto {
    // message fields
    status: ::protobuf::SingularPtrField<RollingUpgradeStatusProto>,
    startTime: ::std::option::Option<u64>,
    finalizeTime: ::std::option::Option<u64>,
    createdRollbackImages: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RollingUpgradeInfoProto {
    pub fn new() -> RollingUpgradeInfoProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RollingUpgradeInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<RollingUpgradeInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollingUpgradeInfoProto,
        };
        unsafe {
            instance.get(|| {
                RollingUpgradeInfoProto {
                    status: ::protobuf::SingularPtrField::none(),
                    startTime: ::std::option::Option::None,
                    finalizeTime: ::std::option::Option::None,
                    createdRollbackImages: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.RollingUpgradeStatusProto status = 1;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: RollingUpgradeStatusProto) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status<'a>(&'a mut self) -> &'a mut RollingUpgradeStatusProto {
        if self.status.is_none() {
            self.status.set_default();
        };
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> RollingUpgradeStatusProto {
        self.status.take().unwrap_or_else(|| RollingUpgradeStatusProto::new())
    }

    pub fn get_status<'a>(&'a self) -> &'a RollingUpgradeStatusProto {
        self.status.as_ref().unwrap_or_else(|| RollingUpgradeStatusProto::default_instance())
    }

    // required uint64 startTime = 2;

    pub fn clear_startTime(&mut self) {
        self.startTime = ::std::option::Option::None;
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: u64) {
        self.startTime = ::std::option::Option::Some(v);
    }

    pub fn get_startTime<'a>(&self) -> u64 {
        self.startTime.unwrap_or(0)
    }

    // required uint64 finalizeTime = 3;

    pub fn clear_finalizeTime(&mut self) {
        self.finalizeTime = ::std::option::Option::None;
    }

    pub fn has_finalizeTime(&self) -> bool {
        self.finalizeTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finalizeTime(&mut self, v: u64) {
        self.finalizeTime = ::std::option::Option::Some(v);
    }

    pub fn get_finalizeTime<'a>(&self) -> u64 {
        self.finalizeTime.unwrap_or(0)
    }

    // required bool createdRollbackImages = 4;

    pub fn clear_createdRollbackImages(&mut self) {
        self.createdRollbackImages = ::std::option::Option::None;
    }

    pub fn has_createdRollbackImages(&self) -> bool {
        self.createdRollbackImages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createdRollbackImages(&mut self, v: bool) {
        self.createdRollbackImages = ::std::option::Option::Some(v);
    }

    pub fn get_createdRollbackImages<'a>(&self) -> bool {
        self.createdRollbackImages.unwrap_or(false)
    }
}

impl ::protobuf::Message for RollingUpgradeInfoProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        };
        if self.startTime.is_none() {
            return false;
        };
        if self.finalizeTime.is_none() {
            return false;
        };
        if self.createdRollbackImages.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.status.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.startTime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.finalizeTime = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.createdRollbackImages = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.status.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.startTime.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.finalizeTime.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.createdRollbackImages.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.startTime {
            try!(os.write_uint64(2, v));
        };
        if let Some(v) = self.finalizeTime {
            try!(os.write_uint64(3, v));
        };
        if let Some(v) = self.createdRollbackImages {
            try!(os.write_bool(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RollingUpgradeInfoProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RollingUpgradeInfoProto {
    fn new() -> RollingUpgradeInfoProto {
        RollingUpgradeInfoProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RollingUpgradeInfoProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "status",
                    RollingUpgradeInfoProto::has_status,
                    RollingUpgradeInfoProto::get_status,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "startTime",
                    RollingUpgradeInfoProto::has_startTime,
                    RollingUpgradeInfoProto::get_startTime,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "finalizeTime",
                    RollingUpgradeInfoProto::has_finalizeTime,
                    RollingUpgradeInfoProto::get_finalizeTime,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "createdRollbackImages",
                    RollingUpgradeInfoProto::has_createdRollbackImages,
                    RollingUpgradeInfoProto::get_createdRollbackImages,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollingUpgradeInfoProto>(
                    "RollingUpgradeInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RollingUpgradeInfoProto {
    fn clear(&mut self) {
        self.clear_status();
        self.clear_startTime();
        self.clear_finalizeTime();
        self.clear_createdRollbackImages();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RollingUpgradeInfoProto {
    fn eq(&self, other: &RollingUpgradeInfoProto) -> bool {
        self.status == other.status &&
        self.startTime == other.startTime &&
        self.finalizeTime == other.finalizeTime &&
        self.createdRollbackImages == other.createdRollbackImages &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RollingUpgradeInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RollingUpgradeResponseProto {
    // message fields
    rollingUpgradeInfo: ::protobuf::SingularPtrField<RollingUpgradeInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RollingUpgradeResponseProto {
    pub fn new() -> RollingUpgradeResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RollingUpgradeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RollingUpgradeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollingUpgradeResponseProto,
        };
        unsafe {
            instance.get(|| {
                RollingUpgradeResponseProto {
                    rollingUpgradeInfo: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .hadoop.hdfs.RollingUpgradeInfoProto rollingUpgradeInfo = 1;

    pub fn clear_rollingUpgradeInfo(&mut self) {
        self.rollingUpgradeInfo.clear();
    }

    pub fn has_rollingUpgradeInfo(&self) -> bool {
        self.rollingUpgradeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpgradeInfo(&mut self, v: RollingUpgradeInfoProto) {
        self.rollingUpgradeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpgradeInfo<'a>(&'a mut self) -> &'a mut RollingUpgradeInfoProto {
        if self.rollingUpgradeInfo.is_none() {
            self.rollingUpgradeInfo.set_default();
        };
        self.rollingUpgradeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollingUpgradeInfo(&mut self) -> RollingUpgradeInfoProto {
        self.rollingUpgradeInfo.take().unwrap_or_else(|| RollingUpgradeInfoProto::new())
    }

    pub fn get_rollingUpgradeInfo<'a>(&'a self) -> &'a RollingUpgradeInfoProto {
        self.rollingUpgradeInfo.as_ref().unwrap_or_else(|| RollingUpgradeInfoProto::default_instance())
    }
}

impl ::protobuf::Message for RollingUpgradeResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.rollingUpgradeInfo.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.rollingUpgradeInfo.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.rollingUpgradeInfo.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RollingUpgradeResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RollingUpgradeResponseProto {
    fn new() -> RollingUpgradeResponseProto {
        RollingUpgradeResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RollingUpgradeResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "rollingUpgradeInfo",
                    RollingUpgradeResponseProto::has_rollingUpgradeInfo,
                    RollingUpgradeResponseProto::get_rollingUpgradeInfo,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollingUpgradeResponseProto>(
                    "RollingUpgradeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RollingUpgradeResponseProto {
    fn clear(&mut self) {
        self.clear_rollingUpgradeInfo();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RollingUpgradeResponseProto {
    fn eq(&self, other: &RollingUpgradeResponseProto) -> bool {
        self.rollingUpgradeInfo == other.rollingUpgradeInfo &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RollingUpgradeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ListCorruptFileBlocksRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    cookie: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ListCorruptFileBlocksRequestProto {
    pub fn new() -> ListCorruptFileBlocksRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCorruptFileBlocksRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCorruptFileBlocksRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCorruptFileBlocksRequestProto,
        };
        unsafe {
            instance.get(|| {
                ListCorruptFileBlocksRequestProto {
                    path: ::protobuf::SingularField::none(),
                    cookie: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        };
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path<'a>(&'a self) -> &'a str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string cookie = 2;

    pub fn clear_cookie(&mut self) {
        self.cookie.clear();
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: ::std::string::String) {
        self.cookie = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cookie<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.cookie.is_none() {
            self.cookie.set_default();
        };
        self.cookie.as_mut().unwrap()
    }

    // Take field
    pub fn take_cookie(&mut self) -> ::std::string::String {
        self.cookie.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_cookie<'a>(&'a self) -> &'a str {
        match self.cookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ListCorruptFileBlocksRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.path.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.cookie.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.path.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.cookie.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.path.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.cookie.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ListCorruptFileBlocksRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCorruptFileBlocksRequestProto {
    fn new() -> ListCorruptFileBlocksRequestProto {
        ListCorruptFileBlocksRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCorruptFileBlocksRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "path",
                    ListCorruptFileBlocksRequestProto::has_path,
                    ListCorruptFileBlocksRequestProto::get_path,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "cookie",
                    ListCorruptFileBlocksRequestProto::has_cookie,
                    ListCorruptFileBlocksRequestProto::get_cookie,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCorruptFileBlocksRequestProto>(
                    "ListCorruptFileBlocksRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCorruptFileBlocksRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.clear_cookie();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ListCorruptFileBlocksRequestProto {
    fn eq(&self, other: &ListCorruptFileBlocksRequestProto) -> bool {
        self.path == other.path &&
        self.cookie == other.cookie &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ListCorruptFileBlocksRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ListCorruptFileBlocksResponseProto {
    // message fields
    corrupt: ::protobuf::SingularPtrField<CorruptFileBlocksProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ListCorruptFileBlocksResponseProto {
    pub fn new() -> ListCorruptFileBlocksResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCorruptFileBlocksResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCorruptFileBlocksResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCorruptFileBlocksResponseProto,
        };
        unsafe {
            instance.get(|| {
                ListCorruptFileBlocksResponseProto {
                    corrupt: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.CorruptFileBlocksProto corrupt = 1;

    pub fn clear_corrupt(&mut self) {
        self.corrupt.clear();
    }

    pub fn has_corrupt(&self) -> bool {
        self.corrupt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt(&mut self, v: CorruptFileBlocksProto) {
        self.corrupt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_corrupt<'a>(&'a mut self) -> &'a mut CorruptFileBlocksProto {
        if self.corrupt.is_none() {
            self.corrupt.set_default();
        };
        self.corrupt.as_mut().unwrap()
    }

    // Take field
    pub fn take_corrupt(&mut self) -> CorruptFileBlocksProto {
        self.corrupt.take().unwrap_or_else(|| CorruptFileBlocksProto::new())
    }

    pub fn get_corrupt<'a>(&'a self) -> &'a CorruptFileBlocksProto {
        self.corrupt.as_ref().unwrap_or_else(|| CorruptFileBlocksProto::default_instance())
    }
}

impl ::protobuf::Message for ListCorruptFileBlocksResponseProto {
    fn is_initialized(&self) -> bool {
        if self.corrupt.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.corrupt.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.corrupt.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.corrupt.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ListCorruptFileBlocksResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCorruptFileBlocksResponseProto {
    fn new() -> ListCorruptFileBlocksResponseProto {
        ListCorruptFileBlocksResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCorruptFileBlocksResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "corrupt",
                    ListCorruptFileBlocksResponseProto::has_corrupt,
                    ListCorruptFileBlocksResponseProto::get_corrupt,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCorruptFileBlocksResponseProto>(
                    "ListCorruptFileBlocksResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCorruptFileBlocksResponseProto {
    fn clear(&mut self) {
        self.clear_corrupt();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ListCorruptFileBlocksResponseProto {
    fn eq(&self, other: &ListCorruptFileBlocksResponseProto) -> bool {
        self.corrupt == other.corrupt &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ListCorruptFileBlocksResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct MetaSaveRequestProto {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl MetaSaveRequestProto {
    pub fn new() -> MetaSaveRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MetaSaveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<MetaSaveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaSaveRequestProto,
        };
        unsafe {
            instance.get(|| {
                MetaSaveRequestProto {
                    filename: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string filename = 1;

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        };
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_filename<'a>(&'a self) -> &'a str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for MetaSaveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.filename.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.filename.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.filename.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.filename.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<MetaSaveRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MetaSaveRequestProto {
    fn new() -> MetaSaveRequestProto {
        MetaSaveRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<MetaSaveRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "filename",
                    MetaSaveRequestProto::has_filename,
                    MetaSaveRequestProto::get_filename,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaSaveRequestProto>(
                    "MetaSaveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MetaSaveRequestProto {
    fn clear(&mut self) {
        self.clear_filename();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for MetaSaveRequestProto {
    fn eq(&self, other: &MetaSaveRequestProto) -> bool {
        self.filename == other.filename &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for MetaSaveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct MetaSaveResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl MetaSaveResponseProto {
    pub fn new() -> MetaSaveResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MetaSaveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<MetaSaveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaSaveResponseProto,
        };
        unsafe {
            instance.get(|| {
                MetaSaveResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for MetaSaveResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<MetaSaveResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MetaSaveResponseProto {
    fn new() -> MetaSaveResponseProto {
        MetaSaveResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<MetaSaveResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<MetaSaveResponseProto>(
                    "MetaSaveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MetaSaveResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for MetaSaveResponseProto {
    fn eq(&self, other: &MetaSaveResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for MetaSaveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetFileInfoRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetFileInfoRequestProto {
    pub fn new() -> GetFileInfoRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFileInfoRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileInfoRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileInfoRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetFileInfoRequestProto {
                    src: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for GetFileInfoRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetFileInfoRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFileInfoRequestProto {
    fn new() -> GetFileInfoRequestProto {
        GetFileInfoRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFileInfoRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    GetFileInfoRequestProto::has_src,
                    GetFileInfoRequestProto::get_src,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileInfoRequestProto>(
                    "GetFileInfoRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFileInfoRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetFileInfoRequestProto {
    fn eq(&self, other: &GetFileInfoRequestProto) -> bool {
        self.src == other.src &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetFileInfoRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetFileInfoResponseProto {
    // message fields
    fs: ::protobuf::SingularPtrField<HdfsFileStatusProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetFileInfoResponseProto {
    pub fn new() -> GetFileInfoResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFileInfoResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileInfoResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileInfoResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetFileInfoResponseProto {
                    fs: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;

    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs<'a>(&'a mut self) -> &'a mut HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        };
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| HdfsFileStatusProto::new())
    }

    pub fn get_fs<'a>(&'a self) -> &'a HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| HdfsFileStatusProto::default_instance())
    }
}

impl ::protobuf::Message for GetFileInfoResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.fs.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.fs.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fs.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetFileInfoResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFileInfoResponseProto {
    fn new() -> GetFileInfoResponseProto {
        GetFileInfoResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFileInfoResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "fs",
                    GetFileInfoResponseProto::has_fs,
                    GetFileInfoResponseProto::get_fs,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileInfoResponseProto>(
                    "GetFileInfoResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFileInfoResponseProto {
    fn clear(&mut self) {
        self.clear_fs();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetFileInfoResponseProto {
    fn eq(&self, other: &GetFileInfoResponseProto) -> bool {
        self.fs == other.fs &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetFileInfoResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct IsFileClosedRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl IsFileClosedRequestProto {
    pub fn new() -> IsFileClosedRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static IsFileClosedRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<IsFileClosedRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IsFileClosedRequestProto,
        };
        unsafe {
            instance.get(|| {
                IsFileClosedRequestProto {
                    src: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for IsFileClosedRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<IsFileClosedRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for IsFileClosedRequestProto {
    fn new() -> IsFileClosedRequestProto {
        IsFileClosedRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<IsFileClosedRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    IsFileClosedRequestProto::has_src,
                    IsFileClosedRequestProto::get_src,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IsFileClosedRequestProto>(
                    "IsFileClosedRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for IsFileClosedRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for IsFileClosedRequestProto {
    fn eq(&self, other: &IsFileClosedRequestProto) -> bool {
        self.src == other.src &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for IsFileClosedRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct IsFileClosedResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl IsFileClosedResponseProto {
    pub fn new() -> IsFileClosedResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static IsFileClosedResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<IsFileClosedResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IsFileClosedResponseProto,
        };
        unsafe {
            instance.get(|| {
                IsFileClosedResponseProto {
                    result: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result<'a>(&self) -> bool {
        self.result.unwrap_or(false)
    }
}

impl ::protobuf::Message for IsFileClosedResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            try!(os.write_bool(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<IsFileClosedResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for IsFileClosedResponseProto {
    fn new() -> IsFileClosedResponseProto {
        IsFileClosedResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<IsFileClosedResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "result",
                    IsFileClosedResponseProto::has_result,
                    IsFileClosedResponseProto::get_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IsFileClosedResponseProto>(
                    "IsFileClosedResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for IsFileClosedResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for IsFileClosedResponseProto {
    fn eq(&self, other: &IsFileClosedResponseProto) -> bool {
        self.result == other.result &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for IsFileClosedResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CacheDirectiveInfoProto {
    // message fields
    id: ::std::option::Option<i64>,
    path: ::protobuf::SingularField<::std::string::String>,
    replication: ::std::option::Option<u32>,
    pool: ::protobuf::SingularField<::std::string::String>,
    expiration: ::protobuf::SingularPtrField<CacheDirectiveInfoExpirationProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CacheDirectiveInfoProto {
    pub fn new() -> CacheDirectiveInfoProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CacheDirectiveInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveInfoProto,
        };
        unsafe {
            instance.get(|| {
                CacheDirectiveInfoProto {
                    id: ::std::option::Option::None,
                    path: ::protobuf::SingularField::none(),
                    replication: ::std::option::Option::None,
                    pool: ::protobuf::SingularField::none(),
                    expiration: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id<'a>(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    // optional string path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        };
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path<'a>(&'a self) -> &'a str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 replication = 3;

    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    pub fn get_replication<'a>(&self) -> u32 {
        self.replication.unwrap_or(0)
    }

    // optional string pool = 4;

    pub fn clear_pool(&mut self) {
        self.pool.clear();
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ::std::string::String) {
        self.pool = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.pool.is_none() {
            self.pool.set_default();
        };
        self.pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_pool(&mut self) -> ::std::string::String {
        self.pool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_pool<'a>(&'a self) -> &'a str {
        match self.pool.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .hadoop.hdfs.CacheDirectiveInfoExpirationProto expiration = 5;

    pub fn clear_expiration(&mut self) {
        self.expiration.clear();
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: CacheDirectiveInfoExpirationProto) {
        self.expiration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expiration<'a>(&'a mut self) -> &'a mut CacheDirectiveInfoExpirationProto {
        if self.expiration.is_none() {
            self.expiration.set_default();
        };
        self.expiration.as_mut().unwrap()
    }

    // Take field
    pub fn take_expiration(&mut self) -> CacheDirectiveInfoExpirationProto {
        self.expiration.take().unwrap_or_else(|| CacheDirectiveInfoExpirationProto::new())
    }

    pub fn get_expiration<'a>(&'a self) -> &'a CacheDirectiveInfoExpirationProto {
        self.expiration.as_ref().unwrap_or_else(|| CacheDirectiveInfoExpirationProto::default_instance())
    }
}

impl ::protobuf::Message for CacheDirectiveInfoProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.path.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.replication = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.pool.set_default();
                    try!(is.read_string_into(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.expiration.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.path.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.replication.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.pool.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.expiration.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            try!(os.write_int64(1, v));
        };
        if let Some(v) = self.path.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.replication {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.pool.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.expiration.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CacheDirectiveInfoProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CacheDirectiveInfoProto {
    fn new() -> CacheDirectiveInfoProto {
        CacheDirectiveInfoProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CacheDirectiveInfoProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "id",
                    CacheDirectiveInfoProto::has_id,
                    CacheDirectiveInfoProto::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "path",
                    CacheDirectiveInfoProto::has_path,
                    CacheDirectiveInfoProto::get_path,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "replication",
                    CacheDirectiveInfoProto::has_replication,
                    CacheDirectiveInfoProto::get_replication,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "pool",
                    CacheDirectiveInfoProto::has_pool,
                    CacheDirectiveInfoProto::get_pool,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "expiration",
                    CacheDirectiveInfoProto::has_expiration,
                    CacheDirectiveInfoProto::get_expiration,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveInfoProto>(
                    "CacheDirectiveInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveInfoProto {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_path();
        self.clear_replication();
        self.clear_pool();
        self.clear_expiration();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CacheDirectiveInfoProto {
    fn eq(&self, other: &CacheDirectiveInfoProto) -> bool {
        self.id == other.id &&
        self.path == other.path &&
        self.replication == other.replication &&
        self.pool == other.pool &&
        self.expiration == other.expiration &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CacheDirectiveInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CacheDirectiveInfoExpirationProto {
    // message fields
    millis: ::std::option::Option<i64>,
    isRelative: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CacheDirectiveInfoExpirationProto {
    pub fn new() -> CacheDirectiveInfoExpirationProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CacheDirectiveInfoExpirationProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveInfoExpirationProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveInfoExpirationProto,
        };
        unsafe {
            instance.get(|| {
                CacheDirectiveInfoExpirationProto {
                    millis: ::std::option::Option::None,
                    isRelative: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required int64 millis = 1;

    pub fn clear_millis(&mut self) {
        self.millis = ::std::option::Option::None;
    }

    pub fn has_millis(&self) -> bool {
        self.millis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_millis(&mut self, v: i64) {
        self.millis = ::std::option::Option::Some(v);
    }

    pub fn get_millis<'a>(&self) -> i64 {
        self.millis.unwrap_or(0)
    }

    // required bool isRelative = 2;

    pub fn clear_isRelative(&mut self) {
        self.isRelative = ::std::option::Option::None;
    }

    pub fn has_isRelative(&self) -> bool {
        self.isRelative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isRelative(&mut self, v: bool) {
        self.isRelative = ::std::option::Option::Some(v);
    }

    pub fn get_isRelative<'a>(&self) -> bool {
        self.isRelative.unwrap_or(false)
    }
}

impl ::protobuf::Message for CacheDirectiveInfoExpirationProto {
    fn is_initialized(&self) -> bool {
        if self.millis.is_none() {
            return false;
        };
        if self.isRelative.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.millis = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.isRelative = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.millis.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.isRelative.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.millis {
            try!(os.write_int64(1, v));
        };
        if let Some(v) = self.isRelative {
            try!(os.write_bool(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CacheDirectiveInfoExpirationProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CacheDirectiveInfoExpirationProto {
    fn new() -> CacheDirectiveInfoExpirationProto {
        CacheDirectiveInfoExpirationProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CacheDirectiveInfoExpirationProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "millis",
                    CacheDirectiveInfoExpirationProto::has_millis,
                    CacheDirectiveInfoExpirationProto::get_millis,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "isRelative",
                    CacheDirectiveInfoExpirationProto::has_isRelative,
                    CacheDirectiveInfoExpirationProto::get_isRelative,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveInfoExpirationProto>(
                    "CacheDirectiveInfoExpirationProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveInfoExpirationProto {
    fn clear(&mut self) {
        self.clear_millis();
        self.clear_isRelative();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CacheDirectiveInfoExpirationProto {
    fn eq(&self, other: &CacheDirectiveInfoExpirationProto) -> bool {
        self.millis == other.millis &&
        self.isRelative == other.isRelative &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CacheDirectiveInfoExpirationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CacheDirectiveStatsProto {
    // message fields
    bytesNeeded: ::std::option::Option<i64>,
    bytesCached: ::std::option::Option<i64>,
    filesNeeded: ::std::option::Option<i64>,
    filesCached: ::std::option::Option<i64>,
    hasExpired: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CacheDirectiveStatsProto {
    pub fn new() -> CacheDirectiveStatsProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CacheDirectiveStatsProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveStatsProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveStatsProto,
        };
        unsafe {
            instance.get(|| {
                CacheDirectiveStatsProto {
                    bytesNeeded: ::std::option::Option::None,
                    bytesCached: ::std::option::Option::None,
                    filesNeeded: ::std::option::Option::None,
                    filesCached: ::std::option::Option::None,
                    hasExpired: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required int64 bytesNeeded = 1;

    pub fn clear_bytesNeeded(&mut self) {
        self.bytesNeeded = ::std::option::Option::None;
    }

    pub fn has_bytesNeeded(&self) -> bool {
        self.bytesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesNeeded(&mut self, v: i64) {
        self.bytesNeeded = ::std::option::Option::Some(v);
    }

    pub fn get_bytesNeeded<'a>(&self) -> i64 {
        self.bytesNeeded.unwrap_or(0)
    }

    // required int64 bytesCached = 2;

    pub fn clear_bytesCached(&mut self) {
        self.bytesCached = ::std::option::Option::None;
    }

    pub fn has_bytesCached(&self) -> bool {
        self.bytesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesCached(&mut self, v: i64) {
        self.bytesCached = ::std::option::Option::Some(v);
    }

    pub fn get_bytesCached<'a>(&self) -> i64 {
        self.bytesCached.unwrap_or(0)
    }

    // required int64 filesNeeded = 3;

    pub fn clear_filesNeeded(&mut self) {
        self.filesNeeded = ::std::option::Option::None;
    }

    pub fn has_filesNeeded(&self) -> bool {
        self.filesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesNeeded(&mut self, v: i64) {
        self.filesNeeded = ::std::option::Option::Some(v);
    }

    pub fn get_filesNeeded<'a>(&self) -> i64 {
        self.filesNeeded.unwrap_or(0)
    }

    // required int64 filesCached = 4;

    pub fn clear_filesCached(&mut self) {
        self.filesCached = ::std::option::Option::None;
    }

    pub fn has_filesCached(&self) -> bool {
        self.filesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesCached(&mut self, v: i64) {
        self.filesCached = ::std::option::Option::Some(v);
    }

    pub fn get_filesCached<'a>(&self) -> i64 {
        self.filesCached.unwrap_or(0)
    }

    // required bool hasExpired = 5;

    pub fn clear_hasExpired(&mut self) {
        self.hasExpired = ::std::option::Option::None;
    }

    pub fn has_hasExpired(&self) -> bool {
        self.hasExpired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasExpired(&mut self, v: bool) {
        self.hasExpired = ::std::option::Option::Some(v);
    }

    pub fn get_hasExpired<'a>(&self) -> bool {
        self.hasExpired.unwrap_or(false)
    }
}

impl ::protobuf::Message for CacheDirectiveStatsProto {
    fn is_initialized(&self) -> bool {
        if self.bytesNeeded.is_none() {
            return false;
        };
        if self.bytesCached.is_none() {
            return false;
        };
        if self.filesNeeded.is_none() {
            return false;
        };
        if self.filesCached.is_none() {
            return false;
        };
        if self.hasExpired.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.bytesNeeded = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.bytesCached = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.filesNeeded = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.filesCached = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.hasExpired = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.bytesNeeded.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bytesCached.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.filesNeeded.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.filesCached.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.hasExpired.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bytesNeeded {
            try!(os.write_int64(1, v));
        };
        if let Some(v) = self.bytesCached {
            try!(os.write_int64(2, v));
        };
        if let Some(v) = self.filesNeeded {
            try!(os.write_int64(3, v));
        };
        if let Some(v) = self.filesCached {
            try!(os.write_int64(4, v));
        };
        if let Some(v) = self.hasExpired {
            try!(os.write_bool(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CacheDirectiveStatsProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CacheDirectiveStatsProto {
    fn new() -> CacheDirectiveStatsProto {
        CacheDirectiveStatsProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CacheDirectiveStatsProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "bytesNeeded",
                    CacheDirectiveStatsProto::has_bytesNeeded,
                    CacheDirectiveStatsProto::get_bytesNeeded,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "bytesCached",
                    CacheDirectiveStatsProto::has_bytesCached,
                    CacheDirectiveStatsProto::get_bytesCached,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "filesNeeded",
                    CacheDirectiveStatsProto::has_filesNeeded,
                    CacheDirectiveStatsProto::get_filesNeeded,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "filesCached",
                    CacheDirectiveStatsProto::has_filesCached,
                    CacheDirectiveStatsProto::get_filesCached,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "hasExpired",
                    CacheDirectiveStatsProto::has_hasExpired,
                    CacheDirectiveStatsProto::get_hasExpired,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveStatsProto>(
                    "CacheDirectiveStatsProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveStatsProto {
    fn clear(&mut self) {
        self.clear_bytesNeeded();
        self.clear_bytesCached();
        self.clear_filesNeeded();
        self.clear_filesCached();
        self.clear_hasExpired();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CacheDirectiveStatsProto {
    fn eq(&self, other: &CacheDirectiveStatsProto) -> bool {
        self.bytesNeeded == other.bytesNeeded &&
        self.bytesCached == other.bytesCached &&
        self.filesNeeded == other.filesNeeded &&
        self.filesCached == other.filesCached &&
        self.hasExpired == other.hasExpired &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CacheDirectiveStatsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct AddCacheDirectiveRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    cacheFlags: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl AddCacheDirectiveRequestProto {
    pub fn new() -> AddCacheDirectiveRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddCacheDirectiveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCacheDirectiveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCacheDirectiveRequestProto,
        };
        unsafe {
            instance.get(|| {
                AddCacheDirectiveRequestProto {
                    info: ::protobuf::SingularPtrField::none(),
                    cacheFlags: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CacheDirectiveInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info<'a>(&'a mut self) -> &'a mut CacheDirectiveInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        };
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CacheDirectiveInfoProto {
        self.info.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    pub fn get_info<'a>(&'a self) -> &'a CacheDirectiveInfoProto {
        self.info.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }

    // optional uint32 cacheFlags = 2;

    pub fn clear_cacheFlags(&mut self) {
        self.cacheFlags = ::std::option::Option::None;
    }

    pub fn has_cacheFlags(&self) -> bool {
        self.cacheFlags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheFlags(&mut self, v: u32) {
        self.cacheFlags = ::std::option::Option::Some(v);
    }

    pub fn get_cacheFlags<'a>(&self) -> u32 {
        self.cacheFlags.unwrap_or(0)
    }
}

impl ::protobuf::Message for AddCacheDirectiveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.info.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.cacheFlags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.info.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.cacheFlags.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.info.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.cacheFlags {
            try!(os.write_uint32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<AddCacheDirectiveRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddCacheDirectiveRequestProto {
    fn new() -> AddCacheDirectiveRequestProto {
        AddCacheDirectiveRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddCacheDirectiveRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "info",
                    AddCacheDirectiveRequestProto::has_info,
                    AddCacheDirectiveRequestProto::get_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "cacheFlags",
                    AddCacheDirectiveRequestProto::has_cacheFlags,
                    AddCacheDirectiveRequestProto::get_cacheFlags,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddCacheDirectiveRequestProto>(
                    "AddCacheDirectiveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddCacheDirectiveRequestProto {
    fn clear(&mut self) {
        self.clear_info();
        self.clear_cacheFlags();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for AddCacheDirectiveRequestProto {
    fn eq(&self, other: &AddCacheDirectiveRequestProto) -> bool {
        self.info == other.info &&
        self.cacheFlags == other.cacheFlags &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for AddCacheDirectiveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct AddCacheDirectiveResponseProto {
    // message fields
    id: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl AddCacheDirectiveResponseProto {
    pub fn new() -> AddCacheDirectiveResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddCacheDirectiveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCacheDirectiveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCacheDirectiveResponseProto,
        };
        unsafe {
            instance.get(|| {
                AddCacheDirectiveResponseProto {
                    id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id<'a>(&self) -> i64 {
        self.id.unwrap_or(0)
    }
}

impl ::protobuf::Message for AddCacheDirectiveResponseProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            try!(os.write_int64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<AddCacheDirectiveResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddCacheDirectiveResponseProto {
    fn new() -> AddCacheDirectiveResponseProto {
        AddCacheDirectiveResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddCacheDirectiveResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "id",
                    AddCacheDirectiveResponseProto::has_id,
                    AddCacheDirectiveResponseProto::get_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddCacheDirectiveResponseProto>(
                    "AddCacheDirectiveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddCacheDirectiveResponseProto {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for AddCacheDirectiveResponseProto {
    fn eq(&self, other: &AddCacheDirectiveResponseProto) -> bool {
        self.id == other.id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for AddCacheDirectiveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ModifyCacheDirectiveRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    cacheFlags: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ModifyCacheDirectiveRequestProto {
    pub fn new() -> ModifyCacheDirectiveRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ModifyCacheDirectiveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCacheDirectiveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCacheDirectiveRequestProto,
        };
        unsafe {
            instance.get(|| {
                ModifyCacheDirectiveRequestProto {
                    info: ::protobuf::SingularPtrField::none(),
                    cacheFlags: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CacheDirectiveInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info<'a>(&'a mut self) -> &'a mut CacheDirectiveInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        };
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CacheDirectiveInfoProto {
        self.info.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    pub fn get_info<'a>(&'a self) -> &'a CacheDirectiveInfoProto {
        self.info.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }

    // optional uint32 cacheFlags = 2;

    pub fn clear_cacheFlags(&mut self) {
        self.cacheFlags = ::std::option::Option::None;
    }

    pub fn has_cacheFlags(&self) -> bool {
        self.cacheFlags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheFlags(&mut self, v: u32) {
        self.cacheFlags = ::std::option::Option::Some(v);
    }

    pub fn get_cacheFlags<'a>(&self) -> u32 {
        self.cacheFlags.unwrap_or(0)
    }
}

impl ::protobuf::Message for ModifyCacheDirectiveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.info.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.cacheFlags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.info.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.cacheFlags.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.info.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.cacheFlags {
            try!(os.write_uint32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ModifyCacheDirectiveRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ModifyCacheDirectiveRequestProto {
    fn new() -> ModifyCacheDirectiveRequestProto {
        ModifyCacheDirectiveRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ModifyCacheDirectiveRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "info",
                    ModifyCacheDirectiveRequestProto::has_info,
                    ModifyCacheDirectiveRequestProto::get_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "cacheFlags",
                    ModifyCacheDirectiveRequestProto::has_cacheFlags,
                    ModifyCacheDirectiveRequestProto::get_cacheFlags,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCacheDirectiveRequestProto>(
                    "ModifyCacheDirectiveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ModifyCacheDirectiveRequestProto {
    fn clear(&mut self) {
        self.clear_info();
        self.clear_cacheFlags();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ModifyCacheDirectiveRequestProto {
    fn eq(&self, other: &ModifyCacheDirectiveRequestProto) -> bool {
        self.info == other.info &&
        self.cacheFlags == other.cacheFlags &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ModifyCacheDirectiveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ModifyCacheDirectiveResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ModifyCacheDirectiveResponseProto {
    pub fn new() -> ModifyCacheDirectiveResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ModifyCacheDirectiveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCacheDirectiveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCacheDirectiveResponseProto,
        };
        unsafe {
            instance.get(|| {
                ModifyCacheDirectiveResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for ModifyCacheDirectiveResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ModifyCacheDirectiveResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ModifyCacheDirectiveResponseProto {
    fn new() -> ModifyCacheDirectiveResponseProto {
        ModifyCacheDirectiveResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ModifyCacheDirectiveResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCacheDirectiveResponseProto>(
                    "ModifyCacheDirectiveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ModifyCacheDirectiveResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ModifyCacheDirectiveResponseProto {
    fn eq(&self, other: &ModifyCacheDirectiveResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ModifyCacheDirectiveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RemoveCacheDirectiveRequestProto {
    // message fields
    id: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RemoveCacheDirectiveRequestProto {
    pub fn new() -> RemoveCacheDirectiveRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RemoveCacheDirectiveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCacheDirectiveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCacheDirectiveRequestProto,
        };
        unsafe {
            instance.get(|| {
                RemoveCacheDirectiveRequestProto {
                    id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id<'a>(&self) -> i64 {
        self.id.unwrap_or(0)
    }
}

impl ::protobuf::Message for RemoveCacheDirectiveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            try!(os.write_int64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RemoveCacheDirectiveRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RemoveCacheDirectiveRequestProto {
    fn new() -> RemoveCacheDirectiveRequestProto {
        RemoveCacheDirectiveRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RemoveCacheDirectiveRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "id",
                    RemoveCacheDirectiveRequestProto::has_id,
                    RemoveCacheDirectiveRequestProto::get_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCacheDirectiveRequestProto>(
                    "RemoveCacheDirectiveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RemoveCacheDirectiveRequestProto {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RemoveCacheDirectiveRequestProto {
    fn eq(&self, other: &RemoveCacheDirectiveRequestProto) -> bool {
        self.id == other.id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RemoveCacheDirectiveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RemoveCacheDirectiveResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RemoveCacheDirectiveResponseProto {
    pub fn new() -> RemoveCacheDirectiveResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RemoveCacheDirectiveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCacheDirectiveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCacheDirectiveResponseProto,
        };
        unsafe {
            instance.get(|| {
                RemoveCacheDirectiveResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for RemoveCacheDirectiveResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RemoveCacheDirectiveResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RemoveCacheDirectiveResponseProto {
    fn new() -> RemoveCacheDirectiveResponseProto {
        RemoveCacheDirectiveResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RemoveCacheDirectiveResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCacheDirectiveResponseProto>(
                    "RemoveCacheDirectiveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RemoveCacheDirectiveResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RemoveCacheDirectiveResponseProto {
    fn eq(&self, other: &RemoveCacheDirectiveResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RemoveCacheDirectiveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ListCacheDirectivesRequestProto {
    // message fields
    prevId: ::std::option::Option<i64>,
    filter: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ListCacheDirectivesRequestProto {
    pub fn new() -> ListCacheDirectivesRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCacheDirectivesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCacheDirectivesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCacheDirectivesRequestProto,
        };
        unsafe {
            instance.get(|| {
                ListCacheDirectivesRequestProto {
                    prevId: ::std::option::Option::None,
                    filter: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required int64 prevId = 1;

    pub fn clear_prevId(&mut self) {
        self.prevId = ::std::option::Option::None;
    }

    pub fn has_prevId(&self) -> bool {
        self.prevId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevId(&mut self, v: i64) {
        self.prevId = ::std::option::Option::Some(v);
    }

    pub fn get_prevId<'a>(&self) -> i64 {
        self.prevId.unwrap_or(0)
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto filter = 2;

    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: CacheDirectiveInfoProto) {
        self.filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter<'a>(&'a mut self) -> &'a mut CacheDirectiveInfoProto {
        if self.filter.is_none() {
            self.filter.set_default();
        };
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> CacheDirectiveInfoProto {
        self.filter.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    pub fn get_filter<'a>(&'a self) -> &'a CacheDirectiveInfoProto {
        self.filter.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }
}

impl ::protobuf::Message for ListCacheDirectivesRequestProto {
    fn is_initialized(&self) -> bool {
        if self.prevId.is_none() {
            return false;
        };
        if self.filter.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.prevId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.filter.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.prevId.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.filter.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prevId {
            try!(os.write_int64(1, v));
        };
        if let Some(v) = self.filter.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ListCacheDirectivesRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCacheDirectivesRequestProto {
    fn new() -> ListCacheDirectivesRequestProto {
        ListCacheDirectivesRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCacheDirectivesRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "prevId",
                    ListCacheDirectivesRequestProto::has_prevId,
                    ListCacheDirectivesRequestProto::get_prevId,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "filter",
                    ListCacheDirectivesRequestProto::has_filter,
                    ListCacheDirectivesRequestProto::get_filter,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCacheDirectivesRequestProto>(
                    "ListCacheDirectivesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCacheDirectivesRequestProto {
    fn clear(&mut self) {
        self.clear_prevId();
        self.clear_filter();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ListCacheDirectivesRequestProto {
    fn eq(&self, other: &ListCacheDirectivesRequestProto) -> bool {
        self.prevId == other.prevId &&
        self.filter == other.filter &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ListCacheDirectivesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CacheDirectiveEntryProto {
    // message fields
    info: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    stats: ::protobuf::SingularPtrField<CacheDirectiveStatsProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CacheDirectiveEntryProto {
    pub fn new() -> CacheDirectiveEntryProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CacheDirectiveEntryProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveEntryProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveEntryProto,
        };
        unsafe {
            instance.get(|| {
                CacheDirectiveEntryProto {
                    info: ::protobuf::SingularPtrField::none(),
                    stats: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CacheDirectiveInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info<'a>(&'a mut self) -> &'a mut CacheDirectiveInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        };
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CacheDirectiveInfoProto {
        self.info.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    pub fn get_info<'a>(&'a self) -> &'a CacheDirectiveInfoProto {
        self.info.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }

    // required .hadoop.hdfs.CacheDirectiveStatsProto stats = 2;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: CacheDirectiveStatsProto) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats<'a>(&'a mut self) -> &'a mut CacheDirectiveStatsProto {
        if self.stats.is_none() {
            self.stats.set_default();
        };
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> CacheDirectiveStatsProto {
        self.stats.take().unwrap_or_else(|| CacheDirectiveStatsProto::new())
    }

    pub fn get_stats<'a>(&'a self) -> &'a CacheDirectiveStatsProto {
        self.stats.as_ref().unwrap_or_else(|| CacheDirectiveStatsProto::default_instance())
    }
}

impl ::protobuf::Message for CacheDirectiveEntryProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        };
        if self.stats.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.info.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.stats.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.info.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.stats.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.info.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.stats.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CacheDirectiveEntryProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CacheDirectiveEntryProto {
    fn new() -> CacheDirectiveEntryProto {
        CacheDirectiveEntryProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CacheDirectiveEntryProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "info",
                    CacheDirectiveEntryProto::has_info,
                    CacheDirectiveEntryProto::get_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "stats",
                    CacheDirectiveEntryProto::has_stats,
                    CacheDirectiveEntryProto::get_stats,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveEntryProto>(
                    "CacheDirectiveEntryProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveEntryProto {
    fn clear(&mut self) {
        self.clear_info();
        self.clear_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CacheDirectiveEntryProto {
    fn eq(&self, other: &CacheDirectiveEntryProto) -> bool {
        self.info == other.info &&
        self.stats == other.stats &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CacheDirectiveEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ListCacheDirectivesResponseProto {
    // message fields
    elements: ::protobuf::RepeatedField<CacheDirectiveEntryProto>,
    hasMore: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ListCacheDirectivesResponseProto {
    pub fn new() -> ListCacheDirectivesResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCacheDirectivesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCacheDirectivesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCacheDirectivesResponseProto,
        };
        unsafe {
            instance.get(|| {
                ListCacheDirectivesResponseProto {
                    elements: ::protobuf::RepeatedField::new(),
                    hasMore: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .hadoop.hdfs.CacheDirectiveEntryProto elements = 1;

    pub fn clear_elements(&mut self) {
        self.elements.clear();
    }

    // Param is passed by value, moved
    pub fn set_elements(&mut self, v: ::protobuf::RepeatedField<CacheDirectiveEntryProto>) {
        self.elements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_elements<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CacheDirectiveEntryProto> {
        &mut self.elements
    }

    // Take field
    pub fn take_elements(&mut self) -> ::protobuf::RepeatedField<CacheDirectiveEntryProto> {
        ::std::mem::replace(&mut self.elements, ::protobuf::RepeatedField::new())
    }

    pub fn get_elements<'a>(&'a self) -> &'a [CacheDirectiveEntryProto] {
        &self.elements
    }

    // required bool hasMore = 2;

    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }

    pub fn get_hasMore<'a>(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }
}

impl ::protobuf::Message for ListCacheDirectivesResponseProto {
    fn is_initialized(&self) -> bool {
        if self.hasMore.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.elements));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.elements.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.hasMore.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.elements.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.hasMore {
            try!(os.write_bool(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ListCacheDirectivesResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCacheDirectivesResponseProto {
    fn new() -> ListCacheDirectivesResponseProto {
        ListCacheDirectivesResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCacheDirectivesResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "elements",
                    ListCacheDirectivesResponseProto::get_elements,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "hasMore",
                    ListCacheDirectivesResponseProto::has_hasMore,
                    ListCacheDirectivesResponseProto::get_hasMore,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCacheDirectivesResponseProto>(
                    "ListCacheDirectivesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCacheDirectivesResponseProto {
    fn clear(&mut self) {
        self.clear_elements();
        self.clear_hasMore();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ListCacheDirectivesResponseProto {
    fn eq(&self, other: &ListCacheDirectivesResponseProto) -> bool {
        self.elements == other.elements &&
        self.hasMore == other.hasMore &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ListCacheDirectivesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CachePoolInfoProto {
    // message fields
    poolName: ::protobuf::SingularField<::std::string::String>,
    ownerName: ::protobuf::SingularField<::std::string::String>,
    groupName: ::protobuf::SingularField<::std::string::String>,
    mode: ::std::option::Option<i32>,
    limit: ::std::option::Option<i64>,
    maxRelativeExpiry: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CachePoolInfoProto {
    pub fn new() -> CachePoolInfoProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CachePoolInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<CachePoolInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CachePoolInfoProto,
        };
        unsafe {
            instance.get(|| {
                CachePoolInfoProto {
                    poolName: ::protobuf::SingularField::none(),
                    ownerName: ::protobuf::SingularField::none(),
                    groupName: ::protobuf::SingularField::none(),
                    mode: ::std::option::Option::None,
                    limit: ::std::option::Option::None,
                    maxRelativeExpiry: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string poolName = 1;

    pub fn clear_poolName(&mut self) {
        self.poolName.clear();
    }

    pub fn has_poolName(&self) -> bool {
        self.poolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poolName(&mut self, v: ::std::string::String) {
        self.poolName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poolName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.poolName.is_none() {
            self.poolName.set_default();
        };
        self.poolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_poolName(&mut self) -> ::std::string::String {
        self.poolName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_poolName<'a>(&'a self) -> &'a str {
        match self.poolName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string ownerName = 2;

    pub fn clear_ownerName(&mut self) {
        self.ownerName.clear();
    }

    pub fn has_ownerName(&self) -> bool {
        self.ownerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ownerName(&mut self, v: ::std::string::String) {
        self.ownerName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ownerName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.ownerName.is_none() {
            self.ownerName.set_default();
        };
        self.ownerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ownerName(&mut self) -> ::std::string::String {
        self.ownerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ownerName<'a>(&'a self) -> &'a str {
        match self.ownerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string groupName = 3;

    pub fn clear_groupName(&mut self) {
        self.groupName.clear();
    }

    pub fn has_groupName(&self) -> bool {
        self.groupName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupName(&mut self, v: ::std::string::String) {
        self.groupName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.groupName.is_none() {
            self.groupName.set_default();
        };
        self.groupName.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupName(&mut self) -> ::std::string::String {
        self.groupName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_groupName<'a>(&'a self) -> &'a str {
        match self.groupName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 mode = 4;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode<'a>(&self) -> i32 {
        self.mode.unwrap_or(0)
    }

    // optional int64 limit = 5;

    pub fn clear_limit(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = ::std::option::Option::Some(v);
    }

    pub fn get_limit<'a>(&self) -> i64 {
        self.limit.unwrap_or(0)
    }

    // optional int64 maxRelativeExpiry = 6;

    pub fn clear_maxRelativeExpiry(&mut self) {
        self.maxRelativeExpiry = ::std::option::Option::None;
    }

    pub fn has_maxRelativeExpiry(&self) -> bool {
        self.maxRelativeExpiry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxRelativeExpiry(&mut self, v: i64) {
        self.maxRelativeExpiry = ::std::option::Option::Some(v);
    }

    pub fn get_maxRelativeExpiry<'a>(&self) -> i64 {
        self.maxRelativeExpiry.unwrap_or(0)
    }
}

impl ::protobuf::Message for CachePoolInfoProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.poolName.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.ownerName.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.groupName.set_default();
                    try!(is.read_string_into(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.mode = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.limit = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.maxRelativeExpiry = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.poolName.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.ownerName.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.groupName.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.mode.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.limit.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.maxRelativeExpiry.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.poolName.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.ownerName.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.groupName.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.mode {
            try!(os.write_int32(4, v));
        };
        if let Some(v) = self.limit {
            try!(os.write_int64(5, v));
        };
        if let Some(v) = self.maxRelativeExpiry {
            try!(os.write_int64(6, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CachePoolInfoProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CachePoolInfoProto {
    fn new() -> CachePoolInfoProto {
        CachePoolInfoProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CachePoolInfoProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "poolName",
                    CachePoolInfoProto::has_poolName,
                    CachePoolInfoProto::get_poolName,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "ownerName",
                    CachePoolInfoProto::has_ownerName,
                    CachePoolInfoProto::get_ownerName,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "groupName",
                    CachePoolInfoProto::has_groupName,
                    CachePoolInfoProto::get_groupName,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "mode",
                    CachePoolInfoProto::has_mode,
                    CachePoolInfoProto::get_mode,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "limit",
                    CachePoolInfoProto::has_limit,
                    CachePoolInfoProto::get_limit,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "maxRelativeExpiry",
                    CachePoolInfoProto::has_maxRelativeExpiry,
                    CachePoolInfoProto::get_maxRelativeExpiry,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CachePoolInfoProto>(
                    "CachePoolInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CachePoolInfoProto {
    fn clear(&mut self) {
        self.clear_poolName();
        self.clear_ownerName();
        self.clear_groupName();
        self.clear_mode();
        self.clear_limit();
        self.clear_maxRelativeExpiry();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CachePoolInfoProto {
    fn eq(&self, other: &CachePoolInfoProto) -> bool {
        self.poolName == other.poolName &&
        self.ownerName == other.ownerName &&
        self.groupName == other.groupName &&
        self.mode == other.mode &&
        self.limit == other.limit &&
        self.maxRelativeExpiry == other.maxRelativeExpiry &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CachePoolInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CachePoolStatsProto {
    // message fields
    bytesNeeded: ::std::option::Option<i64>,
    bytesCached: ::std::option::Option<i64>,
    bytesOverlimit: ::std::option::Option<i64>,
    filesNeeded: ::std::option::Option<i64>,
    filesCached: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CachePoolStatsProto {
    pub fn new() -> CachePoolStatsProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CachePoolStatsProto {
        static mut instance: ::protobuf::lazy::Lazy<CachePoolStatsProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CachePoolStatsProto,
        };
        unsafe {
            instance.get(|| {
                CachePoolStatsProto {
                    bytesNeeded: ::std::option::Option::None,
                    bytesCached: ::std::option::Option::None,
                    bytesOverlimit: ::std::option::Option::None,
                    filesNeeded: ::std::option::Option::None,
                    filesCached: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required int64 bytesNeeded = 1;

    pub fn clear_bytesNeeded(&mut self) {
        self.bytesNeeded = ::std::option::Option::None;
    }

    pub fn has_bytesNeeded(&self) -> bool {
        self.bytesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesNeeded(&mut self, v: i64) {
        self.bytesNeeded = ::std::option::Option::Some(v);
    }

    pub fn get_bytesNeeded<'a>(&self) -> i64 {
        self.bytesNeeded.unwrap_or(0)
    }

    // required int64 bytesCached = 2;

    pub fn clear_bytesCached(&mut self) {
        self.bytesCached = ::std::option::Option::None;
    }

    pub fn has_bytesCached(&self) -> bool {
        self.bytesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesCached(&mut self, v: i64) {
        self.bytesCached = ::std::option::Option::Some(v);
    }

    pub fn get_bytesCached<'a>(&self) -> i64 {
        self.bytesCached.unwrap_or(0)
    }

    // required int64 bytesOverlimit = 3;

    pub fn clear_bytesOverlimit(&mut self) {
        self.bytesOverlimit = ::std::option::Option::None;
    }

    pub fn has_bytesOverlimit(&self) -> bool {
        self.bytesOverlimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesOverlimit(&mut self, v: i64) {
        self.bytesOverlimit = ::std::option::Option::Some(v);
    }

    pub fn get_bytesOverlimit<'a>(&self) -> i64 {
        self.bytesOverlimit.unwrap_or(0)
    }

    // required int64 filesNeeded = 4;

    pub fn clear_filesNeeded(&mut self) {
        self.filesNeeded = ::std::option::Option::None;
    }

    pub fn has_filesNeeded(&self) -> bool {
        self.filesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesNeeded(&mut self, v: i64) {
        self.filesNeeded = ::std::option::Option::Some(v);
    }

    pub fn get_filesNeeded<'a>(&self) -> i64 {
        self.filesNeeded.unwrap_or(0)
    }

    // required int64 filesCached = 5;

    pub fn clear_filesCached(&mut self) {
        self.filesCached = ::std::option::Option::None;
    }

    pub fn has_filesCached(&self) -> bool {
        self.filesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesCached(&mut self, v: i64) {
        self.filesCached = ::std::option::Option::Some(v);
    }

    pub fn get_filesCached<'a>(&self) -> i64 {
        self.filesCached.unwrap_or(0)
    }
}

impl ::protobuf::Message for CachePoolStatsProto {
    fn is_initialized(&self) -> bool {
        if self.bytesNeeded.is_none() {
            return false;
        };
        if self.bytesCached.is_none() {
            return false;
        };
        if self.bytesOverlimit.is_none() {
            return false;
        };
        if self.filesNeeded.is_none() {
            return false;
        };
        if self.filesCached.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.bytesNeeded = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.bytesCached = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.bytesOverlimit = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.filesNeeded = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.filesCached = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.bytesNeeded.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bytesCached.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bytesOverlimit.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.filesNeeded.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.filesCached.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bytesNeeded {
            try!(os.write_int64(1, v));
        };
        if let Some(v) = self.bytesCached {
            try!(os.write_int64(2, v));
        };
        if let Some(v) = self.bytesOverlimit {
            try!(os.write_int64(3, v));
        };
        if let Some(v) = self.filesNeeded {
            try!(os.write_int64(4, v));
        };
        if let Some(v) = self.filesCached {
            try!(os.write_int64(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CachePoolStatsProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CachePoolStatsProto {
    fn new() -> CachePoolStatsProto {
        CachePoolStatsProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CachePoolStatsProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "bytesNeeded",
                    CachePoolStatsProto::has_bytesNeeded,
                    CachePoolStatsProto::get_bytesNeeded,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "bytesCached",
                    CachePoolStatsProto::has_bytesCached,
                    CachePoolStatsProto::get_bytesCached,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "bytesOverlimit",
                    CachePoolStatsProto::has_bytesOverlimit,
                    CachePoolStatsProto::get_bytesOverlimit,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "filesNeeded",
                    CachePoolStatsProto::has_filesNeeded,
                    CachePoolStatsProto::get_filesNeeded,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "filesCached",
                    CachePoolStatsProto::has_filesCached,
                    CachePoolStatsProto::get_filesCached,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CachePoolStatsProto>(
                    "CachePoolStatsProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CachePoolStatsProto {
    fn clear(&mut self) {
        self.clear_bytesNeeded();
        self.clear_bytesCached();
        self.clear_bytesOverlimit();
        self.clear_filesNeeded();
        self.clear_filesCached();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CachePoolStatsProto {
    fn eq(&self, other: &CachePoolStatsProto) -> bool {
        self.bytesNeeded == other.bytesNeeded &&
        self.bytesCached == other.bytesCached &&
        self.bytesOverlimit == other.bytesOverlimit &&
        self.filesNeeded == other.filesNeeded &&
        self.filesCached == other.filesCached &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CachePoolStatsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct AddCachePoolRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CachePoolInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl AddCachePoolRequestProto {
    pub fn new() -> AddCachePoolRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddCachePoolRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCachePoolRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCachePoolRequestProto,
        };
        unsafe {
            instance.get(|| {
                AddCachePoolRequestProto {
                    info: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.CachePoolInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CachePoolInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info<'a>(&'a mut self) -> &'a mut CachePoolInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        };
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CachePoolInfoProto {
        self.info.take().unwrap_or_else(|| CachePoolInfoProto::new())
    }

    pub fn get_info<'a>(&'a self) -> &'a CachePoolInfoProto {
        self.info.as_ref().unwrap_or_else(|| CachePoolInfoProto::default_instance())
    }
}

impl ::protobuf::Message for AddCachePoolRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.info.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.info.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.info.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<AddCachePoolRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddCachePoolRequestProto {
    fn new() -> AddCachePoolRequestProto {
        AddCachePoolRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddCachePoolRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "info",
                    AddCachePoolRequestProto::has_info,
                    AddCachePoolRequestProto::get_info,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddCachePoolRequestProto>(
                    "AddCachePoolRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddCachePoolRequestProto {
    fn clear(&mut self) {
        self.clear_info();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for AddCachePoolRequestProto {
    fn eq(&self, other: &AddCachePoolRequestProto) -> bool {
        self.info == other.info &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for AddCachePoolRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct AddCachePoolResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl AddCachePoolResponseProto {
    pub fn new() -> AddCachePoolResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddCachePoolResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCachePoolResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCachePoolResponseProto,
        };
        unsafe {
            instance.get(|| {
                AddCachePoolResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for AddCachePoolResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<AddCachePoolResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddCachePoolResponseProto {
    fn new() -> AddCachePoolResponseProto {
        AddCachePoolResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddCachePoolResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AddCachePoolResponseProto>(
                    "AddCachePoolResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddCachePoolResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for AddCachePoolResponseProto {
    fn eq(&self, other: &AddCachePoolResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for AddCachePoolResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ModifyCachePoolRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CachePoolInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ModifyCachePoolRequestProto {
    pub fn new() -> ModifyCachePoolRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ModifyCachePoolRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCachePoolRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCachePoolRequestProto,
        };
        unsafe {
            instance.get(|| {
                ModifyCachePoolRequestProto {
                    info: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.CachePoolInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CachePoolInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info<'a>(&'a mut self) -> &'a mut CachePoolInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        };
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CachePoolInfoProto {
        self.info.take().unwrap_or_else(|| CachePoolInfoProto::new())
    }

    pub fn get_info<'a>(&'a self) -> &'a CachePoolInfoProto {
        self.info.as_ref().unwrap_or_else(|| CachePoolInfoProto::default_instance())
    }
}

impl ::protobuf::Message for ModifyCachePoolRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.info.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.info.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.info.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ModifyCachePoolRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ModifyCachePoolRequestProto {
    fn new() -> ModifyCachePoolRequestProto {
        ModifyCachePoolRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ModifyCachePoolRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "info",
                    ModifyCachePoolRequestProto::has_info,
                    ModifyCachePoolRequestProto::get_info,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCachePoolRequestProto>(
                    "ModifyCachePoolRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ModifyCachePoolRequestProto {
    fn clear(&mut self) {
        self.clear_info();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ModifyCachePoolRequestProto {
    fn eq(&self, other: &ModifyCachePoolRequestProto) -> bool {
        self.info == other.info &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ModifyCachePoolRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ModifyCachePoolResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ModifyCachePoolResponseProto {
    pub fn new() -> ModifyCachePoolResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ModifyCachePoolResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCachePoolResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCachePoolResponseProto,
        };
        unsafe {
            instance.get(|| {
                ModifyCachePoolResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for ModifyCachePoolResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ModifyCachePoolResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ModifyCachePoolResponseProto {
    fn new() -> ModifyCachePoolResponseProto {
        ModifyCachePoolResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ModifyCachePoolResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCachePoolResponseProto>(
                    "ModifyCachePoolResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ModifyCachePoolResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ModifyCachePoolResponseProto {
    fn eq(&self, other: &ModifyCachePoolResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ModifyCachePoolResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RemoveCachePoolRequestProto {
    // message fields
    poolName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RemoveCachePoolRequestProto {
    pub fn new() -> RemoveCachePoolRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RemoveCachePoolRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCachePoolRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCachePoolRequestProto,
        };
        unsafe {
            instance.get(|| {
                RemoveCachePoolRequestProto {
                    poolName: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string poolName = 1;

    pub fn clear_poolName(&mut self) {
        self.poolName.clear();
    }

    pub fn has_poolName(&self) -> bool {
        self.poolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poolName(&mut self, v: ::std::string::String) {
        self.poolName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poolName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.poolName.is_none() {
            self.poolName.set_default();
        };
        self.poolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_poolName(&mut self) -> ::std::string::String {
        self.poolName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_poolName<'a>(&'a self) -> &'a str {
        match self.poolName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RemoveCachePoolRequestProto {
    fn is_initialized(&self) -> bool {
        if self.poolName.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.poolName.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.poolName.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.poolName.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RemoveCachePoolRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RemoveCachePoolRequestProto {
    fn new() -> RemoveCachePoolRequestProto {
        RemoveCachePoolRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RemoveCachePoolRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "poolName",
                    RemoveCachePoolRequestProto::has_poolName,
                    RemoveCachePoolRequestProto::get_poolName,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCachePoolRequestProto>(
                    "RemoveCachePoolRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RemoveCachePoolRequestProto {
    fn clear(&mut self) {
        self.clear_poolName();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RemoveCachePoolRequestProto {
    fn eq(&self, other: &RemoveCachePoolRequestProto) -> bool {
        self.poolName == other.poolName &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RemoveCachePoolRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RemoveCachePoolResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RemoveCachePoolResponseProto {
    pub fn new() -> RemoveCachePoolResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RemoveCachePoolResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCachePoolResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCachePoolResponseProto,
        };
        unsafe {
            instance.get(|| {
                RemoveCachePoolResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for RemoveCachePoolResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RemoveCachePoolResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RemoveCachePoolResponseProto {
    fn new() -> RemoveCachePoolResponseProto {
        RemoveCachePoolResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RemoveCachePoolResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCachePoolResponseProto>(
                    "RemoveCachePoolResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RemoveCachePoolResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RemoveCachePoolResponseProto {
    fn eq(&self, other: &RemoveCachePoolResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RemoveCachePoolResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ListCachePoolsRequestProto {
    // message fields
    prevPoolName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ListCachePoolsRequestProto {
    pub fn new() -> ListCachePoolsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCachePoolsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCachePoolsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCachePoolsRequestProto,
        };
        unsafe {
            instance.get(|| {
                ListCachePoolsRequestProto {
                    prevPoolName: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string prevPoolName = 1;

    pub fn clear_prevPoolName(&mut self) {
        self.prevPoolName.clear();
    }

    pub fn has_prevPoolName(&self) -> bool {
        self.prevPoolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevPoolName(&mut self, v: ::std::string::String) {
        self.prevPoolName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prevPoolName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.prevPoolName.is_none() {
            self.prevPoolName.set_default();
        };
        self.prevPoolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_prevPoolName(&mut self) -> ::std::string::String {
        self.prevPoolName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_prevPoolName<'a>(&'a self) -> &'a str {
        match self.prevPoolName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ListCachePoolsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.prevPoolName.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.prevPoolName.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.prevPoolName.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prevPoolName.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ListCachePoolsRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCachePoolsRequestProto {
    fn new() -> ListCachePoolsRequestProto {
        ListCachePoolsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCachePoolsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "prevPoolName",
                    ListCachePoolsRequestProto::has_prevPoolName,
                    ListCachePoolsRequestProto::get_prevPoolName,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCachePoolsRequestProto>(
                    "ListCachePoolsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCachePoolsRequestProto {
    fn clear(&mut self) {
        self.clear_prevPoolName();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ListCachePoolsRequestProto {
    fn eq(&self, other: &ListCachePoolsRequestProto) -> bool {
        self.prevPoolName == other.prevPoolName &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ListCachePoolsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ListCachePoolsResponseProto {
    // message fields
    entries: ::protobuf::RepeatedField<CachePoolEntryProto>,
    hasMore: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ListCachePoolsResponseProto {
    pub fn new() -> ListCachePoolsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCachePoolsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCachePoolsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCachePoolsResponseProto,
        };
        unsafe {
            instance.get(|| {
                ListCachePoolsResponseProto {
                    entries: ::protobuf::RepeatedField::new(),
                    hasMore: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .hadoop.hdfs.CachePoolEntryProto entries = 1;

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CachePoolEntryProto>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CachePoolEntryProto> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CachePoolEntryProto> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }

    pub fn get_entries<'a>(&'a self) -> &'a [CachePoolEntryProto] {
        &self.entries
    }

    // required bool hasMore = 2;

    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }

    pub fn get_hasMore<'a>(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }
}

impl ::protobuf::Message for ListCachePoolsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.hasMore.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.entries.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.hasMore.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.entries.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.hasMore {
            try!(os.write_bool(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ListCachePoolsResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCachePoolsResponseProto {
    fn new() -> ListCachePoolsResponseProto {
        ListCachePoolsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCachePoolsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "entries",
                    ListCachePoolsResponseProto::get_entries,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "hasMore",
                    ListCachePoolsResponseProto::has_hasMore,
                    ListCachePoolsResponseProto::get_hasMore,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCachePoolsResponseProto>(
                    "ListCachePoolsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCachePoolsResponseProto {
    fn clear(&mut self) {
        self.clear_entries();
        self.clear_hasMore();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ListCachePoolsResponseProto {
    fn eq(&self, other: &ListCachePoolsResponseProto) -> bool {
        self.entries == other.entries &&
        self.hasMore == other.hasMore &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ListCachePoolsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CachePoolEntryProto {
    // message fields
    info: ::protobuf::SingularPtrField<CachePoolInfoProto>,
    stats: ::protobuf::SingularPtrField<CachePoolStatsProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CachePoolEntryProto {
    pub fn new() -> CachePoolEntryProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CachePoolEntryProto {
        static mut instance: ::protobuf::lazy::Lazy<CachePoolEntryProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CachePoolEntryProto,
        };
        unsafe {
            instance.get(|| {
                CachePoolEntryProto {
                    info: ::protobuf::SingularPtrField::none(),
                    stats: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.CachePoolInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CachePoolInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info<'a>(&'a mut self) -> &'a mut CachePoolInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        };
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CachePoolInfoProto {
        self.info.take().unwrap_or_else(|| CachePoolInfoProto::new())
    }

    pub fn get_info<'a>(&'a self) -> &'a CachePoolInfoProto {
        self.info.as_ref().unwrap_or_else(|| CachePoolInfoProto::default_instance())
    }

    // required .hadoop.hdfs.CachePoolStatsProto stats = 2;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: CachePoolStatsProto) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats<'a>(&'a mut self) -> &'a mut CachePoolStatsProto {
        if self.stats.is_none() {
            self.stats.set_default();
        };
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> CachePoolStatsProto {
        self.stats.take().unwrap_or_else(|| CachePoolStatsProto::new())
    }

    pub fn get_stats<'a>(&'a self) -> &'a CachePoolStatsProto {
        self.stats.as_ref().unwrap_or_else(|| CachePoolStatsProto::default_instance())
    }
}

impl ::protobuf::Message for CachePoolEntryProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        };
        if self.stats.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.info.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.stats.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.info.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.stats.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.info.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.stats.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CachePoolEntryProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CachePoolEntryProto {
    fn new() -> CachePoolEntryProto {
        CachePoolEntryProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CachePoolEntryProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "info",
                    CachePoolEntryProto::has_info,
                    CachePoolEntryProto::get_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "stats",
                    CachePoolEntryProto::has_stats,
                    CachePoolEntryProto::get_stats,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CachePoolEntryProto>(
                    "CachePoolEntryProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CachePoolEntryProto {
    fn clear(&mut self) {
        self.clear_info();
        self.clear_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CachePoolEntryProto {
    fn eq(&self, other: &CachePoolEntryProto) -> bool {
        self.info == other.info &&
        self.stats == other.stats &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CachePoolEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetFileLinkInfoRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetFileLinkInfoRequestProto {
    pub fn new() -> GetFileLinkInfoRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFileLinkInfoRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileLinkInfoRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileLinkInfoRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetFileLinkInfoRequestProto {
                    src: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for GetFileLinkInfoRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetFileLinkInfoRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFileLinkInfoRequestProto {
    fn new() -> GetFileLinkInfoRequestProto {
        GetFileLinkInfoRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFileLinkInfoRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    GetFileLinkInfoRequestProto::has_src,
                    GetFileLinkInfoRequestProto::get_src,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileLinkInfoRequestProto>(
                    "GetFileLinkInfoRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFileLinkInfoRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetFileLinkInfoRequestProto {
    fn eq(&self, other: &GetFileLinkInfoRequestProto) -> bool {
        self.src == other.src &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetFileLinkInfoRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetFileLinkInfoResponseProto {
    // message fields
    fs: ::protobuf::SingularPtrField<HdfsFileStatusProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetFileLinkInfoResponseProto {
    pub fn new() -> GetFileLinkInfoResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFileLinkInfoResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileLinkInfoResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileLinkInfoResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetFileLinkInfoResponseProto {
                    fs: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;

    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs<'a>(&'a mut self) -> &'a mut HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        };
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| HdfsFileStatusProto::new())
    }

    pub fn get_fs<'a>(&'a self) -> &'a HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| HdfsFileStatusProto::default_instance())
    }
}

impl ::protobuf::Message for GetFileLinkInfoResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.fs.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.fs.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fs.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetFileLinkInfoResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFileLinkInfoResponseProto {
    fn new() -> GetFileLinkInfoResponseProto {
        GetFileLinkInfoResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFileLinkInfoResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "fs",
                    GetFileLinkInfoResponseProto::has_fs,
                    GetFileLinkInfoResponseProto::get_fs,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileLinkInfoResponseProto>(
                    "GetFileLinkInfoResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFileLinkInfoResponseProto {
    fn clear(&mut self) {
        self.clear_fs();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetFileLinkInfoResponseProto {
    fn eq(&self, other: &GetFileLinkInfoResponseProto) -> bool {
        self.fs == other.fs &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetFileLinkInfoResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetContentSummaryRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetContentSummaryRequestProto {
    pub fn new() -> GetContentSummaryRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetContentSummaryRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetContentSummaryRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetContentSummaryRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetContentSummaryRequestProto {
                    path: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        };
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path<'a>(&'a self) -> &'a str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for GetContentSummaryRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.path.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.path.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.path.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetContentSummaryRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetContentSummaryRequestProto {
    fn new() -> GetContentSummaryRequestProto {
        GetContentSummaryRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetContentSummaryRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "path",
                    GetContentSummaryRequestProto::has_path,
                    GetContentSummaryRequestProto::get_path,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetContentSummaryRequestProto>(
                    "GetContentSummaryRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetContentSummaryRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetContentSummaryRequestProto {
    fn eq(&self, other: &GetContentSummaryRequestProto) -> bool {
        self.path == other.path &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetContentSummaryRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetContentSummaryResponseProto {
    // message fields
    summary: ::protobuf::SingularPtrField<ContentSummaryProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetContentSummaryResponseProto {
    pub fn new() -> GetContentSummaryResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetContentSummaryResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetContentSummaryResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetContentSummaryResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetContentSummaryResponseProto {
                    summary: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.ContentSummaryProto summary = 1;

    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: ContentSummaryProto) {
        self.summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary<'a>(&'a mut self) -> &'a mut ContentSummaryProto {
        if self.summary.is_none() {
            self.summary.set_default();
        };
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> ContentSummaryProto {
        self.summary.take().unwrap_or_else(|| ContentSummaryProto::new())
    }

    pub fn get_summary<'a>(&'a self) -> &'a ContentSummaryProto {
        self.summary.as_ref().unwrap_or_else(|| ContentSummaryProto::default_instance())
    }
}

impl ::protobuf::Message for GetContentSummaryResponseProto {
    fn is_initialized(&self) -> bool {
        if self.summary.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.summary.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.summary.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.summary.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetContentSummaryResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetContentSummaryResponseProto {
    fn new() -> GetContentSummaryResponseProto {
        GetContentSummaryResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetContentSummaryResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "summary",
                    GetContentSummaryResponseProto::has_summary,
                    GetContentSummaryResponseProto::get_summary,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetContentSummaryResponseProto>(
                    "GetContentSummaryResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetContentSummaryResponseProto {
    fn clear(&mut self) {
        self.clear_summary();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetContentSummaryResponseProto {
    fn eq(&self, other: &GetContentSummaryResponseProto) -> bool {
        self.summary == other.summary &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetContentSummaryResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetQuotaRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    namespaceQuota: ::std::option::Option<u64>,
    storagespaceQuota: ::std::option::Option<u64>,
    storageType: ::std::option::Option<StorageTypeProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetQuotaRequestProto {
    pub fn new() -> SetQuotaRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetQuotaRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetQuotaRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetQuotaRequestProto,
        };
        unsafe {
            instance.get(|| {
                SetQuotaRequestProto {
                    path: ::protobuf::SingularField::none(),
                    namespaceQuota: ::std::option::Option::None,
                    storagespaceQuota: ::std::option::Option::None,
                    storageType: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        };
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path<'a>(&'a self) -> &'a str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required uint64 namespaceQuota = 2;

    pub fn clear_namespaceQuota(&mut self) {
        self.namespaceQuota = ::std::option::Option::None;
    }

    pub fn has_namespaceQuota(&self) -> bool {
        self.namespaceQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceQuota(&mut self, v: u64) {
        self.namespaceQuota = ::std::option::Option::Some(v);
    }

    pub fn get_namespaceQuota<'a>(&self) -> u64 {
        self.namespaceQuota.unwrap_or(0)
    }

    // required uint64 storagespaceQuota = 3;

    pub fn clear_storagespaceQuota(&mut self) {
        self.storagespaceQuota = ::std::option::Option::None;
    }

    pub fn has_storagespaceQuota(&self) -> bool {
        self.storagespaceQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagespaceQuota(&mut self, v: u64) {
        self.storagespaceQuota = ::std::option::Option::Some(v);
    }

    pub fn get_storagespaceQuota<'a>(&self) -> u64 {
        self.storagespaceQuota.unwrap_or(0)
    }

    // optional .hadoop.hdfs.StorageTypeProto storageType = 4;

    pub fn clear_storageType(&mut self) {
        self.storageType = ::std::option::Option::None;
    }

    pub fn has_storageType(&self) -> bool {
        self.storageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageType(&mut self, v: StorageTypeProto) {
        self.storageType = ::std::option::Option::Some(v);
    }

    pub fn get_storageType<'a>(&self) -> StorageTypeProto {
        self.storageType.unwrap_or(StorageTypeProto::DISK)
    }
}

impl ::protobuf::Message for SetQuotaRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        };
        if self.namespaceQuota.is_none() {
            return false;
        };
        if self.storagespaceQuota.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.path.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.namespaceQuota = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.storagespaceQuota = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.storageType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.path.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.namespaceQuota.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.storagespaceQuota.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.storageType.iter() {
            my_size += ::protobuf::rt::enum_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.path.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.namespaceQuota {
            try!(os.write_uint64(2, v));
        };
        if let Some(v) = self.storagespaceQuota {
            try!(os.write_uint64(3, v));
        };
        if let Some(v) = self.storageType {
            try!(os.write_enum(4, v as i32));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetQuotaRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetQuotaRequestProto {
    fn new() -> SetQuotaRequestProto {
        SetQuotaRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetQuotaRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "path",
                    SetQuotaRequestProto::has_path,
                    SetQuotaRequestProto::get_path,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "namespaceQuota",
                    SetQuotaRequestProto::has_namespaceQuota,
                    SetQuotaRequestProto::get_namespaceQuota,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "storagespaceQuota",
                    SetQuotaRequestProto::has_storagespaceQuota,
                    SetQuotaRequestProto::get_storagespaceQuota,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "storageType",
                    SetQuotaRequestProto::has_storageType,
                    SetQuotaRequestProto::get_storageType,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetQuotaRequestProto>(
                    "SetQuotaRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetQuotaRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.clear_namespaceQuota();
        self.clear_storagespaceQuota();
        self.clear_storageType();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetQuotaRequestProto {
    fn eq(&self, other: &SetQuotaRequestProto) -> bool {
        self.path == other.path &&
        self.namespaceQuota == other.namespaceQuota &&
        self.storagespaceQuota == other.storagespaceQuota &&
        self.storageType == other.storageType &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetQuotaRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetQuotaResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetQuotaResponseProto {
    pub fn new() -> SetQuotaResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetQuotaResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetQuotaResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetQuotaResponseProto,
        };
        unsafe {
            instance.get(|| {
                SetQuotaResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for SetQuotaResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetQuotaResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetQuotaResponseProto {
    fn new() -> SetQuotaResponseProto {
        SetQuotaResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetQuotaResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetQuotaResponseProto>(
                    "SetQuotaResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetQuotaResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetQuotaResponseProto {
    fn eq(&self, other: &SetQuotaResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetQuotaResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct FsyncRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    client: ::protobuf::SingularField<::std::string::String>,
    lastBlockLength: ::std::option::Option<i64>,
    fileId: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl FsyncRequestProto {
    pub fn new() -> FsyncRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FsyncRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<FsyncRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FsyncRequestProto,
        };
        unsafe {
            instance.get(|| {
                FsyncRequestProto {
                    src: ::protobuf::SingularField::none(),
                    client: ::protobuf::SingularField::none(),
                    lastBlockLength: ::std::option::Option::None,
                    fileId: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string client = 2;

    pub fn clear_client(&mut self) {
        self.client.clear();
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: ::std::string::String) {
        self.client = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.client.is_none() {
            self.client.set_default();
        };
        self.client.as_mut().unwrap()
    }

    // Take field
    pub fn take_client(&mut self) -> ::std::string::String {
        self.client.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_client<'a>(&'a self) -> &'a str {
        match self.client.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional sint64 lastBlockLength = 3;

    pub fn clear_lastBlockLength(&mut self) {
        self.lastBlockLength = ::std::option::Option::None;
    }

    pub fn has_lastBlockLength(&self) -> bool {
        self.lastBlockLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastBlockLength(&mut self, v: i64) {
        self.lastBlockLength = ::std::option::Option::Some(v);
    }

    pub fn get_lastBlockLength<'a>(&self) -> i64 {
        self.lastBlockLength.unwrap_or(-1i64)
    }

    // optional uint64 fileId = 4;

    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    pub fn get_fileId<'a>(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
}

impl ::protobuf::Message for FsyncRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.client.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.client.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_sint64());
                    self.lastBlockLength = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.client.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.lastBlockLength.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.fileId.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.client.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.lastBlockLength {
            try!(os.write_sint64(3, v));
        };
        if let Some(v) = self.fileId {
            try!(os.write_uint64(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<FsyncRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FsyncRequestProto {
    fn new() -> FsyncRequestProto {
        FsyncRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<FsyncRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    FsyncRequestProto::has_src,
                    FsyncRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "client",
                    FsyncRequestProto::has_client,
                    FsyncRequestProto::get_client,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "lastBlockLength",
                    FsyncRequestProto::has_lastBlockLength,
                    FsyncRequestProto::get_lastBlockLength,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "fileId",
                    FsyncRequestProto::has_fileId,
                    FsyncRequestProto::get_fileId,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FsyncRequestProto>(
                    "FsyncRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FsyncRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_client();
        self.clear_lastBlockLength();
        self.clear_fileId();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for FsyncRequestProto {
    fn eq(&self, other: &FsyncRequestProto) -> bool {
        self.src == other.src &&
        self.client == other.client &&
        self.lastBlockLength == other.lastBlockLength &&
        self.fileId == other.fileId &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for FsyncRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct FsyncResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl FsyncResponseProto {
    pub fn new() -> FsyncResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FsyncResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<FsyncResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FsyncResponseProto,
        };
        unsafe {
            instance.get(|| {
                FsyncResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for FsyncResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<FsyncResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FsyncResponseProto {
    fn new() -> FsyncResponseProto {
        FsyncResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<FsyncResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FsyncResponseProto>(
                    "FsyncResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FsyncResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for FsyncResponseProto {
    fn eq(&self, other: &FsyncResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for FsyncResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetTimesRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    mtime: ::std::option::Option<u64>,
    atime: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetTimesRequestProto {
    pub fn new() -> SetTimesRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetTimesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetTimesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetTimesRequestProto,
        };
        unsafe {
            instance.get(|| {
                SetTimesRequestProto {
                    src: ::protobuf::SingularField::none(),
                    mtime: ::std::option::Option::None,
                    atime: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        };
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src<'a>(&'a self) -> &'a str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required uint64 mtime = 2;

    pub fn clear_mtime(&mut self) {
        self.mtime = ::std::option::Option::None;
    }

    pub fn has_mtime(&self) -> bool {
        self.mtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mtime(&mut self, v: u64) {
        self.mtime = ::std::option::Option::Some(v);
    }

    pub fn get_mtime<'a>(&self) -> u64 {
        self.mtime.unwrap_or(0)
    }

    // required uint64 atime = 3;

    pub fn clear_atime(&mut self) {
        self.atime = ::std::option::Option::None;
    }

    pub fn has_atime(&self) -> bool {
        self.atime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_atime(&mut self, v: u64) {
        self.atime = ::std::option::Option::Some(v);
    }

    pub fn get_atime<'a>(&self) -> u64 {
        self.atime.unwrap_or(0)
    }
}

impl ::protobuf::Message for SetTimesRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        };
        if self.mtime.is_none() {
            return false;
        };
        if self.atime.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.src.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mtime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.atime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.src.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.mtime.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.atime.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.src.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.mtime {
            try!(os.write_uint64(2, v));
        };
        if let Some(v) = self.atime {
            try!(os.write_uint64(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetTimesRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetTimesRequestProto {
    fn new() -> SetTimesRequestProto {
        SetTimesRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetTimesRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "src",
                    SetTimesRequestProto::has_src,
                    SetTimesRequestProto::get_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mtime",
                    SetTimesRequestProto::has_mtime,
                    SetTimesRequestProto::get_mtime,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "atime",
                    SetTimesRequestProto::has_atime,
                    SetTimesRequestProto::get_atime,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetTimesRequestProto>(
                    "SetTimesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetTimesRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_mtime();
        self.clear_atime();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetTimesRequestProto {
    fn eq(&self, other: &SetTimesRequestProto) -> bool {
        self.src == other.src &&
        self.mtime == other.mtime &&
        self.atime == other.atime &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetTimesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetTimesResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetTimesResponseProto {
    pub fn new() -> SetTimesResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetTimesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetTimesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetTimesResponseProto,
        };
        unsafe {
            instance.get(|| {
                SetTimesResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for SetTimesResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetTimesResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetTimesResponseProto {
    fn new() -> SetTimesResponseProto {
        SetTimesResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetTimesResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetTimesResponseProto>(
                    "SetTimesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetTimesResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetTimesResponseProto {
    fn eq(&self, other: &SetTimesResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetTimesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CreateSymlinkRequestProto {
    // message fields
    target: ::protobuf::SingularField<::std::string::String>,
    link: ::protobuf::SingularField<::std::string::String>,
    dirPerm: ::protobuf::SingularPtrField<FsPermissionProto>,
    createParent: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CreateSymlinkRequestProto {
    pub fn new() -> CreateSymlinkRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateSymlinkRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSymlinkRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSymlinkRequestProto,
        };
        unsafe {
            instance.get(|| {
                CreateSymlinkRequestProto {
                    target: ::protobuf::SingularField::none(),
                    link: ::protobuf::SingularField::none(),
                    dirPerm: ::protobuf::SingularPtrField::none(),
                    createParent: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string target = 1;

    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.target.is_none() {
            self.target.set_default();
        };
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_target<'a>(&'a self) -> &'a str {
        match self.target.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string link = 2;

    pub fn clear_link(&mut self) {
        self.link.clear();
    }

    pub fn has_link(&self) -> bool {
        self.link.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link(&mut self, v: ::std::string::String) {
        self.link = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.link.is_none() {
            self.link.set_default();
        };
        self.link.as_mut().unwrap()
    }

    // Take field
    pub fn take_link(&mut self) -> ::std::string::String {
        self.link.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_link<'a>(&'a self) -> &'a str {
        match self.link.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .hadoop.hdfs.FsPermissionProto dirPerm = 3;

    pub fn clear_dirPerm(&mut self) {
        self.dirPerm.clear();
    }

    pub fn has_dirPerm(&self) -> bool {
        self.dirPerm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirPerm(&mut self, v: FsPermissionProto) {
        self.dirPerm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dirPerm<'a>(&'a mut self) -> &'a mut FsPermissionProto {
        if self.dirPerm.is_none() {
            self.dirPerm.set_default();
        };
        self.dirPerm.as_mut().unwrap()
    }

    // Take field
    pub fn take_dirPerm(&mut self) -> FsPermissionProto {
        self.dirPerm.take().unwrap_or_else(|| FsPermissionProto::new())
    }

    pub fn get_dirPerm<'a>(&'a self) -> &'a FsPermissionProto {
        self.dirPerm.as_ref().unwrap_or_else(|| FsPermissionProto::default_instance())
    }

    // required bool createParent = 4;

    pub fn clear_createParent(&mut self) {
        self.createParent = ::std::option::Option::None;
    }

    pub fn has_createParent(&self) -> bool {
        self.createParent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createParent(&mut self, v: bool) {
        self.createParent = ::std::option::Option::Some(v);
    }

    pub fn get_createParent<'a>(&self) -> bool {
        self.createParent.unwrap_or(false)
    }
}

impl ::protobuf::Message for CreateSymlinkRequestProto {
    fn is_initialized(&self) -> bool {
        if self.target.is_none() {
            return false;
        };
        if self.link.is_none() {
            return false;
        };
        if self.dirPerm.is_none() {
            return false;
        };
        if self.createParent.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.target.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.link.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.dirPerm.set_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.createParent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.target.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.link.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.dirPerm.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.createParent.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.target.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.link.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.dirPerm.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.createParent {
            try!(os.write_bool(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CreateSymlinkRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateSymlinkRequestProto {
    fn new() -> CreateSymlinkRequestProto {
        CreateSymlinkRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateSymlinkRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "target",
                    CreateSymlinkRequestProto::has_target,
                    CreateSymlinkRequestProto::get_target,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "link",
                    CreateSymlinkRequestProto::has_link,
                    CreateSymlinkRequestProto::get_link,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "dirPerm",
                    CreateSymlinkRequestProto::has_dirPerm,
                    CreateSymlinkRequestProto::get_dirPerm,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "createParent",
                    CreateSymlinkRequestProto::has_createParent,
                    CreateSymlinkRequestProto::get_createParent,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSymlinkRequestProto>(
                    "CreateSymlinkRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateSymlinkRequestProto {
    fn clear(&mut self) {
        self.clear_target();
        self.clear_link();
        self.clear_dirPerm();
        self.clear_createParent();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CreateSymlinkRequestProto {
    fn eq(&self, other: &CreateSymlinkRequestProto) -> bool {
        self.target == other.target &&
        self.link == other.link &&
        self.dirPerm == other.dirPerm &&
        self.createParent == other.createParent &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CreateSymlinkRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CreateSymlinkResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CreateSymlinkResponseProto {
    pub fn new() -> CreateSymlinkResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateSymlinkResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSymlinkResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSymlinkResponseProto,
        };
        unsafe {
            instance.get(|| {
                CreateSymlinkResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for CreateSymlinkResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CreateSymlinkResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateSymlinkResponseProto {
    fn new() -> CreateSymlinkResponseProto {
        CreateSymlinkResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateSymlinkResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CreateSymlinkResponseProto>(
                    "CreateSymlinkResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateSymlinkResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CreateSymlinkResponseProto {
    fn eq(&self, other: &CreateSymlinkResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CreateSymlinkResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetLinkTargetRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetLinkTargetRequestProto {
    pub fn new() -> GetLinkTargetRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetLinkTargetRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetLinkTargetRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetLinkTargetRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetLinkTargetRequestProto {
                    path: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        };
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path<'a>(&'a self) -> &'a str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for GetLinkTargetRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.path.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.path.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.path.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetLinkTargetRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetLinkTargetRequestProto {
    fn new() -> GetLinkTargetRequestProto {
        GetLinkTargetRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetLinkTargetRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "path",
                    GetLinkTargetRequestProto::has_path,
                    GetLinkTargetRequestProto::get_path,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetLinkTargetRequestProto>(
                    "GetLinkTargetRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetLinkTargetRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetLinkTargetRequestProto {
    fn eq(&self, other: &GetLinkTargetRequestProto) -> bool {
        self.path == other.path &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetLinkTargetRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetLinkTargetResponseProto {
    // message fields
    targetPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetLinkTargetResponseProto {
    pub fn new() -> GetLinkTargetResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetLinkTargetResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetLinkTargetResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetLinkTargetResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetLinkTargetResponseProto {
                    targetPath: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string targetPath = 1;

    pub fn clear_targetPath(&mut self) {
        self.targetPath.clear();
    }

    pub fn has_targetPath(&self) -> bool {
        self.targetPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPath(&mut self, v: ::std::string::String) {
        self.targetPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPath<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.targetPath.is_none() {
            self.targetPath.set_default();
        };
        self.targetPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPath(&mut self) -> ::std::string::String {
        self.targetPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_targetPath<'a>(&'a self) -> &'a str {
        match self.targetPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for GetLinkTargetResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.targetPath.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.targetPath.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.targetPath.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetLinkTargetResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetLinkTargetResponseProto {
    fn new() -> GetLinkTargetResponseProto {
        GetLinkTargetResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetLinkTargetResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "targetPath",
                    GetLinkTargetResponseProto::has_targetPath,
                    GetLinkTargetResponseProto::get_targetPath,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetLinkTargetResponseProto>(
                    "GetLinkTargetResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetLinkTargetResponseProto {
    fn clear(&mut self) {
        self.clear_targetPath();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetLinkTargetResponseProto {
    fn eq(&self, other: &GetLinkTargetResponseProto) -> bool {
        self.targetPath == other.targetPath &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetLinkTargetResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct UpdateBlockForPipelineRequestProto {
    // message fields
    block: ::protobuf::SingularPtrField<ExtendedBlockProto>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl UpdateBlockForPipelineRequestProto {
    pub fn new() -> UpdateBlockForPipelineRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UpdateBlockForPipelineRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdateBlockForPipelineRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateBlockForPipelineRequestProto,
        };
        unsafe {
            instance.get(|| {
                UpdateBlockForPipelineRequestProto {
                    block: ::protobuf::SingularPtrField::none(),
                    clientName: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.ExtendedBlockProto block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: ExtendedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block<'a>(&'a mut self) -> &'a mut ExtendedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        };
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> ExtendedBlockProto {
        self.block.take().unwrap_or_else(|| ExtendedBlockProto::new())
    }

    pub fn get_block<'a>(&'a self) -> &'a ExtendedBlockProto {
        self.block.as_ref().unwrap_or_else(|| ExtendedBlockProto::default_instance())
    }

    // required string clientName = 2;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        };
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName<'a>(&'a self) -> &'a str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for UpdateBlockForPipelineRequestProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        };
        if self.clientName.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.block.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.clientName.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.block.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.clientName.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.block.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.clientName.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<UpdateBlockForPipelineRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UpdateBlockForPipelineRequestProto {
    fn new() -> UpdateBlockForPipelineRequestProto {
        UpdateBlockForPipelineRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<UpdateBlockForPipelineRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "block",
                    UpdateBlockForPipelineRequestProto::has_block,
                    UpdateBlockForPipelineRequestProto::get_block,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "clientName",
                    UpdateBlockForPipelineRequestProto::has_clientName,
                    UpdateBlockForPipelineRequestProto::get_clientName,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateBlockForPipelineRequestProto>(
                    "UpdateBlockForPipelineRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UpdateBlockForPipelineRequestProto {
    fn clear(&mut self) {
        self.clear_block();
        self.clear_clientName();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for UpdateBlockForPipelineRequestProto {
    fn eq(&self, other: &UpdateBlockForPipelineRequestProto) -> bool {
        self.block == other.block &&
        self.clientName == other.clientName &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for UpdateBlockForPipelineRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct UpdateBlockForPipelineResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<LocatedBlockProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl UpdateBlockForPipelineResponseProto {
    pub fn new() -> UpdateBlockForPipelineResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UpdateBlockForPipelineResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdateBlockForPipelineResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateBlockForPipelineResponseProto,
        };
        unsafe {
            instance.get(|| {
                UpdateBlockForPipelineResponseProto {
                    block: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block<'a>(&'a mut self) -> &'a mut LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        };
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> LocatedBlockProto {
        self.block.take().unwrap_or_else(|| LocatedBlockProto::new())
    }

    pub fn get_block<'a>(&'a self) -> &'a LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| LocatedBlockProto::default_instance())
    }
}

impl ::protobuf::Message for UpdateBlockForPipelineResponseProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.block.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.block.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.block.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<UpdateBlockForPipelineResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UpdateBlockForPipelineResponseProto {
    fn new() -> UpdateBlockForPipelineResponseProto {
        UpdateBlockForPipelineResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<UpdateBlockForPipelineResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "block",
                    UpdateBlockForPipelineResponseProto::has_block,
                    UpdateBlockForPipelineResponseProto::get_block,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateBlockForPipelineResponseProto>(
                    "UpdateBlockForPipelineResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UpdateBlockForPipelineResponseProto {
    fn clear(&mut self) {
        self.clear_block();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for UpdateBlockForPipelineResponseProto {
    fn eq(&self, other: &UpdateBlockForPipelineResponseProto) -> bool {
        self.block == other.block &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for UpdateBlockForPipelineResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct UpdatePipelineRequestProto {
    // message fields
    clientName: ::protobuf::SingularField<::std::string::String>,
    oldBlock: ::protobuf::SingularPtrField<ExtendedBlockProto>,
    newBlock: ::protobuf::SingularPtrField<ExtendedBlockProto>,
    newNodes: ::protobuf::RepeatedField<DatanodeIDProto>,
    storageIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl UpdatePipelineRequestProto {
    pub fn new() -> UpdatePipelineRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UpdatePipelineRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdatePipelineRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdatePipelineRequestProto,
        };
        unsafe {
            instance.get(|| {
                UpdatePipelineRequestProto {
                    clientName: ::protobuf::SingularField::none(),
                    oldBlock: ::protobuf::SingularPtrField::none(),
                    newBlock: ::protobuf::SingularPtrField::none(),
                    newNodes: ::protobuf::RepeatedField::new(),
                    storageIDs: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string clientName = 1;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        };
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName<'a>(&'a self) -> &'a str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .hadoop.hdfs.ExtendedBlockProto oldBlock = 2;

    pub fn clear_oldBlock(&mut self) {
        self.oldBlock.clear();
    }

    pub fn has_oldBlock(&self) -> bool {
        self.oldBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldBlock(&mut self, v: ExtendedBlockProto) {
        self.oldBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldBlock<'a>(&'a mut self) -> &'a mut ExtendedBlockProto {
        if self.oldBlock.is_none() {
            self.oldBlock.set_default();
        };
        self.oldBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldBlock(&mut self) -> ExtendedBlockProto {
        self.oldBlock.take().unwrap_or_else(|| ExtendedBlockProto::new())
    }

    pub fn get_oldBlock<'a>(&'a self) -> &'a ExtendedBlockProto {
        self.oldBlock.as_ref().unwrap_or_else(|| ExtendedBlockProto::default_instance())
    }

    // required .hadoop.hdfs.ExtendedBlockProto newBlock = 3;

    pub fn clear_newBlock(&mut self) {
        self.newBlock.clear();
    }

    pub fn has_newBlock(&self) -> bool {
        self.newBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newBlock(&mut self, v: ExtendedBlockProto) {
        self.newBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newBlock<'a>(&'a mut self) -> &'a mut ExtendedBlockProto {
        if self.newBlock.is_none() {
            self.newBlock.set_default();
        };
        self.newBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_newBlock(&mut self) -> ExtendedBlockProto {
        self.newBlock.take().unwrap_or_else(|| ExtendedBlockProto::new())
    }

    pub fn get_newBlock<'a>(&'a self) -> &'a ExtendedBlockProto {
        self.newBlock.as_ref().unwrap_or_else(|| ExtendedBlockProto::default_instance())
    }

    // repeated .hadoop.hdfs.DatanodeIDProto newNodes = 4;

    pub fn clear_newNodes(&mut self) {
        self.newNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_newNodes(&mut self, v: ::protobuf::RepeatedField<DatanodeIDProto>) {
        self.newNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_newNodes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<DatanodeIDProto> {
        &mut self.newNodes
    }

    // Take field
    pub fn take_newNodes(&mut self) -> ::protobuf::RepeatedField<DatanodeIDProto> {
        ::std::mem::replace(&mut self.newNodes, ::protobuf::RepeatedField::new())
    }

    pub fn get_newNodes<'a>(&'a self) -> &'a [DatanodeIDProto] {
        &self.newNodes
    }

    // repeated string storageIDs = 5;

    pub fn clear_storageIDs(&mut self) {
        self.storageIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.storageIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageIDs<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.storageIDs
    }

    // Take field
    pub fn take_storageIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.storageIDs, ::protobuf::RepeatedField::new())
    }

    pub fn get_storageIDs<'a>(&'a self) -> &'a [::std::string::String] {
        &self.storageIDs
    }
}

impl ::protobuf::Message for UpdatePipelineRequestProto {
    fn is_initialized(&self) -> bool {
        if self.clientName.is_none() {
            return false;
        };
        if self.oldBlock.is_none() {
            return false;
        };
        if self.newBlock.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.clientName.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.oldBlock.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.newBlock.set_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.newNodes));
                },
                5 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.storageIDs));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.clientName.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.oldBlock.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.newBlock.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.newNodes.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.storageIDs.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.clientName.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.oldBlock.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.newBlock.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.newNodes.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.storageIDs.iter() {
            try!(os.write_string(5, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<UpdatePipelineRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UpdatePipelineRequestProto {
    fn new() -> UpdatePipelineRequestProto {
        UpdatePipelineRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<UpdatePipelineRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "clientName",
                    UpdatePipelineRequestProto::has_clientName,
                    UpdatePipelineRequestProto::get_clientName,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "oldBlock",
                    UpdatePipelineRequestProto::has_oldBlock,
                    UpdatePipelineRequestProto::get_oldBlock,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "newBlock",
                    UpdatePipelineRequestProto::has_newBlock,
                    UpdatePipelineRequestProto::get_newBlock,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "newNodes",
                    UpdatePipelineRequestProto::get_newNodes,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "storageIDs",
                    UpdatePipelineRequestProto::get_storageIDs,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdatePipelineRequestProto>(
                    "UpdatePipelineRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UpdatePipelineRequestProto {
    fn clear(&mut self) {
        self.clear_clientName();
        self.clear_oldBlock();
        self.clear_newBlock();
        self.clear_newNodes();
        self.clear_storageIDs();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for UpdatePipelineRequestProto {
    fn eq(&self, other: &UpdatePipelineRequestProto) -> bool {
        self.clientName == other.clientName &&
        self.oldBlock == other.oldBlock &&
        self.newBlock == other.newBlock &&
        self.newNodes == other.newNodes &&
        self.storageIDs == other.storageIDs &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for UpdatePipelineRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct UpdatePipelineResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl UpdatePipelineResponseProto {
    pub fn new() -> UpdatePipelineResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UpdatePipelineResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdatePipelineResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdatePipelineResponseProto,
        };
        unsafe {
            instance.get(|| {
                UpdatePipelineResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for UpdatePipelineResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<UpdatePipelineResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UpdatePipelineResponseProto {
    fn new() -> UpdatePipelineResponseProto {
        UpdatePipelineResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<UpdatePipelineResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<UpdatePipelineResponseProto>(
                    "UpdatePipelineResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UpdatePipelineResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for UpdatePipelineResponseProto {
    fn eq(&self, other: &UpdatePipelineResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for UpdatePipelineResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetBalancerBandwidthRequestProto {
    // message fields
    bandwidth: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetBalancerBandwidthRequestProto {
    pub fn new() -> SetBalancerBandwidthRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetBalancerBandwidthRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetBalancerBandwidthRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetBalancerBandwidthRequestProto,
        };
        unsafe {
            instance.get(|| {
                SetBalancerBandwidthRequestProto {
                    bandwidth: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required int64 bandwidth = 1;

    pub fn clear_bandwidth(&mut self) {
        self.bandwidth = ::std::option::Option::None;
    }

    pub fn has_bandwidth(&self) -> bool {
        self.bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bandwidth(&mut self, v: i64) {
        self.bandwidth = ::std::option::Option::Some(v);
    }

    pub fn get_bandwidth<'a>(&self) -> i64 {
        self.bandwidth.unwrap_or(0)
    }
}

impl ::protobuf::Message for SetBalancerBandwidthRequestProto {
    fn is_initialized(&self) -> bool {
        if self.bandwidth.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.bandwidth = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.bandwidth.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bandwidth {
            try!(os.write_int64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetBalancerBandwidthRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetBalancerBandwidthRequestProto {
    fn new() -> SetBalancerBandwidthRequestProto {
        SetBalancerBandwidthRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetBalancerBandwidthRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "bandwidth",
                    SetBalancerBandwidthRequestProto::has_bandwidth,
                    SetBalancerBandwidthRequestProto::get_bandwidth,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetBalancerBandwidthRequestProto>(
                    "SetBalancerBandwidthRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetBalancerBandwidthRequestProto {
    fn clear(&mut self) {
        self.clear_bandwidth();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetBalancerBandwidthRequestProto {
    fn eq(&self, other: &SetBalancerBandwidthRequestProto) -> bool {
        self.bandwidth == other.bandwidth &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetBalancerBandwidthRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SetBalancerBandwidthResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SetBalancerBandwidthResponseProto {
    pub fn new() -> SetBalancerBandwidthResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetBalancerBandwidthResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetBalancerBandwidthResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetBalancerBandwidthResponseProto,
        };
        unsafe {
            instance.get(|| {
                SetBalancerBandwidthResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for SetBalancerBandwidthResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SetBalancerBandwidthResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetBalancerBandwidthResponseProto {
    fn new() -> SetBalancerBandwidthResponseProto {
        SetBalancerBandwidthResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetBalancerBandwidthResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetBalancerBandwidthResponseProto>(
                    "SetBalancerBandwidthResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetBalancerBandwidthResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SetBalancerBandwidthResponseProto {
    fn eq(&self, other: &SetBalancerBandwidthResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SetBalancerBandwidthResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetDataEncryptionKeyRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetDataEncryptionKeyRequestProto {
    pub fn new() -> GetDataEncryptionKeyRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDataEncryptionKeyRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDataEncryptionKeyRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDataEncryptionKeyRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetDataEncryptionKeyRequestProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for GetDataEncryptionKeyRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetDataEncryptionKeyRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDataEncryptionKeyRequestProto {
    fn new() -> GetDataEncryptionKeyRequestProto {
        GetDataEncryptionKeyRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDataEncryptionKeyRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetDataEncryptionKeyRequestProto>(
                    "GetDataEncryptionKeyRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDataEncryptionKeyRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetDataEncryptionKeyRequestProto {
    fn eq(&self, other: &GetDataEncryptionKeyRequestProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetDataEncryptionKeyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetDataEncryptionKeyResponseProto {
    // message fields
    dataEncryptionKey: ::protobuf::SingularPtrField<DataEncryptionKeyProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetDataEncryptionKeyResponseProto {
    pub fn new() -> GetDataEncryptionKeyResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDataEncryptionKeyResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDataEncryptionKeyResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDataEncryptionKeyResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetDataEncryptionKeyResponseProto {
                    dataEncryptionKey: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .hadoop.hdfs.DataEncryptionKeyProto dataEncryptionKey = 1;

    pub fn clear_dataEncryptionKey(&mut self) {
        self.dataEncryptionKey.clear();
    }

    pub fn has_dataEncryptionKey(&self) -> bool {
        self.dataEncryptionKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataEncryptionKey(&mut self, v: DataEncryptionKeyProto) {
        self.dataEncryptionKey = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataEncryptionKey<'a>(&'a mut self) -> &'a mut DataEncryptionKeyProto {
        if self.dataEncryptionKey.is_none() {
            self.dataEncryptionKey.set_default();
        };
        self.dataEncryptionKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_dataEncryptionKey(&mut self) -> DataEncryptionKeyProto {
        self.dataEncryptionKey.take().unwrap_or_else(|| DataEncryptionKeyProto::new())
    }

    pub fn get_dataEncryptionKey<'a>(&'a self) -> &'a DataEncryptionKeyProto {
        self.dataEncryptionKey.as_ref().unwrap_or_else(|| DataEncryptionKeyProto::default_instance())
    }
}

impl ::protobuf::Message for GetDataEncryptionKeyResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.dataEncryptionKey.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.dataEncryptionKey.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dataEncryptionKey.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetDataEncryptionKeyResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDataEncryptionKeyResponseProto {
    fn new() -> GetDataEncryptionKeyResponseProto {
        GetDataEncryptionKeyResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDataEncryptionKeyResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "dataEncryptionKey",
                    GetDataEncryptionKeyResponseProto::has_dataEncryptionKey,
                    GetDataEncryptionKeyResponseProto::get_dataEncryptionKey,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDataEncryptionKeyResponseProto>(
                    "GetDataEncryptionKeyResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDataEncryptionKeyResponseProto {
    fn clear(&mut self) {
        self.clear_dataEncryptionKey();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetDataEncryptionKeyResponseProto {
    fn eq(&self, other: &GetDataEncryptionKeyResponseProto) -> bool {
        self.dataEncryptionKey == other.dataEncryptionKey &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetDataEncryptionKeyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CreateSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    snapshotName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CreateSnapshotRequestProto {
    pub fn new() -> CreateSnapshotRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSnapshotRequestProto,
        };
        unsafe {
            instance.get(|| {
                CreateSnapshotRequestProto {
                    snapshotRoot: ::protobuf::SingularField::none(),
                    snapshotName: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        };
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot<'a>(&'a self) -> &'a str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string snapshotName = 2;

    pub fn clear_snapshotName(&mut self) {
        self.snapshotName.clear();
    }

    pub fn has_snapshotName(&self) -> bool {
        self.snapshotName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotName(&mut self, v: ::std::string::String) {
        self.snapshotName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.snapshotName.is_none() {
            self.snapshotName.set_default();
        };
        self.snapshotName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotName(&mut self) -> ::std::string::String {
        self.snapshotName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotName<'a>(&'a self) -> &'a str {
        match self.snapshotName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CreateSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.snapshotRoot.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.snapshotName.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.snapshotRoot.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.snapshotName.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.snapshotRoot.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.snapshotName.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CreateSnapshotRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateSnapshotRequestProto {
    fn new() -> CreateSnapshotRequestProto {
        CreateSnapshotRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateSnapshotRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "snapshotRoot",
                    CreateSnapshotRequestProto::has_snapshotRoot,
                    CreateSnapshotRequestProto::get_snapshotRoot,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "snapshotName",
                    CreateSnapshotRequestProto::has_snapshotName,
                    CreateSnapshotRequestProto::get_snapshotName,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSnapshotRequestProto>(
                    "CreateSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateSnapshotRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.clear_snapshotName();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CreateSnapshotRequestProto {
    fn eq(&self, other: &CreateSnapshotRequestProto) -> bool {
        self.snapshotRoot == other.snapshotRoot &&
        self.snapshotName == other.snapshotName &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CreateSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CreateSnapshotResponseProto {
    // message fields
    snapshotPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CreateSnapshotResponseProto {
    pub fn new() -> CreateSnapshotResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSnapshotResponseProto,
        };
        unsafe {
            instance.get(|| {
                CreateSnapshotResponseProto {
                    snapshotPath: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string snapshotPath = 1;

    pub fn clear_snapshotPath(&mut self) {
        self.snapshotPath.clear();
    }

    pub fn has_snapshotPath(&self) -> bool {
        self.snapshotPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotPath(&mut self, v: ::std::string::String) {
        self.snapshotPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotPath<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.snapshotPath.is_none() {
            self.snapshotPath.set_default();
        };
        self.snapshotPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotPath(&mut self) -> ::std::string::String {
        self.snapshotPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotPath<'a>(&'a self) -> &'a str {
        match self.snapshotPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CreateSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotPath.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.snapshotPath.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.snapshotPath.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.snapshotPath.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CreateSnapshotResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateSnapshotResponseProto {
    fn new() -> CreateSnapshotResponseProto {
        CreateSnapshotResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateSnapshotResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "snapshotPath",
                    CreateSnapshotResponseProto::has_snapshotPath,
                    CreateSnapshotResponseProto::get_snapshotPath,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSnapshotResponseProto>(
                    "CreateSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateSnapshotResponseProto {
    fn clear(&mut self) {
        self.clear_snapshotPath();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CreateSnapshotResponseProto {
    fn eq(&self, other: &CreateSnapshotResponseProto) -> bool {
        self.snapshotPath == other.snapshotPath &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CreateSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RenameSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    snapshotOldName: ::protobuf::SingularField<::std::string::String>,
    snapshotNewName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RenameSnapshotRequestProto {
    pub fn new() -> RenameSnapshotRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenameSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameSnapshotRequestProto,
        };
        unsafe {
            instance.get(|| {
                RenameSnapshotRequestProto {
                    snapshotRoot: ::protobuf::SingularField::none(),
                    snapshotOldName: ::protobuf::SingularField::none(),
                    snapshotNewName: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        };
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot<'a>(&'a self) -> &'a str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string snapshotOldName = 2;

    pub fn clear_snapshotOldName(&mut self) {
        self.snapshotOldName.clear();
    }

    pub fn has_snapshotOldName(&self) -> bool {
        self.snapshotOldName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotOldName(&mut self, v: ::std::string::String) {
        self.snapshotOldName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotOldName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.snapshotOldName.is_none() {
            self.snapshotOldName.set_default();
        };
        self.snapshotOldName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotOldName(&mut self) -> ::std::string::String {
        self.snapshotOldName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotOldName<'a>(&'a self) -> &'a str {
        match self.snapshotOldName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string snapshotNewName = 3;

    pub fn clear_snapshotNewName(&mut self) {
        self.snapshotNewName.clear();
    }

    pub fn has_snapshotNewName(&self) -> bool {
        self.snapshotNewName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotNewName(&mut self, v: ::std::string::String) {
        self.snapshotNewName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotNewName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.snapshotNewName.is_none() {
            self.snapshotNewName.set_default();
        };
        self.snapshotNewName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotNewName(&mut self) -> ::std::string::String {
        self.snapshotNewName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotNewName<'a>(&'a self) -> &'a str {
        match self.snapshotNewName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RenameSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        };
        if self.snapshotOldName.is_none() {
            return false;
        };
        if self.snapshotNewName.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.snapshotRoot.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.snapshotOldName.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.snapshotNewName.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.snapshotRoot.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.snapshotOldName.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.snapshotNewName.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.snapshotRoot.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.snapshotOldName.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.snapshotNewName.as_ref() {
            try!(os.write_string(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RenameSnapshotRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenameSnapshotRequestProto {
    fn new() -> RenameSnapshotRequestProto {
        RenameSnapshotRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenameSnapshotRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "snapshotRoot",
                    RenameSnapshotRequestProto::has_snapshotRoot,
                    RenameSnapshotRequestProto::get_snapshotRoot,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "snapshotOldName",
                    RenameSnapshotRequestProto::has_snapshotOldName,
                    RenameSnapshotRequestProto::get_snapshotOldName,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "snapshotNewName",
                    RenameSnapshotRequestProto::has_snapshotNewName,
                    RenameSnapshotRequestProto::get_snapshotNewName,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenameSnapshotRequestProto>(
                    "RenameSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenameSnapshotRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.clear_snapshotOldName();
        self.clear_snapshotNewName();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RenameSnapshotRequestProto {
    fn eq(&self, other: &RenameSnapshotRequestProto) -> bool {
        self.snapshotRoot == other.snapshotRoot &&
        self.snapshotOldName == other.snapshotOldName &&
        self.snapshotNewName == other.snapshotNewName &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RenameSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RenameSnapshotResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RenameSnapshotResponseProto {
    pub fn new() -> RenameSnapshotResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenameSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameSnapshotResponseProto,
        };
        unsafe {
            instance.get(|| {
                RenameSnapshotResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for RenameSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RenameSnapshotResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenameSnapshotResponseProto {
    fn new() -> RenameSnapshotResponseProto {
        RenameSnapshotResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenameSnapshotResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RenameSnapshotResponseProto>(
                    "RenameSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenameSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RenameSnapshotResponseProto {
    fn eq(&self, other: &RenameSnapshotResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RenameSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct AllowSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl AllowSnapshotRequestProto {
    pub fn new() -> AllowSnapshotRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AllowSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AllowSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllowSnapshotRequestProto,
        };
        unsafe {
            instance.get(|| {
                AllowSnapshotRequestProto {
                    snapshotRoot: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        };
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot<'a>(&'a self) -> &'a str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AllowSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.snapshotRoot.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.snapshotRoot.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.snapshotRoot.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<AllowSnapshotRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AllowSnapshotRequestProto {
    fn new() -> AllowSnapshotRequestProto {
        AllowSnapshotRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AllowSnapshotRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "snapshotRoot",
                    AllowSnapshotRequestProto::has_snapshotRoot,
                    AllowSnapshotRequestProto::get_snapshotRoot,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AllowSnapshotRequestProto>(
                    "AllowSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AllowSnapshotRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for AllowSnapshotRequestProto {
    fn eq(&self, other: &AllowSnapshotRequestProto) -> bool {
        self.snapshotRoot == other.snapshotRoot &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for AllowSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct AllowSnapshotResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl AllowSnapshotResponseProto {
    pub fn new() -> AllowSnapshotResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AllowSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AllowSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllowSnapshotResponseProto,
        };
        unsafe {
            instance.get(|| {
                AllowSnapshotResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for AllowSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<AllowSnapshotResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AllowSnapshotResponseProto {
    fn new() -> AllowSnapshotResponseProto {
        AllowSnapshotResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AllowSnapshotResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AllowSnapshotResponseProto>(
                    "AllowSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AllowSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for AllowSnapshotResponseProto {
    fn eq(&self, other: &AllowSnapshotResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for AllowSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct DisallowSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl DisallowSnapshotRequestProto {
    pub fn new() -> DisallowSnapshotRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DisallowSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<DisallowSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisallowSnapshotRequestProto,
        };
        unsafe {
            instance.get(|| {
                DisallowSnapshotRequestProto {
                    snapshotRoot: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        };
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot<'a>(&'a self) -> &'a str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DisallowSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.snapshotRoot.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.snapshotRoot.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.snapshotRoot.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<DisallowSnapshotRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DisallowSnapshotRequestProto {
    fn new() -> DisallowSnapshotRequestProto {
        DisallowSnapshotRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DisallowSnapshotRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "snapshotRoot",
                    DisallowSnapshotRequestProto::has_snapshotRoot,
                    DisallowSnapshotRequestProto::get_snapshotRoot,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DisallowSnapshotRequestProto>(
                    "DisallowSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DisallowSnapshotRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for DisallowSnapshotRequestProto {
    fn eq(&self, other: &DisallowSnapshotRequestProto) -> bool {
        self.snapshotRoot == other.snapshotRoot &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for DisallowSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct DisallowSnapshotResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl DisallowSnapshotResponseProto {
    pub fn new() -> DisallowSnapshotResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DisallowSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<DisallowSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisallowSnapshotResponseProto,
        };
        unsafe {
            instance.get(|| {
                DisallowSnapshotResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for DisallowSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<DisallowSnapshotResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DisallowSnapshotResponseProto {
    fn new() -> DisallowSnapshotResponseProto {
        DisallowSnapshotResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DisallowSnapshotResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DisallowSnapshotResponseProto>(
                    "DisallowSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DisallowSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for DisallowSnapshotResponseProto {
    fn eq(&self, other: &DisallowSnapshotResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for DisallowSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct DeleteSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    snapshotName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl DeleteSnapshotRequestProto {
    pub fn new() -> DeleteSnapshotRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeleteSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteSnapshotRequestProto,
        };
        unsafe {
            instance.get(|| {
                DeleteSnapshotRequestProto {
                    snapshotRoot: ::protobuf::SingularField::none(),
                    snapshotName: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        };
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot<'a>(&'a self) -> &'a str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string snapshotName = 2;

    pub fn clear_snapshotName(&mut self) {
        self.snapshotName.clear();
    }

    pub fn has_snapshotName(&self) -> bool {
        self.snapshotName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotName(&mut self, v: ::std::string::String) {
        self.snapshotName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.snapshotName.is_none() {
            self.snapshotName.set_default();
        };
        self.snapshotName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotName(&mut self) -> ::std::string::String {
        self.snapshotName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotName<'a>(&'a self) -> &'a str {
        match self.snapshotName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DeleteSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        };
        if self.snapshotName.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.snapshotRoot.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.snapshotName.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.snapshotRoot.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.snapshotName.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.snapshotRoot.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.snapshotName.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<DeleteSnapshotRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeleteSnapshotRequestProto {
    fn new() -> DeleteSnapshotRequestProto {
        DeleteSnapshotRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeleteSnapshotRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "snapshotRoot",
                    DeleteSnapshotRequestProto::has_snapshotRoot,
                    DeleteSnapshotRequestProto::get_snapshotRoot,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "snapshotName",
                    DeleteSnapshotRequestProto::has_snapshotName,
                    DeleteSnapshotRequestProto::get_snapshotName,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteSnapshotRequestProto>(
                    "DeleteSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeleteSnapshotRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.clear_snapshotName();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for DeleteSnapshotRequestProto {
    fn eq(&self, other: &DeleteSnapshotRequestProto) -> bool {
        self.snapshotRoot == other.snapshotRoot &&
        self.snapshotName == other.snapshotName &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for DeleteSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct DeleteSnapshotResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl DeleteSnapshotResponseProto {
    pub fn new() -> DeleteSnapshotResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeleteSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteSnapshotResponseProto,
        };
        unsafe {
            instance.get(|| {
                DeleteSnapshotResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for DeleteSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<DeleteSnapshotResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeleteSnapshotResponseProto {
    fn new() -> DeleteSnapshotResponseProto {
        DeleteSnapshotResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeleteSnapshotResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DeleteSnapshotResponseProto>(
                    "DeleteSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeleteSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for DeleteSnapshotResponseProto {
    fn eq(&self, other: &DeleteSnapshotResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for DeleteSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CheckAccessRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    mode: ::std::option::Option<AclEntryProto_FsActionProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CheckAccessRequestProto {
    pub fn new() -> CheckAccessRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CheckAccessRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CheckAccessRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckAccessRequestProto,
        };
        unsafe {
            instance.get(|| {
                CheckAccessRequestProto {
                    path: ::protobuf::SingularField::none(),
                    mode: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        };
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path<'a>(&'a self) -> &'a str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .hadoop.hdfs.AclEntryProto.FsActionProto mode = 2;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: AclEntryProto_FsActionProto) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode<'a>(&self) -> AclEntryProto_FsActionProto {
        self.mode.unwrap_or(AclEntryProto_FsActionProto::NONE)
    }
}

impl ::protobuf::Message for CheckAccessRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        };
        if self.mode.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.path.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.mode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.path.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.mode.iter() {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.path.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.mode {
            try!(os.write_enum(2, v as i32));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CheckAccessRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CheckAccessRequestProto {
    fn new() -> CheckAccessRequestProto {
        CheckAccessRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CheckAccessRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "path",
                    CheckAccessRequestProto::has_path,
                    CheckAccessRequestProto::get_path,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "mode",
                    CheckAccessRequestProto::has_mode,
                    CheckAccessRequestProto::get_mode,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CheckAccessRequestProto>(
                    "CheckAccessRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CheckAccessRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.clear_mode();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CheckAccessRequestProto {
    fn eq(&self, other: &CheckAccessRequestProto) -> bool {
        self.path == other.path &&
        self.mode == other.mode &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CheckAccessRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CheckAccessResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CheckAccessResponseProto {
    pub fn new() -> CheckAccessResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CheckAccessResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CheckAccessResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckAccessResponseProto,
        };
        unsafe {
            instance.get(|| {
                CheckAccessResponseProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for CheckAccessResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CheckAccessResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CheckAccessResponseProto {
    fn new() -> CheckAccessResponseProto {
        CheckAccessResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CheckAccessResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CheckAccessResponseProto>(
                    "CheckAccessResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CheckAccessResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CheckAccessResponseProto {
    fn eq(&self, other: &CheckAccessResponseProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CheckAccessResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetCurrentEditLogTxidRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetCurrentEditLogTxidRequestProto {
    pub fn new() -> GetCurrentEditLogTxidRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetCurrentEditLogTxidRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetCurrentEditLogTxidRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetCurrentEditLogTxidRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetCurrentEditLogTxidRequestProto {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for GetCurrentEditLogTxidRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetCurrentEditLogTxidRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetCurrentEditLogTxidRequestProto {
    fn new() -> GetCurrentEditLogTxidRequestProto {
        GetCurrentEditLogTxidRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetCurrentEditLogTxidRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetCurrentEditLogTxidRequestProto>(
                    "GetCurrentEditLogTxidRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetCurrentEditLogTxidRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetCurrentEditLogTxidRequestProto {
    fn eq(&self, other: &GetCurrentEditLogTxidRequestProto) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetCurrentEditLogTxidRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetCurrentEditLogTxidResponseProto {
    // message fields
    txid: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetCurrentEditLogTxidResponseProto {
    pub fn new() -> GetCurrentEditLogTxidResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetCurrentEditLogTxidResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetCurrentEditLogTxidResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetCurrentEditLogTxidResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetCurrentEditLogTxidResponseProto {
                    txid: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required int64 txid = 1;

    pub fn clear_txid(&mut self) {
        self.txid = ::std::option::Option::None;
    }

    pub fn has_txid(&self) -> bool {
        self.txid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: i64) {
        self.txid = ::std::option::Option::Some(v);
    }

    pub fn get_txid<'a>(&self) -> i64 {
        self.txid.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetCurrentEditLogTxidResponseProto {
    fn is_initialized(&self) -> bool {
        if self.txid.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.txid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.txid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txid {
            try!(os.write_int64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetCurrentEditLogTxidResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetCurrentEditLogTxidResponseProto {
    fn new() -> GetCurrentEditLogTxidResponseProto {
        GetCurrentEditLogTxidResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetCurrentEditLogTxidResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "txid",
                    GetCurrentEditLogTxidResponseProto::has_txid,
                    GetCurrentEditLogTxidResponseProto::get_txid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetCurrentEditLogTxidResponseProto>(
                    "GetCurrentEditLogTxidResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetCurrentEditLogTxidResponseProto {
    fn clear(&mut self) {
        self.clear_txid();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetCurrentEditLogTxidResponseProto {
    fn eq(&self, other: &GetCurrentEditLogTxidResponseProto) -> bool {
        self.txid == other.txid &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetCurrentEditLogTxidResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetEditsFromTxidRequestProto {
    // message fields
    txid: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetEditsFromTxidRequestProto {
    pub fn new() -> GetEditsFromTxidRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetEditsFromTxidRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetEditsFromTxidRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetEditsFromTxidRequestProto,
        };
        unsafe {
            instance.get(|| {
                GetEditsFromTxidRequestProto {
                    txid: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required int64 txid = 1;

    pub fn clear_txid(&mut self) {
        self.txid = ::std::option::Option::None;
    }

    pub fn has_txid(&self) -> bool {
        self.txid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: i64) {
        self.txid = ::std::option::Option::Some(v);
    }

    pub fn get_txid<'a>(&self) -> i64 {
        self.txid.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetEditsFromTxidRequestProto {
    fn is_initialized(&self) -> bool {
        if self.txid.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.txid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.txid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txid {
            try!(os.write_int64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetEditsFromTxidRequestProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetEditsFromTxidRequestProto {
    fn new() -> GetEditsFromTxidRequestProto {
        GetEditsFromTxidRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetEditsFromTxidRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "txid",
                    GetEditsFromTxidRequestProto::has_txid,
                    GetEditsFromTxidRequestProto::get_txid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetEditsFromTxidRequestProto>(
                    "GetEditsFromTxidRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetEditsFromTxidRequestProto {
    fn clear(&mut self) {
        self.clear_txid();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetEditsFromTxidRequestProto {
    fn eq(&self, other: &GetEditsFromTxidRequestProto) -> bool {
        self.txid == other.txid &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetEditsFromTxidRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct GetEditsFromTxidResponseProto {
    // message fields
    eventsList: ::protobuf::SingularPtrField<EventsListProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl GetEditsFromTxidResponseProto {
    pub fn new() -> GetEditsFromTxidResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetEditsFromTxidResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetEditsFromTxidResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetEditsFromTxidResponseProto,
        };
        unsafe {
            instance.get(|| {
                GetEditsFromTxidResponseProto {
                    eventsList: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .hadoop.hdfs.EventsListProto eventsList = 1;

    pub fn clear_eventsList(&mut self) {
        self.eventsList.clear();
    }

    pub fn has_eventsList(&self) -> bool {
        self.eventsList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventsList(&mut self, v: EventsListProto) {
        self.eventsList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventsList<'a>(&'a mut self) -> &'a mut EventsListProto {
        if self.eventsList.is_none() {
            self.eventsList.set_default();
        };
        self.eventsList.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventsList(&mut self) -> EventsListProto {
        self.eventsList.take().unwrap_or_else(|| EventsListProto::new())
    }

    pub fn get_eventsList<'a>(&'a self) -> &'a EventsListProto {
        self.eventsList.as_ref().unwrap_or_else(|| EventsListProto::default_instance())
    }
}

impl ::protobuf::Message for GetEditsFromTxidResponseProto {
    fn is_initialized(&self) -> bool {
        if self.eventsList.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.eventsList.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eventsList.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eventsList.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<GetEditsFromTxidResponseProto>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetEditsFromTxidResponseProto {
    fn new() -> GetEditsFromTxidResponseProto {
        GetEditsFromTxidResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetEditsFromTxidResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "eventsList",
                    GetEditsFromTxidResponseProto::has_eventsList,
                    GetEditsFromTxidResponseProto::get_eventsList,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetEditsFromTxidResponseProto>(
                    "GetEditsFromTxidResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetEditsFromTxidResponseProto {
    fn clear(&mut self) {
        self.clear_eventsList();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for GetEditsFromTxidResponseProto {
    fn eq(&self, other: &GetEditsFromTxidResponseProto) -> bool {
        self.eventsList == other.eventsList &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for GetEditsFromTxidResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CreateFlagProto {
    CREATE = 1,
    OVERWRITE = 2,
    APPEND = 4,
    LAZY_PERSIST = 16,
    NEW_BLOCK = 32,
}

impl ::protobuf::ProtobufEnum for CreateFlagProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CreateFlagProto> {
        match value {
            1 => ::std::option::Option::Some(CreateFlagProto::CREATE),
            2 => ::std::option::Option::Some(CreateFlagProto::OVERWRITE),
            4 => ::std::option::Option::Some(CreateFlagProto::APPEND),
            16 => ::std::option::Option::Some(CreateFlagProto::LAZY_PERSIST),
            32 => ::std::option::Option::Some(CreateFlagProto::NEW_BLOCK),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<CreateFlagProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CreateFlagProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CreateFlagProto {
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DatanodeReportTypeProto {
    ALL = 1,
    LIVE = 2,
    DEAD = 3,
    DECOMMISSIONING = 4,
}

impl ::protobuf::ProtobufEnum for DatanodeReportTypeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatanodeReportTypeProto> {
        match value {
            1 => ::std::option::Option::Some(DatanodeReportTypeProto::ALL),
            2 => ::std::option::Option::Some(DatanodeReportTypeProto::LIVE),
            3 => ::std::option::Option::Some(DatanodeReportTypeProto::DEAD),
            4 => ::std::option::Option::Some(DatanodeReportTypeProto::DECOMMISSIONING),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<DatanodeReportTypeProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DatanodeReportTypeProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DatanodeReportTypeProto {
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SafeModeActionProto {
    SAFEMODE_LEAVE = 1,
    SAFEMODE_ENTER = 2,
    SAFEMODE_GET = 3,
}

impl ::protobuf::ProtobufEnum for SafeModeActionProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SafeModeActionProto> {
        match value {
            1 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_LEAVE),
            2 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_ENTER),
            3 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_GET),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<SafeModeActionProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SafeModeActionProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SafeModeActionProto {
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RollingUpgradeActionProto {
    QUERY = 1,
    START = 2,
    FINALIZE = 3,
}

impl ::protobuf::ProtobufEnum for RollingUpgradeActionProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RollingUpgradeActionProto> {
        match value {
            1 => ::std::option::Option::Some(RollingUpgradeActionProto::QUERY),
            2 => ::std::option::Option::Some(RollingUpgradeActionProto::START),
            3 => ::std::option::Option::Some(RollingUpgradeActionProto::FINALIZE),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<RollingUpgradeActionProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RollingUpgradeActionProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RollingUpgradeActionProto {
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CacheFlagProto {
    FORCE = 1,
}

impl ::protobuf::ProtobufEnum for CacheFlagProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CacheFlagProto> {
        match value {
            1 => ::std::option::Option::Some(CacheFlagProto::FORCE),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<CacheFlagProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CacheFlagProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CacheFlagProto {
}

static file_descriptor_proto_data: &'static [u8] = &[
    0x0a, 0x1c, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x6e, 0x6f, 0x64, 0x65,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x1a, 0x0e, 0x53, 0x65, 0x63,
    0x75, 0x72, 0x69, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x0a, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x09, 0x61, 0x63, 0x6c, 0x2e, 0x70, 0x72, 0x6f,
    0x74, 0x6f, 0x1a, 0x0b, 0x78, 0x61, 0x74, 0x74, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a,
    0x10, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74,
    0x6f, 0x1a, 0x0d, 0x69, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
    0x22, 0x4c, 0x0a, 0x1d, 0x47, 0x65, 0x74, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x4c, 0x6f, 0x63, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0e,
    0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04, 0x12, 0x0e,
    0x0a, 0x06, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x03, 0x20, 0x02, 0x28, 0x04, 0x22, 0x54,
    0x0a, 0x1e, 0x47, 0x65, 0x74, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x12, 0x32, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x65, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x22, 0x1f, 0x0a, 0x1d, 0x47, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65,
    0x72, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x5c, 0x0a, 0x1e, 0x47, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76,
    0x65, 0x72, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x3a, 0x0a, 0x0e, 0x73, 0x65, 0x72, 0x76, 0x65,
    0x72, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32,
    0x22, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x46, 0x73,
    0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x22, 0xff, 0x01, 0x0a, 0x12, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x52, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72,
    0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x2e, 0x0a, 0x06, 0x6d, 0x61, 0x73, 0x6b, 0x65,
    0x64, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70,
    0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x46, 0x73, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69,
    0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x02, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a, 0x63,
    0x72, 0x65, 0x61, 0x74, 0x65, 0x46, 0x6c, 0x61, 0x67, 0x18, 0x04, 0x20, 0x02, 0x28, 0x0d, 0x12,
    0x14, 0x0a, 0x0c, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x18,
    0x05, 0x20, 0x02, 0x28, 0x08, 0x12, 0x13, 0x0a, 0x0b, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x02, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x62, 0x6c,
    0x6f, 0x63, 0x6b, 0x53, 0x69, 0x7a, 0x65, 0x18, 0x07, 0x20, 0x02, 0x28, 0x04, 0x12, 0x46, 0x0a,
    0x15, 0x63, 0x72, 0x79, 0x70, 0x74, 0x6f, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x56,
    0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x27, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x72, 0x79, 0x70, 0x74,
    0x6f, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x43, 0x0a, 0x13, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x52,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x2c, 0x0a, 0x02,
    0x66, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f,
    0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x48, 0x64, 0x66, 0x73, 0x46, 0x69, 0x6c, 0x65, 0x53,
    0x74, 0x61, 0x74, 0x75, 0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x43, 0x0a, 0x12, 0x41, 0x70,
    0x70, 0x65, 0x6e, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x12, 0x0a,
    0x0a, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28,
    0x09, 0x12, 0x0c, 0x0a, 0x04, 0x66, 0x6c, 0x61, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x22,
    0x74, 0x0a, 0x13, 0x41, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x2d, 0x0a, 0x05, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68,
    0x64, 0x66, 0x73, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x65, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x2e, 0x0a, 0x04, 0x73, 0x74, 0x61, 0x74, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x48, 0x64, 0x66, 0x73, 0x46, 0x69, 0x6c, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x3e, 0x0a, 0x1a, 0x53, 0x65, 0x74, 0x52, 0x65, 0x70, 0x6c,
    0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09,
    0x12, 0x13, 0x0a, 0x0b, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18,
    0x02, 0x20, 0x02, 0x28, 0x0d, 0x22, 0x2d, 0x0a, 0x1b, 0x53, 0x65, 0x74, 0x52, 0x65, 0x70, 0x6c,
    0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x0a, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01,
    0x20, 0x02, 0x28, 0x08, 0x22, 0x3f, 0x0a, 0x1c, 0x53, 0x65, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61,
    0x67, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x09, 0x12, 0x12, 0x0a, 0x0a, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4e, 0x61, 0x6d, 0x65, 0x18,
    0x02, 0x20, 0x02, 0x28, 0x09, 0x22, 0x1f, 0x0a, 0x1d, 0x53, 0x65, 0x74, 0x53, 0x74, 0x6f, 0x72,
    0x61, 0x67, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x20, 0x0a, 0x1e, 0x47, 0x65, 0x74, 0x53, 0x74, 0x6f,
    0x72, 0x61, 0x67, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x59, 0x0a, 0x1f, 0x47, 0x65, 0x74, 0x53,
    0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x36, 0x0a, 0x08, 0x70,
    0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x24, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x42, 0x6c, 0x6f, 0x63,
    0x6b, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x22, 0x5c, 0x0a, 0x19, 0x53, 0x65, 0x74, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73,
    0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x32, 0x0a,
    0x0a, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x02, 0x28,
    0x0b, 0x32, 0x1e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e,
    0x46, 0x73, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x22, 0x1c, 0x0a, 0x1a, 0x53, 0x65, 0x74, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69,
    0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22,
    0x48, 0x0a, 0x14, 0x53, 0x65, 0x74, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01,
    0x20, 0x02, 0x28, 0x09, 0x12, 0x10, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x6e,
    0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x22, 0x17, 0x0a, 0x15, 0x53, 0x65, 0x74,
    0x4f, 0x77, 0x6e, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x22, 0x76, 0x0a, 0x18, 0x41, 0x62, 0x61, 0x6e, 0x64, 0x6f, 0x6e, 0x42, 0x6c, 0x6f,
    0x63, 0x6b, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x2a,
    0x0a, 0x01, 0x62, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x68, 0x61, 0x64, 0x6f,
    0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x64, 0x65, 0x64,
    0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72,
    0x63, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0e, 0x0a, 0x06, 0x68, 0x6f, 0x6c, 0x64, 0x65,
    0x72, 0x18, 0x03, 0x20, 0x02, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x06, 0x66, 0x69, 0x6c, 0x65, 0x49,
    0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x3a, 0x01, 0x30, 0x22, 0x1b, 0x0a, 0x19, 0x41, 0x62,
    0x61, 0x6e, 0x64, 0x6f, 0x6e, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xc9, 0x01, 0x0a, 0x14, 0x41, 0x64, 0x64, 0x42,
    0x6c, 0x6f, 0x63, 0x6b, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x12, 0x0a,
    0x0a, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28,
    0x09, 0x12, 0x31, 0x0a, 0x08, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x64, 0x65, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x12, 0x34, 0x0a, 0x0c, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x4e,
    0x6f, 0x64, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x68, 0x61, 0x64,
    0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64,
    0x65, 0x49, 0x6e, 0x66, 0x6f, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x11, 0x0a, 0x06, 0x66, 0x69,
    0x6c, 0x65, 0x49, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x3a, 0x01, 0x30, 0x12, 0x14, 0x0a,
    0x0c, 0x66, 0x61, 0x76, 0x6f, 0x72, 0x65, 0x64, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x18, 0x06, 0x20,
    0x03, 0x28, 0x09, 0x22, 0x46, 0x0a, 0x15, 0x41, 0x64, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x52,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x2d, 0x0a, 0x05,
    0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x68, 0x61,
    0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x65,
    0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xa4, 0x02, 0x0a, 0x21,
    0x47, 0x65, 0x74, 0x41, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x44, 0x61, 0x74,
    0x61, 0x6e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x2c,
    0x0a, 0x03, 0x62, 0x6c, 0x6b, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x68, 0x61,
    0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x64,
    0x65, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x31, 0x0a, 0x09,
    0x65, 0x78, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32,
    0x1e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x44, 0x61,
    0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
    0x30, 0x0a, 0x08, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28,
    0x0b, 0x32, 0x1e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e,
    0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x1a, 0x0a, 0x12, 0x6e, 0x75, 0x6d, 0x41, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e,
    0x61, 0x6c, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x18, 0x05, 0x20, 0x02, 0x28, 0x0d, 0x12, 0x12, 0x0a,
    0x0a, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x02, 0x28,
    0x09, 0x12, 0x1c, 0x0a, 0x14, 0x65, 0x78, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x6f,
    0x72, 0x61, 0x67, 0x65, 0x55, 0x75, 0x69, 0x64, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x09, 0x12,
    0x11, 0x0a, 0x06, 0x66, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x3a,
    0x01, 0x30, 0x22, 0x53, 0x0a, 0x22, 0x47, 0x65, 0x74, 0x41, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f,
    0x6e, 0x61, 0x6c, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x2d, 0x0a, 0x05, 0x62, 0x6c, 0x6f, 0x63,
    0x6b, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70,
    0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x65, 0x64, 0x42, 0x6c, 0x6f,
    0x63, 0x6b, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x79, 0x0a, 0x14, 0x43, 0x6f, 0x6d, 0x70, 0x6c,
    0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
    0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a,
    0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09,
    0x12, 0x2d, 0x0a, 0x04, 0x6c, 0x61, 0x73, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x45, 0x78, 0x74,
    0x65, 0x6e, 0x64, 0x65, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
    0x11, 0x0a, 0x06, 0x66, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x3a,
    0x01, 0x30, 0x22, 0x27, 0x0a, 0x15, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x0a, 0x06, 0x72,
    0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x08, 0x22, 0x4d, 0x0a, 0x1b, 0x52,
    0x65, 0x70, 0x6f, 0x72, 0x74, 0x42, 0x61, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x52, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x2e, 0x0a, 0x06, 0x62, 0x6c,
    0x6f, 0x63, 0x6b, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x68, 0x61, 0x64,
    0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x65, 0x64,
    0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x1e, 0x0a, 0x1c, 0x52, 0x65,
    0x70, 0x6f, 0x72, 0x74, 0x42, 0x61, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x52, 0x65, 0x73,
    0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x2f, 0x0a, 0x12, 0x43, 0x6f,
    0x6e, 0x63, 0x61, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x12, 0x0b, 0x0a, 0x03, 0x74, 0x72, 0x67, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0c, 0x0a,
    0x04, 0x73, 0x72, 0x63, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x22, 0x15, 0x0a, 0x13, 0x43,
    0x6f, 0x6e, 0x63, 0x61, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x22, 0x4a, 0x0a, 0x14, 0x54, 0x72, 0x75, 0x6e, 0x63, 0x61, 0x74, 0x65, 0x52, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72,
    0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x6e, 0x65, 0x77, 0x4c, 0x65,
    0x6e, 0x67, 0x74, 0x68, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x02, 0x28, 0x09, 0x22, 0x27,
    0x0a, 0x15, 0x54, 0x72, 0x75, 0x6e, 0x63, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x0a, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c,
    0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x08, 0x22, 0x2e, 0x0a, 0x12, 0x52, 0x65, 0x6e, 0x61, 0x6d,
    0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x0a,
    0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0b, 0x0a, 0x03, 0x64, 0x73,
    0x74, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x22, 0x25, 0x0a, 0x13, 0x52, 0x65, 0x6e, 0x61, 0x6d,
    0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e,
    0x0a, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x08, 0x22, 0x46,
    0x0a, 0x13, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x32, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02,
    0x28, 0x09, 0x12, 0x0b, 0x0a, 0x03, 0x64, 0x73, 0x74, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x12,
    0x15, 0x0a, 0x0d, 0x6f, 0x76, 0x65, 0x72, 0x77, 0x72, 0x69, 0x74, 0x65, 0x44, 0x65, 0x73, 0x74,
    0x18, 0x03, 0x20, 0x02, 0x28, 0x08, 0x22, 0x16, 0x0a, 0x14, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65,
    0x32, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x34,
    0x0a, 0x12, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x09, 0x12, 0x11, 0x0a, 0x09, 0x72, 0x65, 0x63, 0x75, 0x72, 0x73, 0x69, 0x76, 0x65, 0x18, 0x02,
    0x20, 0x02, 0x28, 0x08, 0x22, 0x25, 0x0a, 0x13, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x0a, 0x06, 0x72,
    0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x08, 0x22, 0x67, 0x0a, 0x12, 0x4d,
    0x6b, 0x64, 0x69, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x2e,
    0x0a, 0x06, 0x6d, 0x61, 0x73, 0x6b, 0x65, 0x64, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x1e,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x46, 0x73, 0x50,
    0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14,
    0x0a, 0x0c, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x18, 0x03,
    0x20, 0x02, 0x28, 0x08, 0x22, 0x25, 0x0a, 0x13, 0x4d, 0x6b, 0x64, 0x69, 0x72, 0x73, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x0a, 0x06, 0x72,
    0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x08, 0x22, 0x4f, 0x0a, 0x16, 0x47,
    0x65, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02,
    0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x41, 0x66, 0x74, 0x65, 0x72,
    0x18, 0x02, 0x20, 0x02, 0x28, 0x0c, 0x12, 0x14, 0x0a, 0x0c, 0x6e, 0x65, 0x65, 0x64, 0x4c, 0x6f,
    0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x02, 0x28, 0x08, 0x22, 0x4e, 0x0a, 0x17,
    0x47, 0x65, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x33, 0x0a, 0x07, 0x64, 0x69, 0x72, 0x4c, 0x69,
    0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f,
    0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x79,
    0x4c, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x28, 0x0a, 0x26,
    0x47, 0x65, 0x74, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x74, 0x61, 0x62, 0x6c, 0x65,
    0x44, 0x69, 0x72, 0x4c, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x78, 0x0a, 0x27, 0x47, 0x65, 0x74, 0x53, 0x6e, 0x61,
    0x70, 0x73, 0x68, 0x6f, 0x74, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x69, 0x72, 0x4c, 0x69, 0x73,
    0x74, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x4d, 0x0a, 0x14, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x74, 0x61, 0x62,
    0x6c, 0x65, 0x44, 0x69, 0x72, 0x4c, 0x69, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x2f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x6e,
    0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63,
    0x74, 0x6f, 0x72, 0x79, 0x4c, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x22, 0x63, 0x0a, 0x21, 0x47, 0x65, 0x74, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x44,
    0x69, 0x66, 0x66, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f,
    0x74, 0x52, 0x6f, 0x6f, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x14, 0x0a, 0x0c, 0x66,
    0x72, 0x6f, 0x6d, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x18, 0x02, 0x20, 0x02, 0x28,
    0x09, 0x12, 0x12, 0x0a, 0x0a, 0x74, 0x6f, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x18,
    0x03, 0x20, 0x02, 0x28, 0x09, 0x22, 0x5e, 0x0a, 0x22, 0x47, 0x65, 0x74, 0x53, 0x6e, 0x61, 0x70,
    0x73, 0x68, 0x6f, 0x74, 0x44, 0x69, 0x66, 0x66, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x38, 0x0a, 0x0a, 0x64,
    0x69, 0x66, 0x66, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32,
    0x24, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x6e,
    0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x44, 0x69, 0x66, 0x66, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x2c, 0x0a, 0x16, 0x52, 0x65, 0x6e, 0x65, 0x77, 0x4c, 0x65,
    0x61, 0x73, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
    0x12, 0x0a, 0x0a, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x09, 0x22, 0x19, 0x0a, 0x17, 0x52, 0x65, 0x6e, 0x65, 0x77, 0x4c, 0x65, 0x61, 0x73,
    0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x3b,
    0x0a, 0x18, 0x52, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x4c, 0x65, 0x61, 0x73, 0x65, 0x52, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72,
    0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x22, 0x2b, 0x0a, 0x19, 0x52,
    0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x4c, 0x65, 0x61, 0x73, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x0a, 0x06, 0x72, 0x65, 0x73, 0x75,
    0x6c, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x08, 0x22, 0x19, 0x0a, 0x17, 0x47, 0x65, 0x74, 0x46,
    0x73, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x22, 0xb7, 0x01, 0x0a, 0x17, 0x47, 0x65, 0x74, 0x46, 0x73, 0x53, 0x74, 0x61,
    0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
    0x10, 0x0a, 0x08, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x04, 0x12, 0x0c, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x64, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04, 0x12,
    0x11, 0x0a, 0x09, 0x72, 0x65, 0x6d, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x18, 0x03, 0x20, 0x02,
    0x28, 0x04, 0x12, 0x18, 0x0a, 0x10, 0x75, 0x6e, 0x64, 0x65, 0x72, 0x5f, 0x72, 0x65, 0x70, 0x6c,
    0x69, 0x63, 0x61, 0x74, 0x65, 0x64, 0x18, 0x04, 0x20, 0x02, 0x28, 0x04, 0x12, 0x16, 0x0a, 0x0e,
    0x63, 0x6f, 0x72, 0x72, 0x75, 0x70, 0x74, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x18, 0x05,
    0x20, 0x02, 0x28, 0x04, 0x12, 0x16, 0x0a, 0x0e, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x5f,
    0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x18, 0x06, 0x20, 0x02, 0x28, 0x04, 0x12, 0x1f, 0x0a, 0x17,
    0x6d, 0x69, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x5f, 0x72, 0x65, 0x70, 0x6c, 0x5f, 0x6f, 0x6e, 0x65,
    0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x22, 0x53, 0x0a,
    0x1d, 0x47, 0x65, 0x74, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x70, 0x6f,
    0x72, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x32,
    0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x24, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x6e,
    0x6f, 0x64, 0x65, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x22, 0x4c, 0x0a, 0x1e, 0x47, 0x65, 0x74, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64,
    0x65, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x12, 0x2a, 0x0a, 0x02, 0x64, 0x69, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
    0x32, 0x1e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x44,
    0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x22, 0x5a, 0x0a, 0x24, 0x47, 0x65, 0x74, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x53,
    0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x32, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65,
    0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x24, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x70,
    0x6f, 0x72, 0x74, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x8b, 0x01, 0x0a,
    0x1a, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65,
    0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x34, 0x0a, 0x0c, 0x64,
    0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x0b, 0x32, 0x1e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e,
    0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x37, 0x0a, 0x0e, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x52, 0x65, 0x70, 0x6f,
    0x72, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x68, 0x61, 0x64, 0x6f,
    0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x52,
    0x65, 0x70, 0x6f, 0x72, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x70, 0x0a, 0x25, 0x47, 0x65,
    0x74, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65,
    0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x47, 0x0a, 0x16, 0x64, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x53,
    0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67,
    0x65, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x35, 0x0a, 0x21,
    0x47, 0x65, 0x74, 0x50, 0x72, 0x65, 0x66, 0x65, 0x72, 0x72, 0x65, 0x64, 0x42, 0x6c, 0x6f, 0x63,
    0x6b, 0x53, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x10, 0x0a, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x09, 0x22, 0x33, 0x0a, 0x22, 0x47, 0x65, 0x74, 0x50, 0x72, 0x65, 0x66, 0x65, 0x72,
    0x72, 0x65, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x53, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0d, 0x0a, 0x05, 0x62, 0x73, 0x69,
    0x7a, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x04, 0x22, 0x63, 0x0a, 0x17, 0x53, 0x65, 0x74, 0x53,
    0x61, 0x66, 0x65, 0x4d, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x30, 0x0a, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x0e, 0x32, 0x20, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x53, 0x61, 0x66, 0x65, 0x4d, 0x6f, 0x64, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x16, 0x0a, 0x07, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x65, 0x64,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x22, 0x2a, 0x0a,
    0x18, 0x53, 0x65, 0x74, 0x53, 0x61, 0x66, 0x65, 0x4d, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x0a, 0x06, 0x72, 0x65, 0x73,
    0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x08, 0x22, 0x1b, 0x0a, 0x19, 0x53, 0x61, 0x76,
    0x65, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x1c, 0x0a, 0x1a, 0x53, 0x61, 0x76, 0x65, 0x4e, 0x61,
    0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x22, 0x17, 0x0a, 0x15, 0x52, 0x6f, 0x6c, 0x6c, 0x45, 0x64, 0x69, 0x74,
    0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x30, 0x0a,
    0x16, 0x52, 0x6f, 0x6c, 0x6c, 0x45, 0x64, 0x69, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x16, 0x0a, 0x0e, 0x6e, 0x65, 0x77, 0x53, 0x65,
    0x67, 0x6d, 0x65, 0x6e, 0x74, 0x54, 0x78, 0x49, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x04, 0x22,
    0x2f, 0x0a, 0x20, 0x52, 0x65, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64,
    0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x61, 0x72, 0x67, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09,
    0x22, 0x33, 0x0a, 0x21, 0x52, 0x65, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x46, 0x61, 0x69, 0x6c, 0x65,
    0x64, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x0a, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x08, 0x22, 0x1a, 0x0a, 0x18, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68,
    0x4e, 0x6f, 0x64, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x22, 0x1b, 0x0a, 0x19, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x4e, 0x6f, 0x64, 0x65,
    0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x1d,
    0x0a, 0x1b, 0x46, 0x69, 0x6e, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64,
    0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x1e, 0x0a,
    0x1c, 0x46, 0x69, 0x6e, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x54, 0x0a,
    0x1a, 0x52, 0x6f, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x52,
    0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x36, 0x0a, 0x06, 0x61,
    0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x26, 0x2e, 0x68, 0x61,
    0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x6f, 0x6c, 0x6c, 0x69, 0x6e,
    0x67, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x22, 0x99, 0x01, 0x0a, 0x17, 0x52, 0x6f, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x55,
    0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
    0x36, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32,
    0x26, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x6f,
    0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x53, 0x74, 0x61, 0x74,
    0x75, 0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x11, 0x0a, 0x09, 0x73, 0x74, 0x61, 0x72, 0x74,
    0x54, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04, 0x12, 0x14, 0x0a, 0x0c, 0x66, 0x69,
    0x6e, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x54, 0x69, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x02, 0x28, 0x04,
    0x12, 0x1d, 0x0a, 0x15, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x52, 0x6f, 0x6c, 0x6c, 0x62,
    0x61, 0x63, 0x6b, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x18, 0x04, 0x20, 0x02, 0x28, 0x08, 0x22,
    0x5f, 0x0a, 0x1b, 0x52, 0x6f, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64,
    0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x40,
    0x0a, 0x12, 0x72, 0x6f, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65,
    0x49, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x68, 0x61, 0x64,
    0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x6f, 0x6c, 0x6c, 0x69, 0x6e, 0x67,
    0x55, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x22, 0x41, 0x0a, 0x21, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x6f, 0x72, 0x72, 0x75, 0x70, 0x74, 0x46,
    0x69, 0x6c, 0x65, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x09, 0x12, 0x0e, 0x0a, 0x06, 0x63, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x09, 0x22, 0x5a, 0x0a, 0x22, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x6f, 0x72, 0x72, 0x75,
    0x70, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x34, 0x0a, 0x07, 0x63, 0x6f, 0x72,
    0x72, 0x75, 0x70, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x68, 0x61, 0x64,
    0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x6f, 0x72, 0x72, 0x75, 0x70, 0x74,
    0x46, 0x69, 0x6c, 0x65, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22,
    0x28, 0x0a, 0x14, 0x4d, 0x65, 0x74, 0x61, 0x53, 0x61, 0x76, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x10, 0x0a, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x6e,
    0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x17, 0x0a, 0x15, 0x4d, 0x65, 0x74,
    0x61, 0x53, 0x61, 0x76, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x22, 0x26, 0x0a, 0x17, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x6e, 0x66,
    0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x0a,
    0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x48, 0x0a, 0x18, 0x47, 0x65,
    0x74, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x2c, 0x0a, 0x02, 0x66, 0x73, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x20, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x48, 0x64, 0x66, 0x73, 0x46, 0x69, 0x6c, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x22, 0x27, 0x0a, 0x18, 0x49, 0x73, 0x46, 0x69, 0x6c, 0x65, 0x43, 0x6c,
    0x6f, 0x73, 0x65, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x2b, 0x0a,
    0x19, 0x49, 0x73, 0x46, 0x69, 0x6c, 0x65, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x64, 0x52, 0x65, 0x73,
    0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x0a, 0x06, 0x72, 0x65,
    0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x08, 0x22, 0x9a, 0x01, 0x0a, 0x17, 0x43,
    0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x49, 0x6e, 0x66,
    0x6f, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x03, 0x12, 0x0c, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
    0x12, 0x13, 0x0a, 0x0b, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0c, 0x0a, 0x04, 0x70, 0x6f, 0x6f, 0x6c, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x42, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70,
    0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63,
    0x74, 0x69, 0x76, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x45, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x47, 0x0a, 0x21, 0x43, 0x61, 0x63, 0x68, 0x65,
    0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x45, 0x78, 0x70,
    0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x0a, 0x06,
    0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x73, 0x18, 0x01, 0x20, 0x02, 0x28, 0x03, 0x12, 0x12, 0x0a, 0x0a,
    0x69, 0x73, 0x52, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x08,
    0x22, 0x82, 0x01, 0x0a, 0x18, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74,
    0x69, 0x76, 0x65, 0x53, 0x74, 0x61, 0x74, 0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x13, 0x0a,
    0x0b, 0x62, 0x79, 0x74, 0x65, 0x73, 0x4e, 0x65, 0x65, 0x64, 0x65, 0x64, 0x18, 0x01, 0x20, 0x02,
    0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x62, 0x79, 0x74, 0x65, 0x73, 0x43, 0x61, 0x63, 0x68, 0x65,
    0x64, 0x18, 0x02, 0x20, 0x02, 0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x66, 0x69, 0x6c, 0x65, 0x73,
    0x4e, 0x65, 0x65, 0x64, 0x65, 0x64, 0x18, 0x03, 0x20, 0x02, 0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b,
    0x66, 0x69, 0x6c, 0x65, 0x73, 0x43, 0x61, 0x63, 0x68, 0x65, 0x64, 0x18, 0x04, 0x20, 0x02, 0x28,
    0x03, 0x12, 0x12, 0x0a, 0x0a, 0x68, 0x61, 0x73, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x64, 0x18,
    0x05, 0x20, 0x02, 0x28, 0x08, 0x22, 0x67, 0x0a, 0x1d, 0x41, 0x64, 0x64, 0x43, 0x61, 0x63, 0x68,
    0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x32, 0x0a, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x01,
    0x20, 0x02, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76,
    0x65, 0x49, 0x6e, 0x66, 0x6f, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x61,
    0x63, 0x68, 0x65, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x2c,
    0x0a, 0x1e, 0x41, 0x64, 0x64, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74,
    0x69, 0x76, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x12, 0x0a, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x03, 0x22, 0x6a, 0x0a, 0x20,
    0x4d, 0x6f, 0x64, 0x69, 0x66, 0x79, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63,
    0x74, 0x69, 0x76, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x12, 0x32, 0x0a, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x24,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x61, 0x63,
    0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x61, 0x63, 0x68, 0x65, 0x46, 0x6c, 0x61,
    0x67, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x23, 0x0a, 0x21, 0x4d, 0x6f, 0x64, 0x69,
    0x66, 0x79, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x2e, 0x0a,
    0x20, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65,
    0x63, 0x74, 0x69, 0x76, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x0a, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x03, 0x22, 0x23, 0x0a,
    0x21, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65,
    0x63, 0x74, 0x69, 0x76, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x22, 0x67, 0x0a, 0x1f, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44,
    0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x76, 0x49, 0x64, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x03, 0x12, 0x34, 0x0a, 0x06, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x18,
    0x02, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68,
    0x64, 0x66, 0x73, 0x2e, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69,
    0x76, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x84, 0x01, 0x0a, 0x18,
    0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x45, 0x6e,
    0x74, 0x72, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x32, 0x0a, 0x04, 0x69, 0x6e, 0x66, 0x6f,
    0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74,
    0x69, 0x76, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x34, 0x0a, 0x05,
    0x73, 0x74, 0x61, 0x74, 0x73, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x68, 0x61,
    0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44,
    0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x53, 0x74, 0x61, 0x74, 0x73, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x22, 0x6c, 0x0a, 0x20, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44,
    0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x37, 0x0a, 0x08, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e,
    0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f,
    0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65,
    0x63, 0x74, 0x69, 0x76, 0x65, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
    0x0f, 0x0a, 0x07, 0x68, 0x61, 0x73, 0x4d, 0x6f, 0x72, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x08,
    0x22, 0x84, 0x01, 0x0a, 0x12, 0x43, 0x61, 0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x49, 0x6e,
    0x66, 0x6f, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x10, 0x0a, 0x08, 0x70, 0x6f, 0x6f, 0x6c, 0x4e,
    0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x6f, 0x77, 0x6e,
    0x65, 0x72, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09,
    0x67, 0x72, 0x6f, 0x75, 0x70, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x12,
    0x0c, 0x0a, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0d, 0x0a,
    0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x12, 0x19, 0x0a, 0x11,
    0x6d, 0x61, 0x78, 0x52, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x45, 0x78, 0x70, 0x69, 0x72,
    0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x03, 0x22, 0x81, 0x01, 0x0a, 0x13, 0x43, 0x61, 0x63, 0x68,
    0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
    0x13, 0x0a, 0x0b, 0x62, 0x79, 0x74, 0x65, 0x73, 0x4e, 0x65, 0x65, 0x64, 0x65, 0x64, 0x18, 0x01,
    0x20, 0x02, 0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x62, 0x79, 0x74, 0x65, 0x73, 0x43, 0x61, 0x63,
    0x68, 0x65, 0x64, 0x18, 0x02, 0x20, 0x02, 0x28, 0x03, 0x12, 0x16, 0x0a, 0x0e, 0x62, 0x79, 0x74,
    0x65, 0x73, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x03, 0x20, 0x02, 0x28,
    0x03, 0x12, 0x13, 0x0a, 0x0b, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x4e, 0x65, 0x65, 0x64, 0x65, 0x64,
    0x18, 0x04, 0x20, 0x02, 0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x43,
    0x61, 0x63, 0x68, 0x65, 0x64, 0x18, 0x05, 0x20, 0x02, 0x28, 0x03, 0x22, 0x49, 0x0a, 0x18, 0x41,
    0x64, 0x64, 0x43, 0x61, 0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x2d, 0x0a, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68,
    0x64, 0x66, 0x73, 0x2e, 0x43, 0x61, 0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x49, 0x6e, 0x66,
    0x6f, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x1b, 0x0a, 0x19, 0x41, 0x64, 0x64, 0x43, 0x61, 0x63,
    0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x22, 0x4c, 0x0a, 0x1b, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x79, 0x43, 0x61, 0x63,
    0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x12, 0x2d, 0x0a, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b,
    0x32, 0x1f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43,
    0x61, 0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x22, 0x1e, 0x0a, 0x1c, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x79, 0x43, 0x61, 0x63, 0x68, 0x65,
    0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x22, 0x2f, 0x0a, 0x1b, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x61, 0x63, 0x68, 0x65,
    0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x12, 0x10, 0x0a, 0x08, 0x70, 0x6f, 0x6f, 0x6c, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x02,
    0x28, 0x09, 0x22, 0x1e, 0x0a, 0x1c, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x61, 0x63, 0x68,
    0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x22, 0x32, 0x0a, 0x1a, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x61, 0x63, 0x68, 0x65, 0x50,
    0x6f, 0x6f, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x12, 0x14, 0x0a, 0x0c, 0x70, 0x72, 0x65, 0x76, 0x50, 0x6f, 0x6f, 0x6c, 0x4e, 0x61, 0x6d, 0x65,
    0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x61, 0x0a, 0x1b, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x61,
    0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x31, 0x0a, 0x07, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73,
    0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x61, 0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x45, 0x6e,
    0x74, 0x72, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0f, 0x0a, 0x07, 0x68, 0x61, 0x73, 0x4d,
    0x6f, 0x72, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x08, 0x22, 0x75, 0x0a, 0x13, 0x43, 0x61, 0x63,
    0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x12, 0x2d, 0x0a, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x1f,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x61, 0x63,
    0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
    0x2f, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x74, 0x73, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x20,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x61, 0x63,
    0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x22, 0x2a, 0x0a, 0x1b, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x4c, 0x69, 0x6e, 0x6b, 0x49,
    0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
    0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x4c, 0x0a, 0x1c,
    0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x4c, 0x69, 0x6e, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x52,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x2c, 0x0a, 0x02,
    0x66, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f,
    0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x48, 0x64, 0x66, 0x73, 0x46, 0x69, 0x6c, 0x65, 0x53,
    0x74, 0x61, 0x74, 0x75, 0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x2d, 0x0a, 0x1d, 0x47, 0x65,
    0x74, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52,
    0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x0a, 0x04, 0x70,
    0x61, 0x74, 0x68, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x53, 0x0a, 0x1e, 0x47, 0x65, 0x74,
    0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x31, 0x0a, 0x07, 0x73,
    0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x65,
    0x6e, 0x74, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x8b,
    0x01, 0x0a, 0x14, 0x53, 0x65, 0x74, 0x51, 0x75, 0x6f, 0x74, 0x61, 0x52, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x16, 0x0a, 0x0e, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61,
    0x63, 0x65, 0x51, 0x75, 0x6f, 0x74, 0x61, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04, 0x12, 0x19, 0x0a,
    0x11, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x51, 0x75, 0x6f,
    0x74, 0x61, 0x18, 0x03, 0x20, 0x02, 0x28, 0x04, 0x12, 0x32, 0x0a, 0x0b, 0x73, 0x74, 0x6f, 0x72,
    0x61, 0x67, 0x65, 0x54, 0x79, 0x70, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1d, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x74, 0x6f, 0x72,
    0x61, 0x67, 0x65, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x17, 0x0a, 0x15,
    0x53, 0x65, 0x74, 0x51, 0x75, 0x6f, 0x74, 0x61, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x60, 0x0a, 0x11, 0x46, 0x73, 0x79, 0x6e, 0x63, 0x52, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72,
    0x63, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0e, 0x0a, 0x06, 0x63, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x12, 0x1b, 0x0a, 0x0f, 0x6c, 0x61, 0x73, 0x74, 0x42,
    0x6c, 0x6f, 0x63, 0x6b, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x12,
    0x3a, 0x02, 0x2d, 0x31, 0x12, 0x11, 0x0a, 0x06, 0x66, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x04, 0x3a, 0x01, 0x30, 0x22, 0x14, 0x0a, 0x12, 0x46, 0x73, 0x79, 0x6e, 0x63,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x41, 0x0a,
    0x14, 0x53, 0x65, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x72, 0x63, 0x18, 0x01, 0x20, 0x02,
    0x28, 0x09, 0x12, 0x0d, 0x0a, 0x05, 0x6d, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28,
    0x04, 0x12, 0x0d, 0x0a, 0x05, 0x61, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x02, 0x28, 0x04,
    0x22, 0x17, 0x0a, 0x15, 0x53, 0x65, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x80, 0x01, 0x0a, 0x19, 0x43, 0x72,
    0x65, 0x61, 0x74, 0x65, 0x53, 0x79, 0x6d, 0x6c, 0x69, 0x6e, 0x6b, 0x52, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x0a, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65,
    0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0c, 0x0a, 0x04, 0x6c, 0x69, 0x6e, 0x6b, 0x18,
    0x02, 0x20, 0x02, 0x28, 0x09, 0x12, 0x2f, 0x0a, 0x07, 0x64, 0x69, 0x72, 0x50, 0x65, 0x72, 0x6d,
    0x18, 0x03, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x46, 0x73, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f,
    0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x0a, 0x0c, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
    0x50, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x02, 0x28, 0x08, 0x22, 0x1c, 0x0a, 0x1a,
    0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x79, 0x6d, 0x6c, 0x69, 0x6e, 0x6b, 0x52, 0x65, 0x73,
    0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x29, 0x0a, 0x19, 0x47, 0x65,
    0x74, 0x4c, 0x69, 0x6e, 0x6b, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x30, 0x0a, 0x1a, 0x47, 0x65, 0x74, 0x4c, 0x69, 0x6e, 0x6b,
    0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a, 0x0a, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x50, 0x61, 0x74,
    0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x22, 0x68, 0x0a, 0x22, 0x55, 0x70, 0x64, 0x61, 0x74,
    0x65, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x46, 0x6f, 0x72, 0x50, 0x69, 0x70, 0x65, 0x6c, 0x69, 0x6e,
    0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x2e, 0x0a,
    0x05, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e,
    0x64, 0x65, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a,
    0x0a, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28,
    0x09, 0x22, 0x54, 0x0a, 0x23, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x42, 0x6c, 0x6f, 0x63, 0x6b,
    0x46, 0x6f, 0x72, 0x50, 0x69, 0x70, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x2d, 0x0a, 0x05, 0x62, 0x6c, 0x6f, 0x63,
    0x6b, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70,
    0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x65, 0x64, 0x42, 0x6c, 0x6f,
    0x63, 0x6b, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xda, 0x01, 0x0a, 0x1a, 0x55, 0x70, 0x64, 0x61,
    0x74, 0x65, 0x50, 0x69, 0x70, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x31, 0x0a, 0x08, 0x6f, 0x6c,
    0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e,
    0x64, 0x65, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x31, 0x0a,
    0x08, 0x6e, 0x65, 0x77, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x18, 0x03, 0x20, 0x02, 0x28, 0x0b, 0x32,
    0x1f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x45, 0x78,
    0x74, 0x65, 0x6e, 0x64, 0x65, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x12, 0x2e, 0x0a, 0x08, 0x6e, 0x65, 0x77, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03,
    0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x44, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x12, 0x12, 0x0a, 0x0a, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x44, 0x73, 0x18, 0x05,
    0x20, 0x03, 0x28, 0x09, 0x22, 0x1d, 0x0a, 0x1b, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x69,
    0x70, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x22, 0x35, 0x0a, 0x20, 0x53, 0x65, 0x74, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63,
    0x65, 0x72, 0x42, 0x61, 0x6e, 0x64, 0x77, 0x69, 0x64, 0x74, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x11, 0x0a, 0x09, 0x62, 0x61, 0x6e, 0x64, 0x77,
    0x69, 0x64, 0x74, 0x68, 0x18, 0x01, 0x20, 0x02, 0x28, 0x03, 0x22, 0x23, 0x0a, 0x21, 0x53, 0x65,
    0x74, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x72, 0x42, 0x61, 0x6e, 0x64, 0x77, 0x69, 0x64,
    0x74, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22,
    0x22, 0x0a, 0x20, 0x47, 0x65, 0x74, 0x44, 0x61, 0x74, 0x61, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70,
    0x74, 0x69, 0x6f, 0x6e, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x22, 0x63, 0x0a, 0x21, 0x47, 0x65, 0x74, 0x44, 0x61, 0x74, 0x61, 0x45, 0x6e,
    0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x3e, 0x0a, 0x11, 0x64, 0x61, 0x74, 0x61,
    0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x4b, 0x65, 0x79, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e,
    0x4b, 0x65, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x48, 0x0a, 0x1a, 0x43, 0x72, 0x65, 0x61,
    0x74, 0x65, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68,
    0x6f, 0x74, 0x52, 0x6f, 0x6f, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x14, 0x0a, 0x0c,
    0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x09, 0x22, 0x33, 0x0a, 0x1b, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x6e, 0x61, 0x70,
    0x73, 0x68, 0x6f, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x50, 0x61, 0x74,
    0x68, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x64, 0x0a, 0x1a, 0x52, 0x65, 0x6e, 0x61, 0x6d,
    0x65, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f,
    0x74, 0x52, 0x6f, 0x6f, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x17, 0x0a, 0x0f, 0x73,
    0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x4f, 0x6c, 0x64, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02,
    0x20, 0x02, 0x28, 0x09, 0x12, 0x17, 0x0a, 0x0f, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74,
    0x4e, 0x65, 0x77, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x02, 0x28, 0x09, 0x22, 0x1d, 0x0a,
    0x1b, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x52,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x31, 0x0a, 0x19,
    0x41, 0x6c, 0x6c, 0x6f, 0x77, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x52, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x6e, 0x61,
    0x70, 0x73, 0x68, 0x6f, 0x74, 0x52, 0x6f, 0x6f, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22,
    0x1c, 0x0a, 0x1a, 0x41, 0x6c, 0x6c, 0x6f, 0x77, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x34, 0x0a,
    0x1c, 0x44, 0x69, 0x73, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f,
    0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x0a,
    0x0c, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x52, 0x6f, 0x6f, 0x74, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x09, 0x22, 0x1f, 0x0a, 0x1d, 0x44, 0x69, 0x73, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x53,
    0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x22, 0x48, 0x0a, 0x1a, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x53, 0x6e,
    0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x52, 0x6f,
    0x6f, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x6e, 0x61, 0x70,
    0x73, 0x68, 0x6f, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x22, 0x1d,
    0x0a, 0x1b, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x5f, 0x0a,
    0x17, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x52, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68,
    0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x36, 0x0a, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x02,
    0x20, 0x02, 0x28, 0x0e, 0x32, 0x28, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x41, 0x63, 0x6c, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x2e, 0x46, 0x73, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x1a,
    0x0a, 0x18, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x52, 0x65, 0x73,
    0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x23, 0x0a, 0x21, 0x47, 0x65,
    0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x45, 0x64, 0x69, 0x74, 0x4c, 0x6f, 0x67, 0x54,
    0x78, 0x69, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22,
    0x32, 0x0a, 0x22, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x45, 0x64, 0x69,
    0x74, 0x4c, 0x6f, 0x67, 0x54, 0x78, 0x69, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x78, 0x69, 0x64, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x03, 0x22, 0x2c, 0x0a, 0x1c, 0x47, 0x65, 0x74, 0x45, 0x64, 0x69, 0x74, 0x73, 0x46,
    0x72, 0x6f, 0x6d, 0x54, 0x78, 0x69, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x78, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x03, 0x22, 0x51, 0x0a, 0x1d, 0x47, 0x65, 0x74, 0x45, 0x64, 0x69, 0x74, 0x73, 0x46, 0x72, 0x6f,
    0x6d, 0x54, 0x78, 0x69, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x12, 0x30, 0x0a, 0x0a, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x4c, 0x69, 0x73, 0x74,
    0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x4c, 0x69, 0x73, 0x74, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x2a, 0x59, 0x0a, 0x0f, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x46, 0x6c,
    0x61, 0x67, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x0a, 0x06, 0x43, 0x52, 0x45, 0x41, 0x54,
    0x45, 0x10, 0x01, 0x12, 0x0d, 0x0a, 0x09, 0x4f, 0x56, 0x45, 0x52, 0x57, 0x52, 0x49, 0x54, 0x45,
    0x10, 0x02, 0x12, 0x0a, 0x0a, 0x06, 0x41, 0x50, 0x50, 0x45, 0x4e, 0x44, 0x10, 0x04, 0x12, 0x10,
    0x0a, 0x0c, 0x4c, 0x41, 0x5a, 0x59, 0x5f, 0x50, 0x45, 0x52, 0x53, 0x49, 0x53, 0x54, 0x10, 0x10,
    0x12, 0x0d, 0x0a, 0x09, 0x4e, 0x45, 0x57, 0x5f, 0x42, 0x4c, 0x4f, 0x43, 0x4b, 0x10, 0x20, 0x2a,
    0x4b, 0x0a, 0x17, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x70, 0x6f, 0x72,
    0x74, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x07, 0x0a, 0x03, 0x41, 0x4c,
    0x4c, 0x10, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x4c, 0x49, 0x56, 0x45, 0x10, 0x02, 0x12, 0x08, 0x0a,
    0x04, 0x44, 0x45, 0x41, 0x44, 0x10, 0x03, 0x12, 0x13, 0x0a, 0x0f, 0x44, 0x45, 0x43, 0x4f, 0x4d,
    0x4d, 0x49, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x49, 0x4e, 0x47, 0x10, 0x04, 0x2a, 0x4f, 0x0a, 0x13,
    0x53, 0x61, 0x66, 0x65, 0x4d, 0x6f, 0x64, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a, 0x0e, 0x53, 0x41, 0x46, 0x45, 0x4d, 0x4f, 0x44, 0x45, 0x5f,
    0x4c, 0x45, 0x41, 0x56, 0x45, 0x10, 0x01, 0x12, 0x12, 0x0a, 0x0e, 0x53, 0x41, 0x46, 0x45, 0x4d,
    0x4f, 0x44, 0x45, 0x5f, 0x45, 0x4e, 0x54, 0x45, 0x52, 0x10, 0x02, 0x12, 0x10, 0x0a, 0x0c, 0x53,
    0x41, 0x46, 0x45, 0x4d, 0x4f, 0x44, 0x45, 0x5f, 0x47, 0x45, 0x54, 0x10, 0x03, 0x2a, 0x3f, 0x0a,
    0x19, 0x52, 0x6f, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x41,
    0x63, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x09, 0x0a, 0x05, 0x51, 0x55,
    0x45, 0x52, 0x59, 0x10, 0x01, 0x12, 0x09, 0x0a, 0x05, 0x53, 0x54, 0x41, 0x52, 0x54, 0x10, 0x02,
    0x12, 0x0c, 0x0a, 0x08, 0x46, 0x49, 0x4e, 0x41, 0x4c, 0x49, 0x5a, 0x45, 0x10, 0x03, 0x2a, 0x1b,
    0x0a, 0x0e, 0x43, 0x61, 0x63, 0x68, 0x65, 0x46, 0x6c, 0x61, 0x67, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x12, 0x09, 0x0a, 0x05, 0x46, 0x4f, 0x52, 0x43, 0x45, 0x10, 0x01, 0x32, 0xb0, 0x41, 0x0a, 0x16,
    0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x6e, 0x6f, 0x64, 0x65, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x6c, 0x0a, 0x11, 0x67, 0x65, 0x74, 0x42, 0x6c, 0x6f,
    0x63, 0x6b, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x2a, 0x2e, 0x68, 0x61,
    0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x42, 0x6c, 0x6f,
    0x63, 0x6b, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2b, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70,
    0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x4c, 0x6f,
    0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x12, 0x6c, 0x0a, 0x11, 0x67, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65,
    0x72, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x12, 0x2a, 0x2e, 0x68, 0x61, 0x64, 0x6f,
    0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65,
    0x72, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2b, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68,
    0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x44, 0x65, 0x66,
    0x61, 0x75, 0x6c, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x12, 0x4b, 0x0a, 0x06, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x12, 0x1f, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74,
    0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x20, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x72, 0x65, 0x61,
    0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
    0x4b, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x12, 0x1f, 0x2e, 0x68, 0x61, 0x64, 0x6f,
    0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x41, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x52, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x20, 0x2e, 0x68, 0x61, 0x64,
    0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x41, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x52,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x63, 0x0a, 0x0e,
    0x73, 0x65, 0x74, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x27,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x65, 0x74,
    0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x28, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70,
    0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x65, 0x74, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x69, 0x0a, 0x10, 0x73, 0x65, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x50,
    0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x29, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68,
    0x64, 0x66, 0x73, 0x2e, 0x53, 0x65, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x50, 0x6f,
    0x6c, 0x69, 0x63, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x1a, 0x2a, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53,
    0x65, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x6f, 0x0a, 0x12,
    0x67, 0x65, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x69,
    0x65, 0x73, 0x12, 0x2b, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x47, 0x65, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63,
    0x69, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a,
    0x2c, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65,
    0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x60, 0x0a,
    0x0d, 0x73, 0x65, 0x74, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x26,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x65, 0x74,
    0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x27, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x65, 0x74, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69,
    0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
    0x51, 0x0a, 0x08, 0x73, 0x65, 0x74, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x21, 0x2e, 0x68, 0x61,
    0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x65, 0x74, 0x4f, 0x77, 0x6e,
    0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x22,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x65, 0x74,
    0x4f, 0x77, 0x6e, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x12, 0x5d, 0x0a, 0x0c, 0x61, 0x62, 0x61, 0x6e, 0x64, 0x6f, 0x6e, 0x42, 0x6c, 0x6f,
    0x63, 0x6b, 0x12, 0x25, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x41, 0x62, 0x61, 0x6e, 0x64, 0x6f, 0x6e, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x52, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x26, 0x2e, 0x68, 0x61, 0x64, 0x6f,
    0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x41, 0x62, 0x61, 0x6e, 0x64, 0x6f, 0x6e, 0x42,
    0x6c, 0x6f, 0x63, 0x6b, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x51, 0x0a, 0x08, 0x61, 0x64, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x12, 0x21, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x42,
    0x6c, 0x6f, 0x63, 0x6b, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x1a, 0x22, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x41,
    0x64, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x12, 0x78, 0x0a, 0x15, 0x67, 0x65, 0x74, 0x41, 0x64, 0x64, 0x69, 0x74,
    0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x12, 0x2e, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x41,
    0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64,
    0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2f, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x41,
    0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64,
    0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x51,
    0x0a, 0x08, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x12, 0x21, 0x2e, 0x68, 0x61, 0x64,
    0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74,
    0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x22, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x6f, 0x6d, 0x70,
    0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x66, 0x0a, 0x0f, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x42, 0x61, 0x64, 0x42, 0x6c,
    0x6f, 0x63, 0x6b, 0x73, 0x12, 0x28, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x42, 0x61, 0x64, 0x42, 0x6c, 0x6f, 0x63,
    0x6b, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x29,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x65, 0x70,
    0x6f, 0x72, 0x74, 0x42, 0x61, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x4b, 0x0a, 0x06, 0x63, 0x6f, 0x6e,
    0x63, 0x61, 0x74, 0x12, 0x1f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x43, 0x6f, 0x6e, 0x63, 0x61, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x20, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x43, 0x6f, 0x6e, 0x63, 0x61, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x51, 0x0a, 0x08, 0x74, 0x72, 0x75, 0x6e, 0x63, 0x61,
    0x74, 0x65, 0x12, 0x21, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x54, 0x72, 0x75, 0x6e, 0x63, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x22, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68,
    0x64, 0x66, 0x73, 0x2e, 0x54, 0x72, 0x75, 0x6e, 0x63, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x4b, 0x0a, 0x06, 0x72, 0x65, 0x6e,
    0x61, 0x6d, 0x65, 0x12, 0x1f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x20, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x4e, 0x0a, 0x07, 0x72, 0x65, 0x6e, 0x61, 0x6d, 0x65,
    0x32, 0x12, 0x20, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e,
    0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x32, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x1a, 0x21, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x32, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x4b, 0x0a, 0x06, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65,
    0x12, 0x1f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x44,
    0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x1a, 0x20, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e,
    0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x4b, 0x0a, 0x06, 0x6d, 0x6b, 0x64, 0x69, 0x72, 0x73, 0x12, 0x1f, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4d, 0x6b, 0x64, 0x69,
    0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x20,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4d, 0x6b, 0x64,
    0x69, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x12, 0x57, 0x0a, 0x0a, 0x67, 0x65, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x12, 0x23,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74,
    0x4c, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x1a, 0x24, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x47, 0x65, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x57, 0x0a, 0x0a, 0x72, 0x65, 0x6e,
    0x65, 0x77, 0x4c, 0x65, 0x61, 0x73, 0x65, 0x12, 0x23, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70,
    0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x65, 0x6e, 0x65, 0x77, 0x4c, 0x65, 0x61, 0x73, 0x65,
    0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x24, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x65, 0x6e, 0x65, 0x77,
    0x4c, 0x65, 0x61, 0x73, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x12, 0x5d, 0x0a, 0x0c, 0x72, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x4c, 0x65, 0x61,
    0x73, 0x65, 0x12, 0x25, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x52, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x4c, 0x65, 0x61, 0x73, 0x65, 0x52, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x26, 0x2e, 0x68, 0x61, 0x64, 0x6f,
    0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x4c,
    0x65, 0x61, 0x73, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x58, 0x0a, 0x0a, 0x67, 0x65, 0x74, 0x46, 0x73, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12,
    0x24, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65,
    0x74, 0x46, 0x73, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x24, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68,
    0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x46, 0x73, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x6c, 0x0a, 0x11, 0x67,
    0x65, 0x74, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74,
    0x12, 0x2a, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47,
    0x65, 0x74, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74,
    0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2b, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x44, 0x61,
    0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x81, 0x01, 0x0a, 0x18, 0x67, 0x65,
    0x74, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65,
    0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x31, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x44, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65,
    0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x32, 0x2e, 0x68, 0x61, 0x64, 0x6f,
    0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x44, 0x61, 0x74, 0x61, 0x6e,
    0x6f, 0x64, 0x65, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x78, 0x0a,
    0x15, 0x67, 0x65, 0x74, 0x50, 0x72, 0x65, 0x66, 0x65, 0x72, 0x72, 0x65, 0x64, 0x42, 0x6c, 0x6f,
    0x63, 0x6b, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x2e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x50, 0x72, 0x65, 0x66, 0x65, 0x72, 0x72, 0x65,
    0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x53, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x50, 0x72, 0x65, 0x66, 0x65, 0x72, 0x72, 0x65,
    0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x53, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x5a, 0x0a, 0x0b, 0x73, 0x65, 0x74, 0x53, 0x61,
    0x66, 0x65, 0x4d, 0x6f, 0x64, 0x65, 0x12, 0x24, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x65, 0x74, 0x53, 0x61, 0x66, 0x65, 0x4d, 0x6f, 0x64, 0x65,
    0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x25, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x65, 0x74, 0x53, 0x61,
    0x66, 0x65, 0x4d, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x60, 0x0a, 0x0d, 0x73, 0x61, 0x76, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x73,
    0x70, 0x61, 0x63, 0x65, 0x12, 0x26, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x53, 0x61, 0x76, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65,
    0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x27, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x61, 0x76, 0x65, 0x4e,
    0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x54, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x45, 0x64, 0x69,
    0x74, 0x73, 0x12, 0x22, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x52, 0x6f, 0x6c, 0x6c, 0x45, 0x64, 0x69, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x23, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x6f, 0x6c, 0x6c, 0x45, 0x64, 0x69, 0x74, 0x73, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x75, 0x0a, 0x14, 0x72,
    0x65, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x53, 0x74, 0x6f, 0x72,
    0x61, 0x67, 0x65, 0x12, 0x2d, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x52, 0x65, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x53,
    0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x1a, 0x2e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x52, 0x65, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x53, 0x74,
    0x6f, 0x72, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x12, 0x5d, 0x0a, 0x0c, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x4e, 0x6f, 0x64,
    0x65, 0x73, 0x12, 0x25, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x52, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x26, 0x2e, 0x68, 0x61, 0x64, 0x6f,
    0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x4e,
    0x6f, 0x64, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x66, 0x0a, 0x0f, 0x66, 0x69, 0x6e, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x55, 0x70, 0x67,
    0x72, 0x61, 0x64, 0x65, 0x12, 0x28, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x46, 0x69, 0x6e, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x55, 0x70, 0x67, 0x72, 0x61,
    0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x29,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x46, 0x69, 0x6e,
    0x61, 0x6c, 0x69, 0x7a, 0x65, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x63, 0x0a, 0x0e, 0x72, 0x6f, 0x6c,
    0x6c, 0x69, 0x6e, 0x67, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x12, 0x27, 0x2e, 0x68, 0x61,
    0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x6f, 0x6c, 0x6c, 0x69, 0x6e,
    0x67, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x28, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x52, 0x6f, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64,
    0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x78,
    0x0a, 0x15, 0x6c, 0x69, 0x73, 0x74, 0x43, 0x6f, 0x72, 0x72, 0x75, 0x70, 0x74, 0x46, 0x69, 0x6c,
    0x65, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x12, 0x2e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70,
    0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x6f, 0x72, 0x72, 0x75, 0x70,
    0x74, 0x46, 0x69, 0x6c, 0x65, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70,
    0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x6f, 0x72, 0x72, 0x75, 0x70,
    0x74, 0x46, 0x69, 0x6c, 0x65, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x51, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61,
    0x53, 0x61, 0x76, 0x65, 0x12, 0x21, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x4d, 0x65, 0x74, 0x61, 0x53, 0x61, 0x76, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x22, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70,
    0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4d, 0x65, 0x74, 0x61, 0x53, 0x61, 0x76, 0x65, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x5a, 0x0a, 0x0b, 0x67,
    0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x24, 0x2e, 0x68, 0x61, 0x64,
    0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65,
    0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x1a, 0x25, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47,
    0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x6c, 0x0a, 0x11, 0x61, 0x64, 0x64, 0x43, 0x61,
    0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x2a, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x43, 0x61,
    0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x52, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2b, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f,
    0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44,
    0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x75, 0x0a, 0x14, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x79, 0x43,
    0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x2d, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4d, 0x6f, 0x64, 0x69,
    0x66, 0x79, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65,
    0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2e, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4d, 0x6f, 0x64, 0x69, 0x66,
    0x79, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x52,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x75, 0x0a, 0x14,
    0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63,
    0x74, 0x69, 0x76, 0x65, 0x12, 0x2d, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69,
    0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x1a, 0x2e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x69, 0x72,
    0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x72, 0x0a, 0x13, 0x6c, 0x69, 0x73, 0x74, 0x43, 0x61, 0x63, 0x68, 0x65,
    0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x73, 0x12, 0x2c, 0x2e, 0x68, 0x61, 0x64,
    0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x61, 0x63,
    0x68, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2d, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f,
    0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x61, 0x63, 0x68, 0x65,
    0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x5d, 0x0a, 0x0c, 0x61, 0x64, 0x64, 0x43, 0x61,
    0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x12, 0x25, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70,
    0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x43, 0x61, 0x63, 0x68, 0x65, 0x50, 0x6f,
    0x6f, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x26,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x41, 0x64, 0x64,
    0x43, 0x61, 0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x66, 0x0a, 0x0f, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x79,
    0x43, 0x61, 0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x12, 0x28, 0x2e, 0x68, 0x61, 0x64, 0x6f,
    0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x79, 0x43, 0x61,
    0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x1a, 0x29, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x79, 0x43, 0x61, 0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f,
    0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x66,
    0x0a, 0x0f, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x61, 0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f,
    0x6c, 0x12, 0x28, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e,
    0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x61, 0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x52,
    0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x29, 0x2e, 0x68, 0x61,
    0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65,
    0x43, 0x61, 0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x63, 0x0a, 0x0e, 0x6c, 0x69, 0x73, 0x74, 0x43, 0x61,
    0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x73, 0x12, 0x27, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f,
    0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x61, 0x63, 0x68, 0x65,
    0x50, 0x6f, 0x6f, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x1a, 0x28, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e,
    0x4c, 0x69, 0x73, 0x74, 0x43, 0x61, 0x63, 0x68, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x73, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x66, 0x0a, 0x0f, 0x67,
    0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x4c, 0x69, 0x6e, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x28,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74,
    0x46, 0x69, 0x6c, 0x65, 0x4c, 0x69, 0x6e, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x29, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f,
    0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x4c, 0x69,
    0x6e, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x6c, 0x0a, 0x11, 0x67, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
    0x74, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x12, 0x2a, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f,
    0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
    0x74, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2b, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x53, 0x75, 0x6d,
    0x6d, 0x61, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x51, 0x0a, 0x08, 0x73, 0x65, 0x74, 0x51, 0x75, 0x6f, 0x74, 0x61, 0x12, 0x21, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x65, 0x74, 0x51,
    0x75, 0x6f, 0x74, 0x61, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x1a, 0x22, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53,
    0x65, 0x74, 0x51, 0x75, 0x6f, 0x74, 0x61, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x12, 0x48, 0x0a, 0x05, 0x66, 0x73, 0x79, 0x6e, 0x63, 0x12, 0x1e, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x46, 0x73, 0x79, 0x6e,
    0x63, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x46, 0x73, 0x79, 0x6e,
    0x63, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x51,
    0x0a, 0x08, 0x73, 0x65, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x12, 0x21, 0x2e, 0x68, 0x61, 0x64,
    0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x65, 0x74, 0x54, 0x69, 0x6d, 0x65,
    0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x22, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x65, 0x74, 0x54,
    0x69, 0x6d, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x60, 0x0a, 0x0d, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x79, 0x6d, 0x6c, 0x69,
    0x6e, 0x6b, 0x12, 0x26, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x79, 0x6d, 0x6c, 0x69, 0x6e, 0x6b, 0x52, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x27, 0x2e, 0x68, 0x61, 0x64,
    0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53,
    0x79, 0x6d, 0x6c, 0x69, 0x6e, 0x6b, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x60, 0x0a, 0x0d, 0x67, 0x65, 0x74, 0x4c, 0x69, 0x6e, 0x6b, 0x54, 0x61,
    0x72, 0x67, 0x65, 0x74, 0x12, 0x26, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x4c, 0x69, 0x6e, 0x6b, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74,
    0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x27, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x4c, 0x69,
    0x6e, 0x6b, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x7b, 0x0a, 0x16, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x42,
    0x6c, 0x6f, 0x63, 0x6b, 0x46, 0x6f, 0x72, 0x50, 0x69, 0x70, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x12,
    0x2f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x55, 0x70,
    0x64, 0x61, 0x74, 0x65, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x46, 0x6f, 0x72, 0x50, 0x69, 0x70, 0x65,
    0x6c, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
    0x1a, 0x30, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x55,
    0x70, 0x64, 0x61, 0x74, 0x65, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x46, 0x6f, 0x72, 0x50, 0x69, 0x70,
    0x65, 0x6c, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x12, 0x63, 0x0a, 0x0e, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x69, 0x70, 0x65,
    0x6c, 0x69, 0x6e, 0x65, 0x12, 0x27, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x69, 0x70, 0x65, 0x6c, 0x69, 0x6e,
    0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x28, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x55, 0x70, 0x64, 0x61,
    0x74, 0x65, 0x50, 0x69, 0x70, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x73, 0x0a, 0x12, 0x67, 0x65, 0x74, 0x44, 0x65,
    0x6c, 0x65, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x2d, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x47, 0x65,
    0x74, 0x44, 0x65, 0x6c, 0x65, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x6b, 0x65, 0x6e,
    0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2e, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x47, 0x65, 0x74,
    0x44, 0x65, 0x6c, 0x65, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x79, 0x0a, 0x14,
    0x72, 0x65, 0x6e, 0x65, 0x77, 0x44, 0x65, 0x6c, 0x65, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54,
    0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x2f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x63, 0x6f,
    0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x6e, 0x65, 0x77, 0x44, 0x65, 0x6c, 0x65, 0x67, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x30, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x63,
    0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x6e, 0x65, 0x77, 0x44, 0x65, 0x6c, 0x65, 0x67,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x7c, 0x0a, 0x15, 0x63, 0x61, 0x6e, 0x63, 0x65,
    0x6c, 0x44, 0x65, 0x6c, 0x65, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x6b, 0x65, 0x6e,
    0x12, 0x30, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
    0x2e, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x44, 0x65, 0x6c, 0x65, 0x67, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x1a, 0x31, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x63, 0x6f, 0x6d, 0x6d,
    0x6f, 0x6e, 0x2e, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x44, 0x65, 0x6c, 0x65, 0x67, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x75, 0x0a, 0x14, 0x73, 0x65, 0x74, 0x42, 0x61, 0x6c, 0x61,
    0x6e, 0x63, 0x65, 0x72, 0x42, 0x61, 0x6e, 0x64, 0x77, 0x69, 0x64, 0x74, 0x68, 0x12, 0x2d, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x65, 0x74, 0x42,
    0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x72, 0x42, 0x61, 0x6e, 0x64, 0x77, 0x69, 0x64, 0x74, 0x68,
    0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2e, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x53, 0x65, 0x74, 0x42, 0x61,
    0x6c, 0x61, 0x6e, 0x63, 0x65, 0x72, 0x42, 0x61, 0x6e, 0x64, 0x77, 0x69, 0x64, 0x74, 0x68, 0x52,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x75, 0x0a, 0x14,
    0x67, 0x65, 0x74, 0x44, 0x61, 0x74, 0x61, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f,
    0x6e, 0x4b, 0x65, 0x79, 0x12, 0x2d, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x44, 0x61, 0x74, 0x61, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70,
    0x74, 0x69, 0x6f, 0x6e, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x1a, 0x2e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x47, 0x65, 0x74, 0x44, 0x61, 0x74, 0x61, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74,
    0x69, 0x6f, 0x6e, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x63, 0x0a, 0x0e, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x6e, 0x61,
    0x70, 0x73, 0x68, 0x6f, 0x74, 0x12, 0x27, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68,
    0x64, 0x66, 0x73, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68,
    0x6f, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x28,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x72, 0x65,
    0x61, 0x74, 0x65, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x63, 0x0a, 0x0e, 0x72, 0x65, 0x6e, 0x61,
    0x6d, 0x65, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x12, 0x27, 0x2e, 0x68, 0x61, 0x64,
    0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x53,
    0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x1a, 0x28, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x60, 0x0a,
    0x0d, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x12, 0x26,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x41, 0x6c, 0x6c,
    0x6f, 0x77, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x27, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x41, 0x6c, 0x6c, 0x6f, 0x77, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68,
    0x6f, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
    0x69, 0x0a, 0x10, 0x64, 0x69, 0x73, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x53, 0x6e, 0x61, 0x70, 0x73,
    0x68, 0x6f, 0x74, 0x12, 0x29, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x44, 0x69, 0x73, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68,
    0x6f, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2a,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x44, 0x69, 0x73,
    0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x52, 0x65, 0x73,
    0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x87, 0x01, 0x0a, 0x1a, 0x67,
    0x65, 0x74, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x44,
    0x69, 0x72, 0x4c, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x12, 0x33, 0x2e, 0x68, 0x61, 0x64, 0x6f,
    0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x6e, 0x61, 0x70, 0x73,
    0x68, 0x6f, 0x74, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x69, 0x72, 0x4c, 0x69, 0x73, 0x74, 0x69,
    0x6e, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x34,
    0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74,
    0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x69, 0x72,
    0x4c, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x12, 0x63, 0x0a, 0x0e, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x53, 0x6e,
    0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x12, 0x27, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x53, 0x6e, 0x61, 0x70, 0x73,
    0x68, 0x6f, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a,
    0x28, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x44, 0x65,
    0x6c, 0x65, 0x74, 0x65, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x78, 0x0a, 0x15, 0x67, 0x65, 0x74,
    0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x44, 0x69, 0x66, 0x66, 0x52, 0x65, 0x70, 0x6f,
    0x72, 0x74, 0x12, 0x2e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x47, 0x65, 0x74, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x44, 0x69, 0x66, 0x66,
    0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x1a, 0x2f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x47, 0x65, 0x74, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x44, 0x69, 0x66, 0x66,
    0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x5d, 0x0a, 0x0c, 0x69, 0x73, 0x46, 0x69, 0x6c, 0x65, 0x43, 0x6c, 0x6f,
    0x73, 0x65, 0x64, 0x12, 0x25, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x49, 0x73, 0x46, 0x69, 0x6c, 0x65, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x64, 0x52, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x26, 0x2e, 0x68, 0x61, 0x64,
    0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x49, 0x73, 0x46, 0x69, 0x6c, 0x65, 0x43,
    0x6c, 0x6f, 0x73, 0x65, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x12, 0x69, 0x0a, 0x10, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x79, 0x41, 0x63, 0x6c, 0x45,
    0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x12, 0x29, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x79, 0x41, 0x63, 0x6c, 0x45, 0x6e,
    0x74, 0x72, 0x69, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x1a, 0x2a, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e,
    0x4d, 0x6f, 0x64, 0x69, 0x66, 0x79, 0x41, 0x63, 0x6c, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x69, 0x0a,
    0x10, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x41, 0x63, 0x6c, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65,
    0x73, 0x12, 0x29, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e,
    0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x41, 0x63, 0x6c, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73,
    0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2a, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76,
    0x65, 0x41, 0x63, 0x6c, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x69, 0x0a, 0x10, 0x72, 0x65, 0x6d, 0x6f,
    0x76, 0x65, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x41, 0x63, 0x6c, 0x12, 0x29, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76,
    0x65, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x41, 0x63, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2a, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70,
    0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x44, 0x65, 0x66, 0x61,
    0x75, 0x6c, 0x74, 0x41, 0x63, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x54, 0x0a, 0x09, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x41, 0x63, 0x6c,
    0x12, 0x22, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52,
    0x65, 0x6d, 0x6f, 0x76, 0x65, 0x41, 0x63, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x23, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x41, 0x63, 0x6c, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x4b, 0x0a, 0x06, 0x73, 0x65, 0x74,
    0x41, 0x63, 0x6c, 0x12, 0x1f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66,
    0x73, 0x2e, 0x53, 0x65, 0x74, 0x41, 0x63, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x20, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x53, 0x65, 0x74, 0x41, 0x63, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x5d, 0x0a, 0x0c, 0x67, 0x65, 0x74, 0x41, 0x63, 0x6c,
    0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x25, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x41, 0x63, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x75,
    0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x26, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x41,
    0x63, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x51, 0x0a, 0x08, 0x73, 0x65, 0x74, 0x58, 0x41, 0x74, 0x74,
    0x72, 0x12, 0x21, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e,
    0x53, 0x65, 0x74, 0x58, 0x41, 0x74, 0x74, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x22, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64,
    0x66, 0x73, 0x2e, 0x53, 0x65, 0x74, 0x58, 0x41, 0x74, 0x74, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x54, 0x0a, 0x09, 0x67, 0x65, 0x74, 0x58,
    0x41, 0x74, 0x74, 0x72, 0x73, 0x12, 0x22, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68,
    0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x58, 0x41, 0x74, 0x74, 0x72, 0x73, 0x52, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x23, 0x2e, 0x68, 0x61, 0x64, 0x6f,
    0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x58, 0x41, 0x74, 0x74, 0x72,
    0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x57,
    0x0a, 0x0a, 0x6c, 0x69, 0x73, 0x74, 0x58, 0x41, 0x74, 0x74, 0x72, 0x73, 0x12, 0x23, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x58,
    0x41, 0x74, 0x74, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x1a, 0x24, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e,
    0x4c, 0x69, 0x73, 0x74, 0x58, 0x41, 0x74, 0x74, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x5a, 0x0a, 0x0b, 0x72, 0x65, 0x6d, 0x6f, 0x76,
    0x65, 0x58, 0x41, 0x74, 0x74, 0x72, 0x12, 0x24, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x58, 0x41, 0x74, 0x74, 0x72,
    0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x25, 0x2e, 0x68,
    0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76,
    0x65, 0x58, 0x41, 0x74, 0x74, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x5a, 0x0a, 0x0b, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x41, 0x63, 0x63, 0x65,
    0x73, 0x73, 0x12, 0x24, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x52, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x25, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f,
    0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x41, 0x63, 0x63, 0x65,
    0x73, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
    0x75, 0x0a, 0x14, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74,
    0x69, 0x6f, 0x6e, 0x5a, 0x6f, 0x6e, 0x65, 0x12, 0x2d, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70,
    0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x45, 0x6e, 0x63, 0x72,
    0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x5a, 0x6f, 0x6e, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e,
    0x68, 0x64, 0x66, 0x73, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x45, 0x6e, 0x63, 0x72, 0x79,
    0x70, 0x74, 0x69, 0x6f, 0x6e, 0x5a, 0x6f, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x72, 0x0a, 0x13, 0x6c, 0x69, 0x73, 0x74, 0x45, 0x6e,
    0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x5a, 0x6f, 0x6e, 0x65, 0x73, 0x12, 0x2c, 0x2e,
    0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4c, 0x69, 0x73, 0x74,
    0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x5a, 0x6f, 0x6e, 0x65, 0x73, 0x52,
    0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2d, 0x2e, 0x68, 0x61,
    0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x45, 0x6e,
    0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x5a, 0x6f, 0x6e, 0x65, 0x73, 0x52, 0x65, 0x73,
    0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x5d, 0x0a, 0x0c, 0x67, 0x65,
    0x74, 0x45, 0x5a, 0x46, 0x6f, 0x72, 0x50, 0x61, 0x74, 0x68, 0x12, 0x25, 0x2e, 0x68, 0x61, 0x64,
    0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x45, 0x5a, 0x46, 0x6f,
    0x72, 0x50, 0x61, 0x74, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x1a, 0x26, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e,
    0x47, 0x65, 0x74, 0x45, 0x5a, 0x46, 0x6f, 0x72, 0x50, 0x61, 0x74, 0x68, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x78, 0x0a, 0x15, 0x67, 0x65, 0x74,
    0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x45, 0x64, 0x69, 0x74, 0x4c, 0x6f, 0x67, 0x54, 0x78,
    0x69, 0x64, 0x12, 0x2e, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x45, 0x64, 0x69, 0x74, 0x4c,
    0x6f, 0x67, 0x54, 0x78, 0x69, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x1a, 0x2f, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x45, 0x64, 0x69, 0x74, 0x4c,
    0x6f, 0x67, 0x54, 0x78, 0x69, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x12, 0x69, 0x0a, 0x10, 0x67, 0x65, 0x74, 0x45, 0x64, 0x69, 0x74, 0x73, 0x46,
    0x72, 0x6f, 0x6d, 0x54, 0x78, 0x69, 0x64, 0x12, 0x29, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70,
    0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x45, 0x64, 0x69, 0x74, 0x73, 0x46, 0x72,
    0x6f, 0x6d, 0x54, 0x78, 0x69, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x1a, 0x2a, 0x2e, 0x68, 0x61, 0x64, 0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73,
    0x2e, 0x47, 0x65, 0x74, 0x45, 0x64, 0x69, 0x74, 0x73, 0x46, 0x72, 0x6f, 0x6d, 0x54, 0x78, 0x69,
    0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x42, 0x4b,
    0x0a, 0x25, 0x6f, 0x72, 0x67, 0x2e, 0x61, 0x70, 0x61, 0x63, 0x68, 0x65, 0x2e, 0x68, 0x61, 0x64,
    0x6f, 0x6f, 0x70, 0x2e, 0x68, 0x64, 0x66, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f,
    0x6c, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x42, 0x1c, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4e,
    0x61, 0x6d, 0x65, 0x6e, 0x6f, 0x64, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x73, 0xa0, 0x01, 0x01, 0x88, 0x01, 0x01, 0x4a, 0xc4, 0xd4, 0x01, 0x0a,
    0x07, 0x12, 0x05, 0x18, 0x00, 0xdb, 0x06, 0x01, 0x0a, 0x08, 0x0a, 0x01, 0x08, 0x12, 0x03, 0x18,
    0x00, 0x3e, 0x0a, 0x0b, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x03, 0x18, 0x00, 0x3e, 0x0a,
    0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x03, 0x18, 0x07, 0x13, 0x0a, 0x0d, 0x0a,
    0x06, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x03, 0x18, 0x07, 0x13, 0x0a, 0x0e, 0x0a, 0x07,
    0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x18, 0x07, 0x13, 0x0a, 0x0c, 0x0a, 0x05,
    0x08, 0xe7, 0x07, 0x00, 0x07, 0x12, 0x03, 0x18, 0x16, 0x3d, 0x0a, 0x08, 0x0a, 0x01, 0x08, 0x12,
    0x03, 0x19, 0x00, 0x3d, 0x0a, 0x0b, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x01, 0x12, 0x03, 0x19, 0x00,
    0x3d, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x12, 0x03, 0x19, 0x07, 0x1b, 0x0a,
    0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x12, 0x03, 0x19, 0x07, 0x1b, 0x0a, 0x0e,
    0x0a, 0x07, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x19, 0x07, 0x1b, 0x0a, 0x0c,
    0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01, 0x07, 0x12, 0x03, 0x19, 0x1e, 0x3c, 0x0a, 0x08, 0x0a, 0x01,
    0x08, 0x12, 0x03, 0x1a, 0x00, 0x24, 0x0a, 0x0b, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x02, 0x12, 0x03,
    0x1a, 0x00, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x02, 0x02, 0x12, 0x03, 0x1a, 0x07,
    0x1c, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x02, 0x02, 0x00, 0x12, 0x03, 0x1a, 0x07, 0x1c,
    0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x02, 0x02, 0x00, 0x01, 0x12, 0x03, 0x1a, 0x07, 0x1c,
    0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x02, 0x03, 0x12, 0x03, 0x1a, 0x1f, 0x23, 0x0a, 0x08,
    0x0a, 0x01, 0x08, 0x12, 0x03, 0x1b, 0x00, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x03,
    0x12, 0x03, 0x1b, 0x00, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x03, 0x02, 0x12, 0x03,
    0x1b, 0x07, 0x24, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x03, 0x02, 0x00, 0x12, 0x03, 0x1b,
    0x07, 0x24, 0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x03, 0x02, 0x00, 0x01, 0x12, 0x03, 0x1b,
    0x07, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x03, 0x03, 0x12, 0x03, 0x1b, 0x27, 0x2b,
    0x0a, 0x08, 0x0a, 0x01, 0x02, 0x12, 0x03, 0x1c, 0x08, 0x13, 0x0a, 0x09, 0x0a, 0x02, 0x03, 0x00,
    0x12, 0x03, 0x1e, 0x07, 0x17, 0x0a, 0x09, 0x0a, 0x02, 0x03, 0x01, 0x12, 0x03, 0x1f, 0x07, 0x13,
    0x0a, 0x09, 0x0a, 0x02, 0x03, 0x02, 0x12, 0x03, 0x20, 0x07, 0x12, 0x0a, 0x09, 0x0a, 0x02, 0x03,
    0x03, 0x12, 0x03, 0x21, 0x07, 0x14, 0x0a, 0x09, 0x0a, 0x02, 0x03, 0x04, 0x12, 0x03, 0x22, 0x07,
    0x19, 0x0a, 0x09, 0x0a, 0x02, 0x03, 0x05, 0x12, 0x03, 0x23, 0x07, 0x16, 0x0a, 0x0a, 0x0a, 0x02,
    0x04, 0x00, 0x12, 0x04, 0x2e, 0x00, 0x32, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x00, 0x01, 0x12,
    0x03, 0x2e, 0x08, 0x25, 0x0a, 0x18, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x00, 0x12, 0x03, 0x2f, 0x02,
    0x1a, 0x22, 0x0b, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x04, 0x12, 0x03, 0x2f, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x00, 0x02, 0x00, 0x05, 0x12, 0x03, 0x2f, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00,
    0x02, 0x00, 0x01, 0x12, 0x03, 0x2f, 0x12, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00,
    0x03, 0x12, 0x03, 0x2f, 0x18, 0x19, 0x0a, 0x21, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x01, 0x12, 0x03,
    0x30, 0x02, 0x1d, 0x22, 0x14, 0x20, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x20, 0x73, 0x74, 0x61, 0x72,
    0x74, 0x20, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x01, 0x04, 0x12, 0x03, 0x30, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x05,
    0x12, 0x03, 0x30, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03,
    0x30, 0x12, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x03, 0x12, 0x03, 0x30, 0x1b,
    0x1c, 0x0a, 0x1b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x02, 0x12, 0x03, 0x31, 0x02, 0x1d, 0x22, 0x0e,
    0x20, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x20, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x02, 0x04, 0x12, 0x03, 0x31, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x00, 0x02, 0x02, 0x05, 0x12, 0x03, 0x31, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00,
    0x02, 0x02, 0x01, 0x12, 0x03, 0x31, 0x12, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x02,
    0x03, 0x12, 0x03, 0x31, 0x1b, 0x1c, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x01, 0x12, 0x04, 0x34, 0x00,
    0x36, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x01, 0x01, 0x12, 0x03, 0x34, 0x08, 0x26, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x01, 0x02, 0x00, 0x12, 0x03, 0x35, 0x02, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x00, 0x04, 0x12, 0x03, 0x35, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02,
    0x00, 0x06, 0x12, 0x03, 0x35, 0x0b, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x01,
    0x12, 0x03, 0x35, 0x1e, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x03, 0x12, 0x03,
    0x35, 0x2a, 0x2b, 0x0a, 0x1b, 0x0a, 0x02, 0x04, 0x02, 0x12, 0x04, 0x38, 0x00, 0x39, 0x01, 0x22,
    0x0f, 0x20, 0x4e, 0x6f, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x0a,
    0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x02, 0x01, 0x12, 0x03, 0x38, 0x08, 0x25, 0x0a, 0x0a, 0x0a, 0x02,
    0x04, 0x03, 0x12, 0x04, 0x3b, 0x00, 0x3d, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x03, 0x01, 0x12,
    0x03, 0x3b, 0x08, 0x26, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x00, 0x12, 0x03, 0x3c, 0x02,
    0x34, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x04, 0x12, 0x03, 0x3c, 0x02, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x06, 0x12, 0x03, 0x3c, 0x0b, 0x20, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x03, 0x02, 0x00, 0x01, 0x12, 0x03, 0x3c, 0x21, 0x2f, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x03, 0x02, 0x00, 0x03, 0x12, 0x03, 0x3c, 0x32, 0x33, 0x0a, 0x0a, 0x0a, 0x02, 0x05, 0x00, 0x12,
    0x04, 0x3f, 0x00, 0x45, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x00, 0x01, 0x12, 0x03, 0x3f, 0x05,
    0x14, 0x0a, 0x1c, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x00, 0x12, 0x03, 0x40, 0x02, 0x10, 0x22, 0x0f,
    0x20, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x40, 0x02, 0x08, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x00, 0x02, 0x00, 0x02, 0x12, 0x03, 0x40, 0x0b, 0x0f, 0x0a, 0x3f, 0x0a, 0x04, 0x05,
    0x00, 0x02, 0x01, 0x12, 0x03, 0x41, 0x02, 0x13, 0x22, 0x32, 0x20, 0x54, 0x72, 0x75, 0x6e, 0x63,
    0x61, 0x74, 0x65, 0x2f, 0x6f, 0x76, 0x65, 0x72, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x61, 0x20,
    0x66, 0x69, 0x6c, 0x65, 0x2e, 0x20, 0x53, 0x61, 0x6d, 0x65, 0x20, 0x61, 0x73, 0x20, 0x50, 0x4f,
    0x53, 0x49, 0x58, 0x20, 0x4f, 0x5f, 0x54, 0x52, 0x55, 0x4e, 0x43, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x41, 0x02, 0x0b, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x01, 0x02, 0x12, 0x03, 0x41, 0x0e, 0x12, 0x0a, 0x1f, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x02,
    0x12, 0x03, 0x42, 0x02, 0x10, 0x22, 0x12, 0x20, 0x41, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x20, 0x74,
    0x6f, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x02, 0x01, 0x12, 0x03, 0x42, 0x02, 0x08, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x02, 0x02,
    0x12, 0x03, 0x42, 0x0b, 0x0f, 0x0a, 0x37, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x03, 0x12, 0x03, 0x43,
    0x02, 0x16, 0x22, 0x2a, 0x20, 0x46, 0x69, 0x6c, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x72,
    0x65, 0x64, 0x75, 0x63, 0x65, 0x64, 0x20, 0x64, 0x75, 0x72, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74,
    0x79, 0x20, 0x67, 0x75, 0x61, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x00, 0x02, 0x03, 0x01, 0x12, 0x03, 0x43, 0x02, 0x0e, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x03, 0x02, 0x12, 0x03, 0x43, 0x11, 0x15, 0x0a, 0x37, 0x0a, 0x04, 0x05, 0x00,
    0x02, 0x04, 0x12, 0x03, 0x44, 0x02, 0x13, 0x22, 0x2a, 0x20, 0x57, 0x72, 0x69, 0x74, 0x65, 0x20,
    0x64, 0x61, 0x74, 0x61, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x6e, 0x65, 0x77, 0x20, 0x62, 0x6c,
    0x6f, 0x63, 0x6b, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x69,
    0x6e, 0x67, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x04, 0x01, 0x12, 0x03, 0x44, 0x02,
    0x0b, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x04, 0x02, 0x12, 0x03, 0x44, 0x0e, 0x12, 0x0a,
    0x0a, 0x0a, 0x02, 0x04, 0x04, 0x12, 0x04, 0x47, 0x00, 0x50, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04,
    0x04, 0x01, 0x12, 0x03, 0x47, 0x08, 0x1a, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x00, 0x12,
    0x03, 0x48, 0x02, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x04, 0x12, 0x03, 0x48,
    0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x05, 0x12, 0x03, 0x48, 0x0b, 0x11,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x01, 0x12, 0x03, 0x48, 0x12, 0x15, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x03, 0x12, 0x03, 0x48, 0x18, 0x19, 0x0a, 0x0b, 0x0a, 0x04,
    0x04, 0x04, 0x02, 0x01, 0x12, 0x03, 0x49, 0x02, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02,
    0x01, 0x04, 0x12, 0x03, 0x49, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x06,
    0x12, 0x03, 0x49, 0x0b, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x01, 0x12, 0x03,
    0x49, 0x1d, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x03, 0x12, 0x03, 0x49, 0x26,
    0x27, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x02, 0x12, 0x03, 0x4a, 0x02, 0x21, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x04, 0x02, 0x02, 0x04, 0x12, 0x03, 0x4a, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x04, 0x02, 0x02, 0x05, 0x12, 0x03, 0x4a, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04,
    0x02, 0x02, 0x01, 0x12, 0x03, 0x4a, 0x12, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x02,
    0x03, 0x12, 0x03, 0x4a, 0x1f, 0x20, 0x0a, 0x28, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x03, 0x12, 0x03,
    0x4b, 0x02, 0x21, 0x22, 0x1b, 0x20, 0x62, 0x69, 0x74, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x75,
    0x73, 0x69, 0x6e, 0x67, 0x20, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x46, 0x6c, 0x61, 0x67, 0x0a,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x03, 0x04, 0x12, 0x03, 0x4b, 0x02, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x04, 0x02, 0x03, 0x05, 0x12, 0x03, 0x4b, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x04, 0x02, 0x03, 0x01, 0x12, 0x03, 0x4b, 0x12, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04,
    0x02, 0x03, 0x03, 0x12, 0x03, 0x4b, 0x1f, 0x20, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x04,
    0x12, 0x03, 0x4c, 0x02, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x04, 0x04, 0x12, 0x03,
    0x4c, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x04, 0x05, 0x12, 0x03, 0x4c, 0x0b,
    0x0f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x04, 0x01, 0x12, 0x03, 0x4c, 0x10, 0x1c, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x04, 0x03, 0x12, 0x03, 0x4c, 0x1f, 0x20, 0x0a, 0x27, 0x0a,
    0x04, 0x04, 0x04, 0x02, 0x05, 0x12, 0x03, 0x4d, 0x02, 0x22, 0x22, 0x1a, 0x20, 0x53, 0x68, 0x6f,
    0x72, 0x74, 0x3a, 0x20, 0x4f, 0x6e, 0x6c, 0x79, 0x20, 0x31, 0x36, 0x20, 0x62, 0x69, 0x74, 0x73,
    0x20, 0x75, 0x73, 0x65, 0x64, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x05, 0x04, 0x12,
    0x03, 0x4d, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x05, 0x05, 0x12, 0x03, 0x4d,
    0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x05, 0x01, 0x12, 0x03, 0x4d, 0x12, 0x1d,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x05, 0x03, 0x12, 0x03, 0x4d, 0x20, 0x21, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x04, 0x02, 0x06, 0x12, 0x03, 0x4e, 0x02, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x04, 0x02, 0x06, 0x04, 0x12, 0x03, 0x4e, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02,
    0x06, 0x05, 0x12, 0x03, 0x4e, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x06, 0x01,
    0x12, 0x03, 0x4e, 0x12, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x06, 0x03, 0x12, 0x03,
    0x4e, 0x1e, 0x1f, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x07, 0x12, 0x03, 0x4f, 0x02, 0x40,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x07, 0x04, 0x12, 0x03, 0x4f, 0x02, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x04, 0x02, 0x07, 0x06, 0x12, 0x03, 0x4f, 0x0b, 0x25, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x04, 0x02, 0x07, 0x01, 0x12, 0x03, 0x4f, 0x26, 0x3b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04,
    0x02, 0x07, 0x03, 0x12, 0x03, 0x4f, 0x3e, 0x3f, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x05, 0x12, 0x04,
    0x52, 0x00, 0x54, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x05, 0x01, 0x12, 0x03, 0x52, 0x08, 0x1b,
    0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x00, 0x12, 0x03, 0x53, 0x02, 0x26, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x00, 0x04, 0x12, 0x03, 0x53, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x00, 0x06, 0x12, 0x03, 0x53, 0x0b, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x00, 0x01, 0x12, 0x03, 0x53, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x03,
    0x12, 0x03, 0x53, 0x24, 0x25, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x06, 0x12, 0x04, 0x56, 0x00, 0x5a,
    0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x06, 0x01, 0x12, 0x03, 0x56, 0x08, 0x1a, 0x0a, 0x0b, 0x0a,
    0x04, 0x04, 0x06, 0x02, 0x00, 0x12, 0x03, 0x57, 0x02, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x00, 0x04, 0x12, 0x03, 0x57, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00,
    0x05, 0x12, 0x03, 0x57, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x01, 0x12,
    0x03, 0x57, 0x12, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x03, 0x12, 0x03, 0x57,
    0x18, 0x19, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x01, 0x12, 0x03, 0x58, 0x02, 0x21, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x04, 0x12, 0x03, 0x58, 0x02, 0x0a, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x01, 0x05, 0x12, 0x03, 0x58, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x01, 0x01, 0x12, 0x03, 0x58, 0x12, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02,
    0x01, 0x03, 0x12, 0x03, 0x58, 0x1f, 0x20, 0x0a, 0x28, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x02, 0x12,
    0x03, 0x59, 0x02, 0x1b, 0x22, 0x1b, 0x20, 0x62, 0x69, 0x74, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20,
    0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x46, 0x6c, 0x61, 0x67,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x02, 0x04, 0x12, 0x03, 0x59, 0x02, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x02, 0x05, 0x12, 0x03, 0x59, 0x0b, 0x11, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x02, 0x01, 0x12, 0x03, 0x59, 0x12, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x02, 0x03, 0x12, 0x03, 0x59, 0x19, 0x1a, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x07, 0x12,
    0x04, 0x5c, 0x00, 0x5f, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x07, 0x01, 0x12, 0x03, 0x5c, 0x08,
    0x1b, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x00, 0x12, 0x03, 0x5d, 0x02, 0x27, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x04, 0x12, 0x03, 0x5d, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x07, 0x02, 0x00, 0x06, 0x12, 0x03, 0x5d, 0x0b, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07,
    0x02, 0x00, 0x01, 0x12, 0x03, 0x5d, 0x1d, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00,
    0x03, 0x12, 0x03, 0x5d, 0x25, 0x26, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x01, 0x12, 0x03,
    0x5e, 0x02, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x01, 0x04, 0x12, 0x03, 0x5e, 0x02,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x01, 0x06, 0x12, 0x03, 0x5e, 0x0b, 0x1e, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x01, 0x01, 0x12, 0x03, 0x5e, 0x1f, 0x23, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x07, 0x02, 0x01, 0x03, 0x12, 0x03, 0x5e, 0x26, 0x27, 0x0a, 0x0a, 0x0a, 0x02, 0x04,
    0x08, 0x12, 0x04, 0x61, 0x00, 0x64, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x08, 0x01, 0x12, 0x03,
    0x61, 0x08, 0x22, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x00, 0x12, 0x03, 0x62, 0x02, 0x1a,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x04, 0x12, 0x03, 0x62, 0x02, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x05, 0x12, 0x03, 0x62, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x08, 0x02, 0x00, 0x01, 0x12, 0x03, 0x62, 0x12, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08,
    0x02, 0x00, 0x03, 0x12, 0x03, 0x62, 0x18, 0x19, 0x0a, 0x27, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x01,
    0x12, 0x03, 0x63, 0x02, 0x22, 0x22, 0x1a, 0x20, 0x53, 0x68, 0x6f, 0x72, 0x74, 0x3a, 0x20, 0x4f,
    0x6e, 0x6c, 0x79, 0x20, 0x31, 0x36, 0x20, 0x62, 0x69, 0x74, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x04, 0x12, 0x03, 0x63, 0x02, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x05, 0x12, 0x03, 0x63, 0x0b, 0x11, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x08, 0x02, 0x01, 0x01, 0x12, 0x03, 0x63, 0x12, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x08, 0x02, 0x01, 0x03, 0x12, 0x03, 0x63, 0x20, 0x21, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x09, 0x12,
    0x04, 0x66, 0x00, 0x68, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x09, 0x01, 0x12, 0x03, 0x66, 0x08,
    0x23, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x00, 0x12, 0x03, 0x67, 0x02, 0x1b, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x04, 0x12, 0x03, 0x67, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x09, 0x02, 0x00, 0x05, 0x12, 0x03, 0x67, 0x0b, 0x0f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x09,
    0x02, 0x00, 0x01, 0x12, 0x03, 0x67, 0x10, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00,
    0x03, 0x12, 0x03, 0x67, 0x19, 0x1a, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x0a, 0x12, 0x04, 0x6a, 0x00,
    0x6d, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x0a, 0x01, 0x12, 0x03, 0x6a, 0x08, 0x24, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x0a, 0x02, 0x00, 0x12, 0x03, 0x6b, 0x02, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x0a, 0x02, 0x00, 0x04, 0x12, 0x03, 0x6b, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x0a, 0x02,
    0x00, 0x05, 0x12, 0x03, 0x6b, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x01,
    0x12, 0x03, 0x6b, 0x12, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x03, 0x12, 0x03,
    0x6b, 0x18, 0x19, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x01, 0x12, 0x03, 0x6c, 0x02, 0x21,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x04, 0x12, 0x03, 0x6c, 0x02, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x05, 0x12, 0x03, 0x6c, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x0a, 0x02, 0x01, 0x01, 0x12, 0x03, 0x6c, 0x12, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x0a,
    0x02, 0x01, 0x03, 0x12, 0x03, 0x6c, 0x1f, 0x20, 0x0a, 0x1b, 0x0a, 0x02, 0x04, 0x0b, 0x12, 0x04,
    0x6f, 0x00, 0x70, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x0b, 0x01, 0x12, 0x03, 0x6f, 0x08,
    0x25, 0x0a, 0x1a, 0x0a, 0x02, 0x04, 0x0c, 0x12, 0x04, 0x72, 0x00, 0x73, 0x01, 0x22, 0x0e, 0x20,
    0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x0a, 0x0a, 0x0a, 0x0a,
    0x03, 0x04, 0x0c, 0x01, 0x12, 0x03, 0x72, 0x08, 0x26, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x0d, 0x12,
    0x04, 0x75, 0x00, 0x77, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x0d, 0x01, 0x12, 0x03, 0x75, 0x08,
    0x27, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x00, 0x12, 0x03, 0x76, 0x02, 0x30, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x04, 0x12, 0x03, 0x76, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x0d, 0x02, 0x00, 0x06, 0x12, 0x03, 0x76, 0x0b, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x0d,
    0x02, 0x00, 0x01, 0x12, 0x03, 0x76, 0x23, 0x2b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00,
    0x03, 0x12, 0x03, 0x76, 0x2e, 0x2f, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x0e, 0x12, 0x04, 0x79, 0x00,
    0x7c, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x0e, 0x01, 0x12, 0x03, 0x79, 0x08, 0x21, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x0e, 0x02, 0x00, 0x12, 0x03, 0x7a, 0x02, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x0e, 0x02, 0x00, 0x04, 0x12, 0x03, 0x7a, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x0e, 0x02,
    0x00, 0x05, 0x12, 0x03, 0x7a, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x01,
    0x12, 0x03, 0x7a, 0x12, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x03, 0x12, 0x03,
    0x7a, 0x18, 0x19, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x01, 0x12, 0x03, 0x7b, 0x02, 0x2c,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x04, 0x12, 0x03, 0x7b, 0x02, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x06, 0x12, 0x03, 0x7b, 0x0b, 0x1c, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x0e, 0x02, 0x01, 0x01, 0x12, 0x03, 0x7b, 0x1d, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x0e,
    0x02, 0x01, 0x03, 0x12, 0x03, 0x7b, 0x2a, 0x2b, 0x0a, 0x1b, 0x0a, 0x02, 0x04, 0x0f, 0x12, 0x04,
    0x7e, 0x00, 0x7f, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x0f, 0x01, 0x12, 0x03, 0x7e, 0x08,
    0x22, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x10, 0x12, 0x06, 0x81, 0x01, 0x00, 0x85, 0x01, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x10, 0x01, 0x12, 0x04, 0x81, 0x01, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x10, 0x02, 0x00, 0x12, 0x04, 0x82, 0x01, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10,
    0x02, 0x00, 0x04, 0x12, 0x04, 0x82, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02,
    0x00, 0x05, 0x12, 0x04, 0x82, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00,
    0x01, 0x12, 0x04, 0x82, 0x01, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x03,
    0x12, 0x04, 0x82, 0x01, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x01, 0x12, 0x04,
    0x83, 0x01, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01, 0x04, 0x12, 0x04, 0x83,
    0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01, 0x05, 0x12, 0x04, 0x83, 0x01,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01, 0x01, 0x12, 0x04, 0x83, 0x01, 0x12,
    0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01, 0x03, 0x12, 0x04, 0x83, 0x01, 0x1d, 0x1e,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x02, 0x12, 0x04, 0x84, 0x01, 0x02, 0x20, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x04, 0x12, 0x04, 0x84, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x10, 0x02, 0x02, 0x05, 0x12, 0x04, 0x84, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x10, 0x02, 0x02, 0x01, 0x12, 0x04, 0x84, 0x01, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x10, 0x02, 0x02, 0x03, 0x12, 0x04, 0x84, 0x01, 0x1e, 0x1f, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x11,
    0x12, 0x06, 0x87, 0x01, 0x00, 0x88, 0x01, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20,
    0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x11, 0x01,
    0x12, 0x04, 0x87, 0x01, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x12, 0x12, 0x06, 0x8a, 0x01,
    0x00, 0x8f, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x12, 0x01, 0x12, 0x04, 0x8a, 0x01, 0x08,
    0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x00, 0x12, 0x04, 0x8b, 0x01, 0x02, 0x24, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8b, 0x01, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x06, 0x12, 0x04, 0x8b, 0x01, 0x0b, 0x1d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8b, 0x01, 0x1e, 0x1f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8b, 0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x12, 0x02, 0x01, 0x12, 0x04, 0x8c, 0x01, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x01, 0x04, 0x12, 0x04, 0x8c, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01,
    0x05, 0x12, 0x04, 0x8c, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x01,
    0x12, 0x04, 0x8c, 0x01, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x03, 0x12,
    0x04, 0x8c, 0x01, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x02, 0x12, 0x04, 0x8d,
    0x01, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x04, 0x12, 0x04, 0x8d, 0x01,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x05, 0x12, 0x04, 0x8d, 0x01, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x01, 0x12, 0x04, 0x8d, 0x01, 0x12, 0x18,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x03, 0x12, 0x04, 0x8d, 0x01, 0x1b, 0x1c, 0x0a,
    0x2f, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x03, 0x12, 0x04, 0x8e, 0x01, 0x02, 0x2b, 0x22, 0x21, 0x20,
    0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x47, 0x52, 0x41, 0x4e, 0x44,
    0x46, 0x41, 0x54, 0x48, 0x45, 0x52, 0x5f, 0x49, 0x4e, 0x4f, 0x44, 0x45, 0x5f, 0x49, 0x44, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x04, 0x12, 0x04, 0x8e, 0x01, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x05, 0x12, 0x04, 0x8e, 0x01, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x01, 0x12, 0x04, 0x8e, 0x01, 0x12, 0x18, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x03, 0x03, 0x12, 0x04, 0x8e, 0x01, 0x1b, 0x1c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x03, 0x08, 0x12, 0x04, 0x8e, 0x01, 0x1d, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x03, 0x07, 0x12, 0x04, 0x8e, 0x01, 0x28, 0x29, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x13,
    0x12, 0x06, 0x91, 0x01, 0x00, 0x92, 0x01, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20,
    0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x13, 0x01,
    0x12, 0x04, 0x91, 0x01, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x14, 0x12, 0x06, 0x94, 0x01,
    0x00, 0x9b, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x14, 0x01, 0x12, 0x04, 0x94, 0x01, 0x08,
    0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x00, 0x12, 0x04, 0x95, 0x01, 0x02, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x00, 0x04, 0x12, 0x04, 0x95, 0x01, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x00, 0x05, 0x12, 0x04, 0x95, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x00, 0x01, 0x12, 0x04, 0x95, 0x01, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x00, 0x03, 0x12, 0x04, 0x95, 0x01, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x14, 0x02, 0x01, 0x12, 0x04, 0x96, 0x01, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x01, 0x04, 0x12, 0x04, 0x96, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x01,
    0x05, 0x12, 0x04, 0x96, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x01, 0x01,
    0x12, 0x04, 0x96, 0x01, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x01, 0x03, 0x12,
    0x04, 0x96, 0x01, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x02, 0x12, 0x04, 0x97,
    0x01, 0x02, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x04, 0x12, 0x04, 0x97, 0x01,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x06, 0x12, 0x04, 0x97, 0x01, 0x0b,
    0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x01, 0x12, 0x04, 0x97, 0x01, 0x1e, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x03, 0x12, 0x04, 0x97, 0x01, 0x29, 0x2a, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x03, 0x12, 0x04, 0x98, 0x01, 0x02, 0x2e, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x03, 0x04, 0x12, 0x04, 0x98, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x03, 0x06, 0x12, 0x04, 0x98, 0x01, 0x0b, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x03, 0x01, 0x12, 0x04, 0x98, 0x01, 0x1d, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x03, 0x03, 0x12, 0x04, 0x98, 0x01, 0x2c, 0x2d, 0x0a, 0x25, 0x0a, 0x04, 0x04, 0x14, 0x02,
    0x04, 0x12, 0x04, 0x99, 0x01, 0x02, 0x2b, 0x22, 0x17, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c,
    0x74, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x62, 0x6f, 0x67, 0x75, 0x73, 0x20, 0x69, 0x64, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x04, 0x04, 0x12, 0x04, 0x99, 0x01, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x04, 0x05, 0x12, 0x04, 0x99, 0x01, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x04, 0x01, 0x12, 0x04, 0x99, 0x01, 0x12, 0x18, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x04, 0x03, 0x12, 0x04, 0x99, 0x01, 0x1b, 0x1c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x04, 0x08, 0x12, 0x04, 0x99, 0x01, 0x1d, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x04, 0x07, 0x12, 0x04, 0x99, 0x01, 0x28, 0x29, 0x0a, 0x38, 0x0a, 0x04, 0x04, 0x14,
    0x02, 0x05, 0x12, 0x04, 0x9a, 0x01, 0x02, 0x23, 0x22, 0x2a, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65,
    0x74, 0x20, 0x6f, 0x66, 0x20, 0x64, 0x61, 0x74, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x73, 0x20, 0x74,
    0x6f, 0x20, 0x75, 0x73, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6c,
    0x6f, 0x63, 0x6b, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x05, 0x04, 0x12, 0x04, 0x9a,
    0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x05, 0x05, 0x12, 0x04, 0x9a, 0x01,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x05, 0x01, 0x12, 0x04, 0x9a, 0x01, 0x12,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x05, 0x03, 0x12, 0x04, 0x9a, 0x01, 0x21, 0x22,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x15, 0x12, 0x06, 0x9d, 0x01, 0x00, 0x9f, 0x01, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x15, 0x01, 0x12, 0x04, 0x9d, 0x01, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x15, 0x02, 0x00, 0x12, 0x04, 0x9e, 0x01, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02,
    0x00, 0x04, 0x12, 0x04, 0x9e, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00,
    0x06, 0x12, 0x04, 0x9e, 0x01, 0x0b, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x01,
    0x12, 0x04, 0x9e, 0x01, 0x1d, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x03, 0x12,
    0x04, 0x9e, 0x01, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x16, 0x12, 0x06, 0xa1, 0x01, 0x00,
    0xaa, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x16, 0x01, 0x12, 0x04, 0xa1, 0x01, 0x08, 0x29,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x00, 0x12, 0x04, 0xa2, 0x01, 0x02, 0x1a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa2, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x16, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa2, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x16, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa2, 0x01, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x16, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa2, 0x01, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16,
    0x02, 0x01, 0x12, 0x04, 0xa3, 0x01, 0x02, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01,
    0x04, 0x12, 0x04, 0xa3, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x06,
    0x12, 0x04, 0xa3, 0x01, 0x0b, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xa3, 0x01, 0x1e, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xa3, 0x01, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x02, 0x12, 0x04, 0xa4, 0x01,
    0x02, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa4, 0x01, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x02, 0x06, 0x12, 0x04, 0xa4, 0x01, 0x0b, 0x1c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa4, 0x01, 0x1d, 0x26, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa4, 0x01, 0x29, 0x2a, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x16, 0x02, 0x03, 0x12, 0x04, 0xa5, 0x01, 0x02, 0x2a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x16, 0x02, 0x03, 0x04, 0x12, 0x04, 0xa5, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x16, 0x02, 0x03, 0x06, 0x12, 0x04, 0xa5, 0x01, 0x0b, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x03, 0x01, 0x12, 0x04, 0xa5, 0x01, 0x1d, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x03, 0x03, 0x12, 0x04, 0xa5, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x04,
    0x12, 0x04, 0xa6, 0x01, 0x02, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x04, 0x12,
    0x04, 0xa6, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x05, 0x12, 0x04,
    0xa6, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x01, 0x12, 0x04, 0xa6,
    0x01, 0x12, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x03, 0x12, 0x04, 0xa6, 0x01,
    0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x05, 0x12, 0x04, 0xa7, 0x01, 0x02, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x05, 0x04, 0x12, 0x04, 0xa7, 0x01, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x05, 0x05, 0x12, 0x04, 0xa7, 0x01, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x16, 0x02, 0x05, 0x01, 0x12, 0x04, 0xa7, 0x01, 0x12, 0x1c, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x16, 0x02, 0x05, 0x03, 0x12, 0x04, 0xa7, 0x01, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x16, 0x02, 0x06, 0x12, 0x04, 0xa8, 0x01, 0x02, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x06, 0x04, 0x12, 0x04, 0xa8, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x06, 0x05, 0x12, 0x04, 0xa8, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x06,
    0x01, 0x12, 0x04, 0xa8, 0x01, 0x12, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x06, 0x03,
    0x12, 0x04, 0xa8, 0x01, 0x29, 0x2a, 0x0a, 0x2f, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x07, 0x12, 0x04,
    0xa9, 0x01, 0x02, 0x2b, 0x22, 0x21, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x74,
    0x6f, 0x20, 0x47, 0x52, 0x41, 0x4e, 0x44, 0x46, 0x41, 0x54, 0x48, 0x45, 0x52, 0x5f, 0x49, 0x4e,
    0x4f, 0x44, 0x45, 0x5f, 0x49, 0x44, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x04,
    0x12, 0x04, 0xa9, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x05, 0x12,
    0x04, 0xa9, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x01, 0x12, 0x04,
    0xa9, 0x01, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x03, 0x12, 0x04, 0xa9,
    0x01, 0x1b, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x08, 0x12, 0x04, 0xa9, 0x01,
    0x1d, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x07, 0x12, 0x04, 0xa9, 0x01, 0x28,
    0x29, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x17, 0x12, 0x06, 0xac, 0x01, 0x00, 0xae, 0x01, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x17, 0x01, 0x12, 0x04, 0xac, 0x01, 0x08, 0x2a, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x17, 0x02, 0x00, 0x12, 0x04, 0xad, 0x01, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xad, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02,
    0x00, 0x06, 0x12, 0x04, 0xad, 0x01, 0x0b, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xad, 0x01, 0x1d, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xad, 0x01, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x18, 0x12, 0x06, 0xb0, 0x01,
    0x00, 0xb5, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x18, 0x01, 0x12, 0x04, 0xb0, 0x01, 0x08,
    0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x00, 0x12, 0x04, 0xb1, 0x01, 0x02, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb1, 0x01, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb1, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x18, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb1, 0x01, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x18, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb1, 0x01, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x18, 0x02, 0x01, 0x12, 0x04, 0xb2, 0x01, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xb2, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xb2, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xb2, 0x01, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xb2, 0x01, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x02, 0x12, 0x04, 0xb3,
    0x01, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb3, 0x01,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x06, 0x12, 0x04, 0xb3, 0x01, 0x0b,
    0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb3, 0x01, 0x1e, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb3, 0x01, 0x25, 0x26, 0x0a,
    0x2f, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x03, 0x12, 0x04, 0xb4, 0x01, 0x02, 0x2b, 0x22, 0x21, 0x20,
    0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x47, 0x52, 0x41, 0x4e, 0x44,
    0x46, 0x41, 0x54, 0x48, 0x45, 0x52, 0x5f, 0x49, 0x4e, 0x4f, 0x44, 0x45, 0x5f, 0x49, 0x44, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x03, 0x04, 0x12, 0x04, 0xb4, 0x01, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x03, 0x05, 0x12, 0x04, 0xb4, 0x01, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x18, 0x02, 0x03, 0x01, 0x12, 0x04, 0xb4, 0x01, 0x12, 0x18, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x18, 0x02, 0x03, 0x03, 0x12, 0x04, 0xb4, 0x01, 0x1b, 0x1c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x18, 0x02, 0x03, 0x08, 0x12, 0x04, 0xb4, 0x01, 0x1d, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x18, 0x02, 0x03, 0x07, 0x12, 0x04, 0xb4, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x19,
    0x12, 0x06, 0xb7, 0x01, 0x00, 0xb9, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x19, 0x01, 0x12,
    0x04, 0xb7, 0x01, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x00, 0x12, 0x04, 0xb8,
    0x01, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb8, 0x01,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb8, 0x01, 0x0b,
    0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb8, 0x01, 0x10, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb8, 0x01, 0x19, 0x1a, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x1a, 0x12, 0x06, 0xbb, 0x01, 0x00, 0xbd, 0x01, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x1a, 0x01, 0x12, 0x04, 0xbb, 0x01, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1a,
    0x02, 0x00, 0x12, 0x04, 0xbc, 0x01, 0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xbc, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00, 0x06,
    0x12, 0x04, 0xbc, 0x01, 0x0b, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xbc, 0x01, 0x1d, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xbc, 0x01, 0x26, 0x27, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x1b, 0x12, 0x06, 0xbf, 0x01, 0x00, 0xc0,
    0x01, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1b, 0x01, 0x12, 0x04, 0xbf, 0x01, 0x08, 0x24,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1c, 0x12, 0x06, 0xc2, 0x01, 0x00, 0xc5, 0x01, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x1c, 0x01, 0x12, 0x04, 0xc2, 0x01, 0x08, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x1c, 0x02, 0x00, 0x12, 0x04, 0xc3, 0x01, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xc3, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xc3, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xc3, 0x01, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xc3, 0x01, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x01, 0x12, 0x04, 0xc4,
    0x01, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc4, 0x01,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01, 0x05, 0x12, 0x04, 0xc4, 0x01, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc4, 0x01, 0x12, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc4, 0x01, 0x19, 0x1a, 0x0a,
    0x1d, 0x0a, 0x02, 0x04, 0x1d, 0x12, 0x06, 0xc7, 0x01, 0x00, 0xc8, 0x01, 0x01, 0x22, 0x0f, 0x20,
    0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x1d, 0x01, 0x12, 0x04, 0xc7, 0x01, 0x08, 0x1b, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x1e, 0x12, 0x06, 0xca, 0x01, 0x00, 0xce, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1e, 0x01,
    0x12, 0x04, 0xca, 0x01, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x00, 0x12, 0x04,
    0xcb, 0x01, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x04, 0x12, 0x04, 0xcb,
    0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x05, 0x12, 0x04, 0xcb, 0x01,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xcb, 0x01, 0x12,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcb, 0x01, 0x18, 0x19,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x01, 0x12, 0x04, 0xcc, 0x01, 0x02, 0x20, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x01, 0x04, 0x12, 0x04, 0xcc, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x01, 0x05, 0x12, 0x04, 0xcc, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x01, 0x01, 0x12, 0x04, 0xcc, 0x01, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x01, 0x03, 0x12, 0x04, 0xcc, 0x01, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e,
    0x02, 0x02, 0x12, 0x04, 0xcd, 0x01, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xcd, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02, 0x05,
    0x12, 0x04, 0xcd, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xcd, 0x01, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xcd, 0x01, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1f, 0x12, 0x06, 0xd0, 0x01, 0x00, 0xd2,
    0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1f, 0x01, 0x12, 0x04, 0xd0, 0x01, 0x08, 0x1d, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x1f, 0x02, 0x00, 0x12, 0x04, 0xd1, 0x01, 0x02, 0x1b, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1f, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd1, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1f, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd1, 0x01, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1f, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd1, 0x01, 0x10, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xd1, 0x01, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x20, 0x12,
    0x06, 0xd4, 0x01, 0x00, 0xd7, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x20, 0x01, 0x12, 0x04,
    0xd4, 0x01, 0x08, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x00, 0x12, 0x04, 0xd5, 0x01,
    0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd5, 0x01, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd5, 0x01, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd5, 0x01, 0x12, 0x15, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd5, 0x01, 0x18, 0x19, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x20, 0x02, 0x01, 0x12, 0x04, 0xd6, 0x01, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x20, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd6, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x20, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd6, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20,
    0x02, 0x01, 0x01, 0x12, 0x04, 0xd6, 0x01, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xd6, 0x01, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x21, 0x12, 0x06,
    0xd9, 0x01, 0x00, 0xdb, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x21, 0x01, 0x12, 0x04, 0xd9,
    0x01, 0x08, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x21, 0x02, 0x00, 0x12, 0x04, 0xda, 0x01, 0x02,
    0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x00, 0x04, 0x12, 0x04, 0xda, 0x01, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x00, 0x05, 0x12, 0x04, 0xda, 0x01, 0x0b, 0x0f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x00, 0x01, 0x12, 0x04, 0xda, 0x01, 0x10, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x21, 0x02, 0x00, 0x03, 0x12, 0x04, 0xda, 0x01, 0x19, 0x1a, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x22, 0x12, 0x06, 0xde, 0x01, 0x00, 0xe2, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x22, 0x01, 0x12, 0x04, 0xde, 0x01, 0x08, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x22, 0x02, 0x00,
    0x12, 0x04, 0xdf, 0x01, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xdf, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xdf, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdf,
    0x01, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00, 0x03, 0x12, 0x04, 0xdf, 0x01,
    0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x22, 0x02, 0x01, 0x12, 0x04, 0xe0, 0x01, 0x02, 0x1a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe0, 0x01, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe0, 0x01, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x22, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe0, 0x01, 0x12, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x22, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe0, 0x01, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x22, 0x02, 0x02, 0x12, 0x04, 0xe1, 0x01, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22,
    0x02, 0x02, 0x04, 0x12, 0x04, 0xe1, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02,
    0x02, 0x05, 0x12, 0x04, 0xe1, 0x01, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xe1, 0x01, 0x10, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x02, 0x03,
    0x12, 0x04, 0xe1, 0x01, 0x20, 0x21, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x23, 0x12, 0x06, 0xe4, 0x01,
    0x00, 0xe5, 0x01, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x23, 0x01, 0x12, 0x04, 0xe4, 0x01,
    0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x24, 0x12, 0x06, 0xe7, 0x01, 0x00, 0xea, 0x01, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x24, 0x01, 0x12, 0x04, 0xe7, 0x01, 0x08, 0x1a, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x24, 0x02, 0x00, 0x12, 0x04, 0xe8, 0x01, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x24, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe8, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xe8, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xe8, 0x01, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xe8, 0x01, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x24, 0x02, 0x01, 0x12,
    0x04, 0xe9, 0x01, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xe9, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe9,
    0x01, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe9, 0x01,
    0x10, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe9, 0x01, 0x1c,
    0x1d, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x25, 0x12, 0x06, 0xec, 0x01, 0x00, 0xee, 0x01, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x25, 0x01, 0x12, 0x04, 0xec, 0x01, 0x08, 0x1b, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x25, 0x02, 0x00, 0x12, 0x04, 0xed, 0x01, 0x04, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xed, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xed, 0x01, 0x0d, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xed, 0x01, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xed, 0x01, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x26, 0x12, 0x06, 0xf0, 0x01,
    0x00, 0xf4, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x26, 0x01, 0x12, 0x04, 0xf0, 0x01, 0x08,
    0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x26, 0x02, 0x00, 0x12, 0x04, 0xf1, 0x01, 0x02, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf1, 0x01, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x26, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf1, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x26, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf1, 0x01, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x26, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf1, 0x01, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x26, 0x02, 0x01, 0x12, 0x04, 0xf2, 0x01, 0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xf2, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x01,
    0x06, 0x12, 0x04, 0xf2, 0x01, 0x0b, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xf2, 0x01, 0x1d, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xf2, 0x01, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x26, 0x02, 0x02, 0x12, 0x04, 0xf3,
    0x01, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf3, 0x01,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf3, 0x01, 0x0b,
    0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf3, 0x01, 0x10, 0x1c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf3, 0x01, 0x1f, 0x20, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x27, 0x12, 0x06, 0xf5, 0x01, 0x00, 0xf7, 0x01, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x27, 0x01, 0x12, 0x04, 0xf5, 0x01, 0x08, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27,
    0x02, 0x00, 0x12, 0x04, 0xf6, 0x01, 0x04, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xf6, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xf6, 0x01, 0x0d, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xf6, 0x01, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xf6, 0x01, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x28, 0x12, 0x06, 0xf9, 0x01, 0x00, 0xfd,
    0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x28, 0x01, 0x12, 0x04, 0xf9, 0x01, 0x08, 0x1e, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x28, 0x02, 0x00, 0x12, 0x04, 0xfa, 0x01, 0x02, 0x1a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x28, 0x02, 0x00, 0x04, 0x12, 0x04, 0xfa, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x28, 0x02, 0x00, 0x05, 0x12, 0x04, 0xfa, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x28, 0x02, 0x00, 0x01, 0x12, 0x04, 0xfa, 0x01, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xfa, 0x01, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x28, 0x02,
    0x01, 0x12, 0x04, 0xfb, 0x01, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xfb, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xfb, 0x01, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xfb, 0x01, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x03, 0x12, 0x04, 0xfb,
    0x01, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x28, 0x02, 0x02, 0x12, 0x04, 0xfc, 0x01, 0x02,
    0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x02, 0x04, 0x12, 0x04, 0xfc, 0x01, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x02, 0x05, 0x12, 0x04, 0xfc, 0x01, 0x0b, 0x0f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x02, 0x01, 0x12, 0x04, 0xfc, 0x01, 0x10, 0x1c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x28, 0x02, 0x02, 0x03, 0x12, 0x04, 0xfc, 0x01, 0x1f, 0x20, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x29, 0x12, 0x06, 0xfe, 0x01, 0x00, 0x80, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x29, 0x01, 0x12, 0x04, 0xfe, 0x01, 0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x29, 0x02, 0x00,
    0x12, 0x04, 0xff, 0x01, 0x02, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xff, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x06, 0x12, 0x04,
    0xff, 0x01, 0x0b, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x01, 0x12, 0x04, 0xff,
    0x01, 0x21, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x03, 0x12, 0x04, 0xff, 0x01,
    0x2b, 0x2c, 0x0a, 0x23, 0x0a, 0x02, 0x04, 0x2a, 0x12, 0x06, 0x82, 0x02, 0x00, 0x83, 0x02, 0x01,
    0x22, 0x15, 0x20, 0x6e, 0x6f, 0x20, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x20, 0x70, 0x61, 0x72, 0x61,
    0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2a, 0x01, 0x12, 0x04,
    0x82, 0x02, 0x08, 0x2e, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x2b, 0x12, 0x06, 0x84, 0x02, 0x00, 0x86,
    0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2b, 0x01, 0x12, 0x04, 0x84, 0x02, 0x08, 0x2f, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x2b, 0x02, 0x00, 0x12, 0x04, 0x85, 0x02, 0x02, 0x47, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x2b, 0x02, 0x00, 0x04, 0x12, 0x04, 0x85, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x2b, 0x02, 0x00, 0x06, 0x12, 0x04, 0x85, 0x02, 0x0b, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2b, 0x02, 0x00, 0x01, 0x12, 0x04, 0x85, 0x02, 0x2e, 0x42, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x85, 0x02, 0x45, 0x46, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x2c, 0x12,
    0x06, 0x88, 0x02, 0x00, 0x8c, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2c, 0x01, 0x12, 0x04,
    0x88, 0x02, 0x08, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2c, 0x02, 0x00, 0x12, 0x04, 0x89, 0x02,
    0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x04, 0x12, 0x04, 0x89, 0x02, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x05, 0x12, 0x04, 0x89, 0x02, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x01, 0x12, 0x04, 0x89, 0x02, 0x12, 0x1e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x03, 0x12, 0x04, 0x89, 0x02, 0x21, 0x22, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x2c, 0x02, 0x01, 0x12, 0x04, 0x8a, 0x02, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x2c, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8a, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2c, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8a, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c,
    0x02, 0x01, 0x01, 0x12, 0x04, 0x8a, 0x02, 0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02,
    0x01, 0x03, 0x12, 0x04, 0x8a, 0x02, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2c, 0x02, 0x02,
    0x12, 0x04, 0x8b, 0x02, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x02, 0x04, 0x12,
    0x04, 0x8b, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x02, 0x05, 0x12, 0x04,
    0x8b, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x02, 0x01, 0x12, 0x04, 0x8b,
    0x02, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x02, 0x03, 0x12, 0x04, 0x8b, 0x02,
    0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x2d, 0x12, 0x06, 0x8d, 0x02, 0x00, 0x8f, 0x02, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2d, 0x01, 0x12, 0x04, 0x8d, 0x02, 0x08, 0x2a, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x2d, 0x02, 0x00, 0x12, 0x04, 0x8e, 0x02, 0x02, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2d, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8e, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d,
    0x02, 0x00, 0x06, 0x12, 0x04, 0x8e, 0x02, 0x0b, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02,
    0x00, 0x01, 0x12, 0x04, 0x8e, 0x02, 0x23, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x00,
    0x03, 0x12, 0x04, 0x8e, 0x02, 0x30, 0x31, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x2e, 0x12, 0x06, 0x91,
    0x02, 0x00, 0x93, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2e, 0x01, 0x12, 0x04, 0x91, 0x02,
    0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2e, 0x02, 0x00, 0x12, 0x04, 0x92, 0x02, 0x02, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x04, 0x12, 0x04, 0x92, 0x02, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x05, 0x12, 0x04, 0x92, 0x02, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x01, 0x12, 0x04, 0x92, 0x02, 0x12, 0x1c, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x2e, 0x02, 0x00, 0x03, 0x12, 0x04, 0x92, 0x02, 0x1f, 0x20, 0x0a, 0x1c, 0x0a, 0x02,
    0x04, 0x2f, 0x12, 0x06, 0x95, 0x02, 0x00, 0x96, 0x02, 0x01, 0x22, 0x0e, 0x76, 0x6f, 0x69, 0x64,
    0x20, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2f,
    0x01, 0x12, 0x04, 0x95, 0x02, 0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x30, 0x12, 0x06, 0x98,
    0x02, 0x00, 0x9b, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x30, 0x01, 0x12, 0x04, 0x98, 0x02,
    0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x30, 0x02, 0x00, 0x12, 0x04, 0x99, 0x02, 0x02, 0x1a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x00, 0x04, 0x12, 0x04, 0x99, 0x02, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x00, 0x05, 0x12, 0x04, 0x99, 0x02, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x30, 0x02, 0x00, 0x01, 0x12, 0x04, 0x99, 0x02, 0x12, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x30, 0x02, 0x00, 0x03, 0x12, 0x04, 0x99, 0x02, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x30, 0x02, 0x01, 0x12, 0x04, 0x9a, 0x02, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30,
    0x02, 0x01, 0x04, 0x12, 0x04, 0x9a, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02,
    0x01, 0x05, 0x12, 0x04, 0x9a, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x01,
    0x01, 0x12, 0x04, 0x9a, 0x02, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x01, 0x03,
    0x12, 0x04, 0x9a, 0x02, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x31, 0x12, 0x06, 0x9c, 0x02,
    0x00, 0x9e, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x31, 0x01, 0x12, 0x04, 0x9c, 0x02, 0x08,
    0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x31, 0x02, 0x00, 0x12, 0x04, 0x9d, 0x02, 0x02, 0x1b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9d, 0x02, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x31, 0x02, 0x00, 0x05, 0x12, 0x04, 0x9d, 0x02, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x31, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9d, 0x02, 0x10, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x31, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9d, 0x02, 0x19, 0x1a, 0x0a, 0x22, 0x0a, 0x02, 0x04,
    0x32, 0x12, 0x06, 0xa0, 0x02, 0x00, 0xa1, 0x02, 0x01, 0x22, 0x14, 0x20, 0x6e, 0x6f, 0x20, 0x69,
    0x6e, 0x70, 0x75, 0x74, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x74, 0x65, 0x72, 0x73, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x32, 0x01, 0x12, 0x04, 0xa0, 0x02, 0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x33, 0x12, 0x06, 0xa3, 0x02, 0x00, 0xab, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x33,
    0x01, 0x12, 0x04, 0xa3, 0x02, 0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02, 0x00, 0x12,
    0x04, 0xa4, 0x02, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xa4, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa4,
    0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa4, 0x02,
    0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa4, 0x02, 0x1d,
    0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02, 0x01, 0x12, 0x04, 0xa5, 0x02, 0x02, 0x1b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa5, 0x02, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x33, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa5, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x33, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa5, 0x02, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x33, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa5, 0x02, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x33, 0x02, 0x02, 0x12, 0x04, 0xa6, 0x02, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xa6, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x02,
    0x05, 0x12, 0x04, 0xa6, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xa6, 0x02, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xa6, 0x02, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02, 0x03, 0x12, 0x04, 0xa7,
    0x02, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x03, 0x04, 0x12, 0x04, 0xa7, 0x02,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x03, 0x05, 0x12, 0x04, 0xa7, 0x02, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x03, 0x01, 0x12, 0x04, 0xa7, 0x02, 0x12, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x03, 0x03, 0x12, 0x04, 0xa7, 0x02, 0x25, 0x26, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02, 0x04, 0x12, 0x04, 0xa8, 0x02, 0x02, 0x25, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x33, 0x02, 0x04, 0x04, 0x12, 0x04, 0xa8, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x33, 0x02, 0x04, 0x05, 0x12, 0x04, 0xa8, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x33, 0x02, 0x04, 0x01, 0x12, 0x04, 0xa8, 0x02, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33,
    0x02, 0x04, 0x03, 0x12, 0x04, 0xa8, 0x02, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02,
    0x05, 0x12, 0x04, 0xa9, 0x02, 0x02, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x05, 0x04,
    0x12, 0x04, 0xa9, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x05, 0x05, 0x12,
    0x04, 0xa9, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x05, 0x01, 0x12, 0x04,
    0xa9, 0x02, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x05, 0x03, 0x12, 0x04, 0xa9,
    0x02, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02, 0x06, 0x12, 0x04, 0xaa, 0x02, 0x02,
    0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x06, 0x04, 0x12, 0x04, 0xaa, 0x02, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x06, 0x05, 0x12, 0x04, 0xaa, 0x02, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x06, 0x01, 0x12, 0x04, 0xaa, 0x02, 0x12, 0x29, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x33, 0x02, 0x06, 0x03, 0x12, 0x04, 0xaa, 0x02, 0x2c, 0x2d, 0x0a, 0x2b, 0x0a,
    0x02, 0x05, 0x01, 0x12, 0x06, 0xad, 0x02, 0x00, 0xb2, 0x02, 0x01, 0x22, 0x1d, 0x20, 0x74, 0x79,
    0x70, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x6e, 0x6f,
    0x64, 0x65, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x01,
    0x01, 0x12, 0x04, 0xad, 0x02, 0x05, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x00, 0x12,
    0x04, 0xae, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xae, 0x02, 0x02, 0x05, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x00, 0x02, 0x12, 0x04, 0xae,
    0x02, 0x08, 0x09, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x01, 0x12, 0x04, 0xaf, 0x02, 0x02,
    0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xaf, 0x02, 0x02, 0x06,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x01, 0x02, 0x12, 0x04, 0xaf, 0x02, 0x09, 0x0a, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x02, 0x12, 0x04, 0xb0, 0x02, 0x02, 0x0b, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb0, 0x02, 0x02, 0x06, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x02, 0x02, 0x12, 0x04, 0xb0, 0x02, 0x09, 0x0a, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x03, 0x12, 0x04, 0xb1, 0x02, 0x02, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xb1, 0x02, 0x02, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x03,
    0x02, 0x12, 0x04, 0xb1, 0x02, 0x14, 0x15, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x34, 0x12, 0x06, 0xb4,
    0x02, 0x00, 0xb6, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x34, 0x01, 0x12, 0x04, 0xb4, 0x02,
    0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x34, 0x02, 0x00, 0x12, 0x04, 0xb5, 0x02, 0x02, 0x2c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb5, 0x02, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02, 0x00, 0x06, 0x12, 0x04, 0xb5, 0x02, 0x0b, 0x22, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x34, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb5, 0x02, 0x23, 0x27, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x34, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb5, 0x02, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x35, 0x12, 0x06, 0xb8, 0x02, 0x00, 0xba, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x35,
    0x01, 0x12, 0x04, 0xb8, 0x02, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x35, 0x02, 0x00, 0x12,
    0x04, 0xb9, 0x02, 0x02, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x35, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xb9, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x35, 0x02, 0x00, 0x06, 0x12, 0x04, 0xb9,
    0x02, 0x0b, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x35, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb9, 0x02,
    0x1d, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x35, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb9, 0x02, 0x22,
    0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x36, 0x12, 0x06, 0xbc, 0x02, 0x00, 0xbe, 0x02, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x36, 0x01, 0x12, 0x04, 0xbc, 0x02, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x36, 0x02, 0x00, 0x12, 0x04, 0xbd, 0x02, 0x02, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xbd, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02,
    0x00, 0x06, 0x12, 0x04, 0xbd, 0x02, 0x0b, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xbd, 0x02, 0x23, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xbd, 0x02, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x37, 0x12, 0x06, 0xc0, 0x02,
    0x00, 0xc3, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x37, 0x01, 0x12, 0x04, 0xc0, 0x02, 0x08,
    0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x37, 0x02, 0x00, 0x12, 0x04, 0xc1, 0x02, 0x02, 0x2e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc1, 0x02, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x37, 0x02, 0x00, 0x06, 0x12, 0x04, 0xc1, 0x02, 0x0b, 0x1c, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x37, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc1, 0x02, 0x1d, 0x29, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x37, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc1, 0x02, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x37, 0x02, 0x01, 0x12, 0x04, 0xc2, 0x02, 0x02, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xc2, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x01,
    0x06, 0x12, 0x04, 0xc2, 0x02, 0x0b, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xc2, 0x02, 0x1e, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xc2, 0x02, 0x2f, 0x30, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x38, 0x12, 0x06, 0xc5, 0x02, 0x00,
    0xc7, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x38, 0x01, 0x12, 0x04, 0xc5, 0x02, 0x08, 0x2d,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x38, 0x02, 0x00, 0x12, 0x04, 0xc6, 0x02, 0x02, 0x41, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x38, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc6, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x38, 0x02, 0x00, 0x06, 0x12, 0x04, 0xc6, 0x02, 0x0b, 0x25, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x38, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc6, 0x02, 0x26, 0x3c, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x38, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc6, 0x02, 0x3f, 0x40, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x39,
    0x12, 0x06, 0xc9, 0x02, 0x00, 0xcb, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x39, 0x01, 0x12,
    0x04, 0xc9, 0x02, 0x08, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x39, 0x02, 0x00, 0x12, 0x04, 0xca,
    0x02, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x39, 0x02, 0x00, 0x04, 0x12, 0x04, 0xca, 0x02,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x39, 0x02, 0x00, 0x05, 0x12, 0x04, 0xca, 0x02, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x39, 0x02, 0x00, 0x01, 0x12, 0x04, 0xca, 0x02, 0x12, 0x1a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x39, 0x02, 0x00, 0x03, 0x12, 0x04, 0xca, 0x02, 0x1d, 0x1e, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x3a, 0x12, 0x06, 0xcd, 0x02, 0x00, 0xcf, 0x02, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x3a, 0x01, 0x12, 0x04, 0xcd, 0x02, 0x08, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3a,
    0x02, 0x00, 0x12, 0x04, 0xce, 0x02, 0x02, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xce, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xce, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xce, 0x02, 0x12, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xce, 0x02, 0x1a, 0x1b, 0x0a, 0x0c, 0x0a, 0x02, 0x05, 0x02, 0x12, 0x06, 0xd1, 0x02, 0x00, 0xd5,
    0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x02, 0x01, 0x12, 0x04, 0xd1, 0x02, 0x05, 0x18, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x00, 0x12, 0x04, 0xd2, 0x02, 0x02, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd2, 0x02, 0x02, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x02, 0x02, 0x00, 0x02, 0x12, 0x04, 0xd2, 0x02, 0x13, 0x14, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xd3, 0x02, 0x02, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xd3, 0x02, 0x02, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x01,
    0x02, 0x12, 0x04, 0xd3, 0x02, 0x13, 0x14, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x02, 0x12,
    0x04, 0xd4, 0x02, 0x02, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xd4, 0x02, 0x02, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x02, 0x02, 0x12, 0x04, 0xd4,
    0x02, 0x11, 0x12, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x3b, 0x12, 0x06, 0xd7, 0x02, 0x00, 0xda, 0x02,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x3b, 0x01, 0x12, 0x04, 0xd7, 0x02, 0x08, 0x1f, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x3b, 0x02, 0x00, 0x12, 0x04, 0xd8, 0x02, 0x02, 0x2a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x3b, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd8, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x3b, 0x02, 0x00, 0x06, 0x12, 0x04, 0xd8, 0x02, 0x0b, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3b,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xd8, 0x02, 0x1f, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3b, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xd8, 0x02, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3b, 0x02, 0x01,
    0x12, 0x04, 0xd9, 0x02, 0x02, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3b, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xd9, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3b, 0x02, 0x01, 0x05, 0x12, 0x04,
    0xd9, 0x02, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3b, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd9,
    0x02, 0x10, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3b, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd9, 0x02,
    0x1a, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3b, 0x02, 0x01, 0x08, 0x12, 0x04, 0xd9, 0x02, 0x1c,
    0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3b, 0x02, 0x01, 0x07, 0x12, 0x04, 0xd9, 0x02, 0x27, 0x2c,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x3c, 0x12, 0x06, 0xdc, 0x02, 0x00, 0xde, 0x02, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x3c, 0x01, 0x12, 0x04, 0xdc, 0x02, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x3c, 0x02, 0x00, 0x12, 0x04, 0xdd, 0x02, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xdd, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xdd, 0x02, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xdd, 0x02, 0x10, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xdd, 0x02, 0x19, 0x1a, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x3d, 0x12, 0x06, 0xe0, 0x02, 0x00,
    0xe1, 0x02, 0x01, 0x22, 0x0f, 0x20, 0x6e, 0x6f, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
    0x65, 0x72, 0x73, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x3d, 0x01, 0x12, 0x04, 0xe0, 0x02, 0x08,
    0x21, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x3e, 0x12, 0x06, 0xe3, 0x02, 0x00, 0xe4, 0x02, 0x01, 0x22,
    0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x0a,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x3e, 0x01, 0x12, 0x04, 0xe3, 0x02, 0x08, 0x22, 0x0a, 0x1d, 0x0a,
    0x02, 0x04, 0x3f, 0x12, 0x06, 0xe6, 0x02, 0x00, 0xe7, 0x02, 0x01, 0x22, 0x0f, 0x20, 0x6e, 0x6f,
    0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x0a, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x3f, 0x01, 0x12, 0x04, 0xe6, 0x02, 0x08, 0x1d, 0x0a, 0x18, 0x0a, 0x02, 0x04, 0x40, 0x12,
    0x06, 0xe9, 0x02, 0x00, 0xeb, 0x02, 0x01, 0x22, 0x0a, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x40, 0x01, 0x12, 0x04, 0xe9, 0x02, 0x08, 0x1e,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x40, 0x02, 0x00, 0x12, 0x04, 0xea, 0x02, 0x02, 0x25, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x40, 0x02, 0x00, 0x04, 0x12, 0x04, 0xea, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x40, 0x02, 0x00, 0x05, 0x12, 0x04, 0xea, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x40, 0x02, 0x00, 0x01, 0x12, 0x04, 0xea, 0x02, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x40, 0x02, 0x00, 0x03, 0x12, 0x04, 0xea, 0x02, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x41,
    0x12, 0x06, 0xed, 0x02, 0x00, 0xef, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x41, 0x01, 0x12,
    0x04, 0xed, 0x02, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x41, 0x02, 0x00, 0x12, 0x04, 0xee,
    0x02, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x41, 0x02, 0x00, 0x04, 0x12, 0x04, 0xee, 0x02,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x41, 0x02, 0x00, 0x05, 0x12, 0x04, 0xee, 0x02, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x41, 0x02, 0x00, 0x01, 0x12, 0x04, 0xee, 0x02, 0x12, 0x15,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x41, 0x02, 0x00, 0x03, 0x12, 0x04, 0xee, 0x02, 0x18, 0x19, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x42, 0x12, 0x06, 0xf1, 0x02, 0x00, 0xf3, 0x02, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x42, 0x01, 0x12, 0x04, 0xf1, 0x02, 0x08, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x42,
    0x02, 0x00, 0x12, 0x04, 0xf2, 0x02, 0x04, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xf2, 0x02, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xf2, 0x02, 0x0d, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xf2, 0x02, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xf2, 0x02, 0x1b, 0x1c, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x43, 0x12, 0x06, 0xf5, 0x02, 0x00, 0xf6,
    0x02, 0x01, 0x22, 0x0f, 0x20, 0x6e, 0x6f, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
    0x72, 0x73, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x43, 0x01, 0x12, 0x04, 0xf5, 0x02, 0x08, 0x20,
    0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x44, 0x12, 0x06, 0xf8, 0x02, 0x00, 0xf9, 0x02, 0x01, 0x22, 0x0f,
    0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x44, 0x01, 0x12, 0x04, 0xf8, 0x02, 0x08, 0x21, 0x0a, 0x1d, 0x0a, 0x02,
    0x04, 0x45, 0x12, 0x06, 0xfb, 0x02, 0x00, 0xfc, 0x02, 0x01, 0x22, 0x0f, 0x20, 0x6e, 0x6f, 0x20,
    0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x45, 0x01, 0x12, 0x04, 0xfb, 0x02, 0x08, 0x23, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x46, 0x12, 0x06,
    0xfe, 0x02, 0x00, 0xff, 0x02, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x46, 0x01, 0x12, 0x04,
    0xfe, 0x02, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x02, 0x05, 0x03, 0x12, 0x06, 0x81, 0x03, 0x00, 0x85,
    0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x03, 0x01, 0x12, 0x04, 0x81, 0x03, 0x05, 0x1e, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x00, 0x12, 0x04, 0x82, 0x03, 0x02, 0x0c, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x03, 0x02, 0x00, 0x01, 0x12, 0x04, 0x82, 0x03, 0x02, 0x07, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x03, 0x02, 0x00, 0x02, 0x12, 0x04, 0x82, 0x03, 0x0a, 0x0b, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x03, 0x02, 0x01, 0x12, 0x04, 0x83, 0x03, 0x02, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02,
    0x01, 0x01, 0x12, 0x04, 0x83, 0x03, 0x02, 0x07, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x01,
    0x02, 0x12, 0x04, 0x83, 0x03, 0x0a, 0x0b, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x02, 0x12,
    0x04, 0x84, 0x03, 0x02, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x02, 0x01, 0x12, 0x04,
    0x84, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x02, 0x02, 0x12, 0x04, 0x84,
    0x03, 0x0d, 0x0e, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x47, 0x12, 0x06, 0x87, 0x03, 0x00, 0x89, 0x03,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x47, 0x01, 0x12, 0x04, 0x87, 0x03, 0x08, 0x22, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x47, 0x02, 0x00, 0x12, 0x04, 0x88, 0x03, 0x02, 0x30, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x47, 0x02, 0x00, 0x04, 0x12, 0x04, 0x88, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x47, 0x02, 0x00, 0x06, 0x12, 0x04, 0x88, 0x03, 0x0b, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47,
    0x02, 0x00, 0x01, 0x12, 0x04, 0x88, 0x03, 0x25, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02,
    0x00, 0x03, 0x12, 0x04, 0x88, 0x03, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x48, 0x12, 0x06,
    0x8b, 0x03, 0x00, 0x90, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x48, 0x01, 0x12, 0x04, 0x8b,
    0x03, 0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x48, 0x02, 0x00, 0x12, 0x04, 0x8c, 0x03, 0x02,
    0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8c, 0x03, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x00, 0x06, 0x12, 0x04, 0x8c, 0x03, 0x0b, 0x24, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8c, 0x03, 0x25, 0x2b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x48, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8c, 0x03, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x48, 0x02, 0x01, 0x12, 0x04, 0x8d, 0x03, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x48, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8d, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48,
    0x02, 0x01, 0x05, 0x12, 0x04, 0x8d, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02,
    0x01, 0x01, 0x12, 0x04, 0x8d, 0x03, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x01,
    0x03, 0x12, 0x04, 0x8d, 0x03, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x48, 0x02, 0x02, 0x12,
    0x04, 0x8e, 0x03, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x02, 0x04, 0x12, 0x04,
    0x8e, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x02, 0x05, 0x12, 0x04, 0x8e,
    0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x02, 0x01, 0x12, 0x04, 0x8e, 0x03,
    0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x02, 0x03, 0x12, 0x04, 0x8e, 0x03, 0x21,
    0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x48, 0x02, 0x03, 0x12, 0x04, 0x8f, 0x03, 0x02, 0x2a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x03, 0x04, 0x12, 0x04, 0x8f, 0x03, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x48, 0x02, 0x03, 0x05, 0x12, 0x04, 0x8f, 0x03, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x48, 0x02, 0x03, 0x01, 0x12, 0x04, 0x8f, 0x03, 0x10, 0x25, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x48, 0x02, 0x03, 0x03, 0x12, 0x04, 0x8f, 0x03, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x49, 0x12, 0x06, 0x92, 0x03, 0x00, 0x94, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x49, 0x01,
    0x12, 0x04, 0x92, 0x03, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x49, 0x02, 0x00, 0x12, 0x04,
    0x93, 0x03, 0x02, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x00, 0x04, 0x12, 0x04, 0x93,
    0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x00, 0x06, 0x12, 0x04, 0x93, 0x03,
    0x0b, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x00, 0x01, 0x12, 0x04, 0x93, 0x03, 0x23,
    0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x00, 0x03, 0x12, 0x04, 0x93, 0x03, 0x37, 0x38,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x4a, 0x12, 0x06, 0x96, 0x03, 0x00, 0x99, 0x03, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x4a, 0x01, 0x12, 0x04, 0x96, 0x03, 0x08, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x4a, 0x02, 0x00, 0x12, 0x04, 0x97, 0x03, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02,
    0x00, 0x04, 0x12, 0x04, 0x97, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x00,
    0x05, 0x12, 0x04, 0x97, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x00, 0x01,
    0x12, 0x04, 0x97, 0x03, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x00, 0x03, 0x12,
    0x04, 0x97, 0x03, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4a, 0x02, 0x01, 0x12, 0x04, 0x98,
    0x03, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x01, 0x04, 0x12, 0x04, 0x98, 0x03,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x01, 0x05, 0x12, 0x04, 0x98, 0x03, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x01, 0x01, 0x12, 0x04, 0x98, 0x03, 0x12, 0x18,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x01, 0x03, 0x12, 0x04, 0x98, 0x03, 0x1b, 0x1c, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x4b, 0x12, 0x06, 0x9b, 0x03, 0x00, 0x9d, 0x03, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x4b, 0x01, 0x12, 0x04, 0x9b, 0x03, 0x08, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4b,
    0x02, 0x00, 0x12, 0x04, 0x9c, 0x03, 0x02, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b, 0x02, 0x00,
    0x04, 0x12, 0x04, 0x9c, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b, 0x02, 0x00, 0x06,
    0x12, 0x04, 0x9c, 0x03, 0x0b, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b, 0x02, 0x00, 0x01, 0x12,
    0x04, 0x9c, 0x03, 0x22, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b, 0x02, 0x00, 0x03, 0x12, 0x04,
    0x9c, 0x03, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x4c, 0x12, 0x06, 0x9f, 0x03, 0x00, 0xa1,
    0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x4c, 0x01, 0x12, 0x04, 0x9f, 0x03, 0x08, 0x1c, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x4c, 0x02, 0x00, 0x12, 0x04, 0xa0, 0x03, 0x02, 0x1f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x4c, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa0, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x4c, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa0, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x4c, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa0, 0x03, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4c,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xa0, 0x03, 0x1d, 0x1e, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x4d, 0x12,
    0x06, 0xa3, 0x03, 0x00, 0xa4, 0x03, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x72,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x4d, 0x01, 0x12,
    0x04, 0xa3, 0x03, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x4e, 0x12, 0x06, 0xa6, 0x03, 0x00,
    0xa8, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x4e, 0x01, 0x12, 0x04, 0xa6, 0x03, 0x08, 0x1f,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4e, 0x02, 0x00, 0x12, 0x04, 0xa7, 0x03, 0x02, 0x1a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x4e, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa7, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x4e, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa7, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x4e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa7, 0x03, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x4e, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa7, 0x03, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x4f,
    0x12, 0x06, 0xaa, 0x03, 0x00, 0xac, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x4f, 0x01, 0x12,
    0x04, 0xaa, 0x03, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4f, 0x02, 0x00, 0x12, 0x04, 0xab,
    0x03, 0x02, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4f, 0x02, 0x00, 0x04, 0x12, 0x04, 0xab, 0x03,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4f, 0x02, 0x00, 0x06, 0x12, 0x04, 0xab, 0x03, 0x0b,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4f, 0x02, 0x00, 0x01, 0x12, 0x04, 0xab, 0x03, 0x1f, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4f, 0x02, 0x00, 0x03, 0x12, 0x04, 0xab, 0x03, 0x24, 0x25, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x50, 0x12, 0x06, 0xae, 0x03, 0x00, 0xb0, 0x03, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x50, 0x01, 0x12, 0x04, 0xae, 0x03, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x50,
    0x02, 0x00, 0x12, 0x04, 0xaf, 0x03, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x50, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xaf, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x50, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xaf, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x50, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xaf, 0x03, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x50, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xaf, 0x03, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x51, 0x12, 0x06, 0xb2, 0x03, 0x00, 0xb4,
    0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x51, 0x01, 0x12, 0x04, 0xb2, 0x03, 0x08, 0x21, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x51, 0x02, 0x00, 0x12, 0x04, 0xb3, 0x03, 0x02, 0x1b, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x51, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb3, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x51, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb3, 0x03, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x51, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb3, 0x03, 0x10, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x51,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xb3, 0x03, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x52, 0x12,
    0x06, 0xb6, 0x03, 0x00, 0xbc, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x52, 0x01, 0x12, 0x04,
    0xb6, 0x03, 0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x52, 0x02, 0x00, 0x12, 0x04, 0xb7, 0x03,
    0x02, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb7, 0x03, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb7, 0x03, 0x0b, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb7, 0x03, 0x11, 0x13, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb7, 0x03, 0x16, 0x17, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x52, 0x02, 0x01, 0x12, 0x04, 0xb8, 0x03, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x52, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb8, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x52, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb8, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52,
    0x02, 0x01, 0x01, 0x12, 0x04, 0xb8, 0x03, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xb8, 0x03, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x52, 0x02, 0x02,
    0x12, 0x04, 0xb9, 0x03, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x02, 0x04, 0x12,
    0x04, 0xb9, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x02, 0x05, 0x12, 0x04,
    0xb9, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb9,
    0x03, 0x12, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb9, 0x03,
    0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x52, 0x02, 0x03, 0x12, 0x04, 0xba, 0x03, 0x02, 0x1b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x03, 0x04, 0x12, 0x04, 0xba, 0x03, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x03, 0x05, 0x12, 0x04, 0xba, 0x03, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x52, 0x02, 0x03, 0x01, 0x12, 0x04, 0xba, 0x03, 0x12, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x52, 0x02, 0x03, 0x03, 0x12, 0x04, 0xba, 0x03, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x52, 0x02, 0x04, 0x12, 0x04, 0xbb, 0x03, 0x02, 0x3c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52,
    0x02, 0x04, 0x04, 0x12, 0x04, 0xbb, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02,
    0x04, 0x06, 0x12, 0x04, 0xbb, 0x03, 0x0b, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x04,
    0x01, 0x12, 0x04, 0xbb, 0x03, 0x2d, 0x37, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x04, 0x03,
    0x12, 0x04, 0xbb, 0x03, 0x3a, 0x3b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x53, 0x12, 0x06, 0xbe, 0x03,
    0x00, 0xc1, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x53, 0x01, 0x12, 0x04, 0xbe, 0x03, 0x08,
    0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x53, 0x02, 0x00, 0x12, 0x04, 0xbf, 0x03, 0x02, 0x1c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x00, 0x04, 0x12, 0x04, 0xbf, 0x03, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x53, 0x02, 0x00, 0x05, 0x12, 0x04, 0xbf, 0x03, 0x0b, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x53, 0x02, 0x00, 0x01, 0x12, 0x04, 0xbf, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x53, 0x02, 0x00, 0x03, 0x12, 0x04, 0xbf, 0x03, 0x1a, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x53, 0x02, 0x01, 0x12, 0x04, 0xc0, 0x03, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xc0, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xc0, 0x03, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xc0, 0x03, 0x10, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xc0, 0x03, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x54, 0x12, 0x06, 0xc3, 0x03, 0x00,
    0xc9, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x54, 0x01, 0x12, 0x04, 0xc3, 0x03, 0x08, 0x20,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x54, 0x02, 0x00, 0x12, 0x04, 0xc4, 0x03, 0x02, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x54, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc4, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x54, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc4, 0x03, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x54, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc4, 0x03, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x54, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc4, 0x03, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x54,
    0x02, 0x01, 0x12, 0x04, 0xc5, 0x03, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x01,
    0x04, 0x12, 0x04, 0xc5, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x01, 0x05,
    0x12, 0x04, 0xc5, 0x03, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xc5, 0x03, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xc5, 0x03, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x54, 0x02, 0x02, 0x12, 0x04, 0xc6, 0x03,
    0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc6, 0x03, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x02, 0x05, 0x12, 0x04, 0xc6, 0x03, 0x0b, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc6, 0x03, 0x11, 0x1c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc6, 0x03, 0x1f, 0x20, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x54, 0x02, 0x03, 0x12, 0x04, 0xc7, 0x03, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x54, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc7, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x54, 0x02, 0x03, 0x05, 0x12, 0x04, 0xc7, 0x03, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54,
    0x02, 0x03, 0x01, 0x12, 0x04, 0xc7, 0x03, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02,
    0x03, 0x03, 0x12, 0x04, 0xc7, 0x03, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x54, 0x02, 0x04,
    0x12, 0x04, 0xc8, 0x03, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x04, 0x04, 0x12,
    0x04, 0xc8, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x04, 0x05, 0x12, 0x04,
    0xc8, 0x03, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x04, 0x01, 0x12, 0x04, 0xc8,
    0x03, 0x10, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x04, 0x03, 0x12, 0x04, 0xc8, 0x03,
    0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x02, 0x05, 0x04, 0x12, 0x06, 0xcb, 0x03, 0x00, 0xcd, 0x03, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x04, 0x01, 0x12, 0x04, 0xcb, 0x03, 0x05, 0x13, 0x0a, 0x2b, 0x0a,
    0x04, 0x05, 0x04, 0x02, 0x00, 0x12, 0x04, 0xcc, 0x03, 0x02, 0x0f, 0x22, 0x1d, 0x20, 0x49, 0x67,
    0x6e, 0x6f, 0x72, 0x65, 0x20, 0x70, 0x6f, 0x6f, 0x6c, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72,
    0x63, 0x65, 0x20, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xcc, 0x03, 0x02, 0x07, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02,
    0x00, 0x02, 0x12, 0x04, 0xcc, 0x03, 0x0a, 0x0e, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x55, 0x12, 0x06,
    0xcf, 0x03, 0x00, 0xd2, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x55, 0x01, 0x12, 0x04, 0xcf,
    0x03, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x55, 0x02, 0x00, 0x12, 0x04, 0xd0, 0x03, 0x02,
    0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd0, 0x03, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02, 0x00, 0x06, 0x12, 0x04, 0xd0, 0x03, 0x0b, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd0, 0x03, 0x23, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x55, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd0, 0x03, 0x2a, 0x2b, 0x0a, 0x28, 0x0a,
    0x04, 0x04, 0x55, 0x02, 0x01, 0x12, 0x04, 0xd1, 0x03, 0x02, 0x21, 0x22, 0x1a, 0x20, 0x62, 0x69,
    0x74, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x43, 0x61, 0x63,
    0x68, 0x65, 0x46, 0x6c, 0x61, 0x67, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xd1, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xd1, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xd1, 0x03, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd1,
    0x03, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x56, 0x12, 0x06, 0xd4, 0x03, 0x00, 0xd6, 0x03,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x56, 0x01, 0x12, 0x04, 0xd4, 0x03, 0x08, 0x26, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x56, 0x02, 0x00, 0x12, 0x04, 0xd5, 0x03, 0x02, 0x18, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x56, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd5, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x56, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd5, 0x03, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x56,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xd5, 0x03, 0x11, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x56, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xd5, 0x03, 0x16, 0x17, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x57, 0x12, 0x06,
    0xd8, 0x03, 0x00, 0xdb, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x57, 0x01, 0x12, 0x04, 0xd8,
    0x03, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x57, 0x02, 0x00, 0x12, 0x04, 0xd9, 0x03, 0x02,
    0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x57, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd9, 0x03, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x57, 0x02, 0x00, 0x06, 0x12, 0x04, 0xd9, 0x03, 0x0b, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x57, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd9, 0x03, 0x23, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x57, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd9, 0x03, 0x2a, 0x2b, 0x0a, 0x28, 0x0a,
    0x04, 0x04, 0x57, 0x02, 0x01, 0x12, 0x04, 0xda, 0x03, 0x02, 0x21, 0x22, 0x1a, 0x20, 0x62, 0x69,
    0x74, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x43, 0x61, 0x63,
    0x68, 0x65, 0x46, 0x6c, 0x61, 0x67, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x57, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xda, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x57, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xda, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x57, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xda, 0x03, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x57, 0x02, 0x01, 0x03, 0x12, 0x04, 0xda,
    0x03, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x58, 0x12, 0x06, 0xdd, 0x03, 0x00, 0xde, 0x03,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x58, 0x01, 0x12, 0x04, 0xdd, 0x03, 0x08, 0x29, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x59, 0x12, 0x06, 0xe0, 0x03, 0x00, 0xe2, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x59, 0x01, 0x12, 0x04, 0xe0, 0x03, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x59, 0x02,
    0x00, 0x12, 0x04, 0xe1, 0x03, 0x02, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xe1, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xe1, 0x03, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xe1, 0x03, 0x11, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe1,
    0x03, 0x16, 0x17, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x5a, 0x12, 0x06, 0xe4, 0x03, 0x00, 0xe5, 0x03,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x5a, 0x01, 0x12, 0x04, 0xe4, 0x03, 0x08, 0x29, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x5b, 0x12, 0x06, 0xe7, 0x03, 0x00, 0xea, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x5b, 0x01, 0x12, 0x04, 0xe7, 0x03, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5b, 0x02,
    0x00, 0x12, 0x04, 0xe8, 0x03, 0x02, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5b, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xe8, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5b, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xe8, 0x03, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5b, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xe8, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5b, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe8,
    0x03, 0x1a, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5b, 0x02, 0x01, 0x12, 0x04, 0xe9, 0x03, 0x02,
    0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5b, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe9, 0x03, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5b, 0x02, 0x01, 0x06, 0x12, 0x04, 0xe9, 0x03, 0x0b, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x5b, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe9, 0x03, 0x23, 0x29, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x5b, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe9, 0x03, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x5c, 0x12, 0x06, 0xec, 0x03, 0x00, 0xef, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x5c, 0x01, 0x12, 0x04, 0xec, 0x03, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5c, 0x02, 0x00,
    0x12, 0x04, 0xed, 0x03, 0x02, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5c, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xed, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5c, 0x02, 0x00, 0x06, 0x12, 0x04,
    0xed, 0x03, 0x0b, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5c, 0x02, 0x00, 0x01, 0x12, 0x04, 0xed,
    0x03, 0x23, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5c, 0x02, 0x00, 0x03, 0x12, 0x04, 0xed, 0x03,
    0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5c, 0x02, 0x01, 0x12, 0x04, 0xee, 0x03, 0x02, 0x2e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5c, 0x02, 0x01, 0x04, 0x12, 0x04, 0xee, 0x03, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x5c, 0x02, 0x01, 0x06, 0x12, 0x04, 0xee, 0x03, 0x0b, 0x23, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x5c, 0x02, 0x01, 0x01, 0x12, 0x04, 0xee, 0x03, 0x24, 0x29, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x5c, 0x02, 0x01, 0x03, 0x12, 0x04, 0xee, 0x03, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x5d, 0x12, 0x06, 0xf1, 0x03, 0x00, 0xf4, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x5d,
    0x01, 0x12, 0x04, 0xf1, 0x03, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5d, 0x02, 0x00, 0x12,
    0x04, 0xf2, 0x03, 0x02, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5d, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xf2, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5d, 0x02, 0x00, 0x06, 0x12, 0x04, 0xf2,
    0x03, 0x0b, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5d, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf2, 0x03,
    0x24, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5d, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf2, 0x03, 0x2f,
    0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5d, 0x02, 0x01, 0x12, 0x04, 0xf3, 0x03, 0x02, 0x1c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x5d, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf3, 0x03, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x5d, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf3, 0x03, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x5d, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf3, 0x03, 0x10, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x5d, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf3, 0x03, 0x1a, 0x1b, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x5e, 0x12, 0x06, 0xf6, 0x03, 0x00, 0xfd, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x5e, 0x01,
    0x12, 0x04, 0xf6, 0x03, 0x08, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5e, 0x02, 0x00, 0x12, 0x04,
    0xf7, 0x03, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf7,
    0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf7, 0x03,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf7, 0x03, 0x12,
    0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf7, 0x03, 0x1d, 0x1e,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5e, 0x02, 0x01, 0x12, 0x04, 0xf8, 0x03, 0x02, 0x20, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x5e, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf8, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x5e, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf8, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x5e, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf8, 0x03, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x5e, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf8, 0x03, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5e,
    0x02, 0x02, 0x12, 0x04, 0xf9, 0x03, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xf9, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x02, 0x05,
    0x12, 0x04, 0xf9, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xf9, 0x03, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xf9, 0x03, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5e, 0x02, 0x03, 0x12, 0x04, 0xfa, 0x03,
    0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x03, 0x04, 0x12, 0x04, 0xfa, 0x03, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x03, 0x05, 0x12, 0x04, 0xfa, 0x03, 0x0b, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x03, 0x01, 0x12, 0x04, 0xfa, 0x03, 0x11, 0x15, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x03, 0x03, 0x12, 0x04, 0xfa, 0x03, 0x18, 0x19, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x5e, 0x02, 0x04, 0x12, 0x04, 0xfb, 0x03, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x5e, 0x02, 0x04, 0x04, 0x12, 0x04, 0xfb, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x5e, 0x02, 0x04, 0x05, 0x12, 0x04, 0xfb, 0x03, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xfb, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02,
    0x04, 0x03, 0x12, 0x04, 0xfb, 0x03, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5e, 0x02, 0x05,
    0x12, 0x04, 0xfc, 0x03, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x05, 0x04, 0x12,
    0x04, 0xfc, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x05, 0x05, 0x12, 0x04,
    0xfc, 0x03, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x05, 0x01, 0x12, 0x04, 0xfc,
    0x03, 0x11, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x05, 0x03, 0x12, 0x04, 0xfc, 0x03,
    0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x5f, 0x12, 0x06, 0xff, 0x03, 0x00, 0x85, 0x04, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x5f, 0x01, 0x12, 0x04, 0xff, 0x03, 0x08, 0x1b, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x5f, 0x02, 0x00, 0x12, 0x04, 0x80, 0x04, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x5f, 0x02, 0x00, 0x04, 0x12, 0x04, 0x80, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f,
    0x02, 0x00, 0x05, 0x12, 0x04, 0x80, 0x04, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f, 0x02,
    0x00, 0x01, 0x12, 0x04, 0x80, 0x04, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f, 0x02, 0x00,
    0x03, 0x12, 0x04, 0x80, 0x04, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5f, 0x02, 0x01, 0x12,
    0x04, 0x81, 0x04, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f, 0x02, 0x01, 0x04, 0x12, 0x04,
    0x81, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f, 0x02, 0x01, 0x05, 0x12, 0x04, 0x81,
    0x04, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f, 0x02, 0x01, 0x01, 0x12, 0x04, 0x81, 0x04,
    0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f, 0x02, 0x01, 0x03, 0x12, 0x04, 0x81, 0x04, 0x1f,
    0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5f, 0x02, 0x02, 0x12, 0x04, 0x82, 0x04, 0x02, 0x24, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x5f, 0x02, 0x02, 0x04, 0x12, 0x04, 0x82, 0x04, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x5f, 0x02, 0x02, 0x05, 0x12, 0x04, 0x82, 0x04, 0x0b, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x5f, 0x02, 0x02, 0x01, 0x12, 0x04, 0x82, 0x04, 0x11, 0x1f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x5f, 0x02, 0x02, 0x03, 0x12, 0x04, 0x82, 0x04, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x5f, 0x02, 0x03, 0x12, 0x04, 0x83, 0x04, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f, 0x02,
    0x03, 0x04, 0x12, 0x04, 0x83, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f, 0x02, 0x03,
    0x05, 0x12, 0x04, 0x83, 0x04, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f, 0x02, 0x03, 0x01,
    0x12, 0x04, 0x83, 0x04, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f, 0x02, 0x03, 0x03, 0x12,
    0x04, 0x83, 0x04, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5f, 0x02, 0x04, 0x12, 0x04, 0x84,
    0x04, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f, 0x02, 0x04, 0x04, 0x12, 0x04, 0x84, 0x04,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f, 0x02, 0x04, 0x05, 0x12, 0x04, 0x84, 0x04, 0x0b,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f, 0x02, 0x04, 0x01, 0x12, 0x04, 0x84, 0x04, 0x11, 0x1c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f, 0x02, 0x04, 0x03, 0x12, 0x04, 0x84, 0x04, 0x1f, 0x20, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x60, 0x12, 0x06, 0x87, 0x04, 0x00, 0x89, 0x04, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x60, 0x01, 0x12, 0x04, 0x87, 0x04, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x60,
    0x02, 0x00, 0x12, 0x04, 0x88, 0x04, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x60, 0x02, 0x00,
    0x04, 0x12, 0x04, 0x88, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x60, 0x02, 0x00, 0x06,
    0x12, 0x04, 0x88, 0x04, 0x0b, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x60, 0x02, 0x00, 0x01, 0x12,
    0x04, 0x88, 0x04, 0x1e, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x60, 0x02, 0x00, 0x03, 0x12, 0x04,
    0x88, 0x04, 0x25, 0x26, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x61, 0x12, 0x06, 0x8b, 0x04, 0x00, 0x8c,
    0x04, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x61, 0x01, 0x12, 0x04, 0x8b, 0x04, 0x08, 0x21,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x62, 0x12, 0x06, 0x8e, 0x04, 0x00, 0x90, 0x04, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x62, 0x01, 0x12, 0x04, 0x8e, 0x04, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x62, 0x02, 0x00, 0x12, 0x04, 0x8f, 0x04, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02,
    0x00, 0x04, 0x12, 0x04, 0x8f, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x00,
    0x06, 0x12, 0x04, 0x8f, 0x04, 0x0b, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x00, 0x01,
    0x12, 0x04, 0x8f, 0x04, 0x1e, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x00, 0x03, 0x12,
    0x04, 0x8f, 0x04, 0x25, 0x26, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x63, 0x12, 0x06, 0x92, 0x04, 0x00,
    0x93, 0x04, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x63, 0x01, 0x12, 0x04, 0x92, 0x04, 0x08,
    0x24, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x64, 0x12, 0x06, 0x95, 0x04, 0x00, 0x97, 0x04, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x64, 0x01, 0x12, 0x04, 0x95, 0x04, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x64, 0x02, 0x00, 0x12, 0x04, 0x96, 0x04, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x64,
    0x02, 0x00, 0x04, 0x12, 0x04, 0x96, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x64, 0x02,
    0x00, 0x05, 0x12, 0x04, 0x96, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x64, 0x02, 0x00,
    0x01, 0x12, 0x04, 0x96, 0x04, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x64, 0x02, 0x00, 0x03,
    0x12, 0x04, 0x96, 0x04, 0x1d, 0x1e, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x65, 0x12, 0x06, 0x99, 0x04,
    0x00, 0x9a, 0x04, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x65, 0x01, 0x12, 0x04, 0x99, 0x04,
    0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x66, 0x12, 0x06, 0x9c, 0x04, 0x00, 0x9e, 0x04, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x66, 0x01, 0x12, 0x04, 0x9c, 0x04, 0x08, 0x22, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x66, 0x02, 0x00, 0x12, 0x04, 0x9d, 0x04, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x66, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9d, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x66,
    0x02, 0x00, 0x05, 0x12, 0x04, 0x9d, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x66, 0x02,
    0x00, 0x01, 0x12, 0x04, 0x9d, 0x04, 0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x66, 0x02, 0x00,
    0x03, 0x12, 0x04, 0x9d, 0x04, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x67, 0x12, 0x06, 0xa0,
    0x04, 0x00, 0xa3, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x67, 0x01, 0x12, 0x04, 0xa0, 0x04,
    0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x67, 0x02, 0x00, 0x12, 0x04, 0xa1, 0x04, 0x02, 0x2b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x67, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa1, 0x04, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x67, 0x02, 0x00, 0x06, 0x12, 0x04, 0xa1, 0x04, 0x0b, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x67, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa1, 0x04, 0x1f, 0x26, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x67, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa1, 0x04, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x67, 0x02, 0x01, 0x12, 0x04, 0xa2, 0x04, 0x02, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x67,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xa2, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x67, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xa2, 0x04, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x67, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xa2, 0x04, 0x10, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x67, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xa2, 0x04, 0x1a, 0x1b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x68, 0x12, 0x06, 0xa5, 0x04,
    0x00, 0xa8, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x68, 0x01, 0x12, 0x04, 0xa5, 0x04, 0x08,
    0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x68, 0x02, 0x00, 0x12, 0x04, 0xa6, 0x04, 0x02, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x68, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa6, 0x04, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x68, 0x02, 0x00, 0x06, 0x12, 0x04, 0xa6, 0x04, 0x0b, 0x1d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x68, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa6, 0x04, 0x1e, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x68, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa6, 0x04, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x68, 0x02, 0x01, 0x12, 0x04, 0xa7, 0x04, 0x02, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x68, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xa7, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x68, 0x02, 0x01,
    0x06, 0x12, 0x04, 0xa7, 0x04, 0x0b, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x68, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xa7, 0x04, 0x1f, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x68, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xa7, 0x04, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x69, 0x12, 0x06, 0xaa, 0x04, 0x00,
    0xac, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x69, 0x01, 0x12, 0x04, 0xaa, 0x04, 0x08, 0x23,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x69, 0x02, 0x00, 0x12, 0x04, 0xab, 0x04, 0x02, 0x1a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x69, 0x02, 0x00, 0x04, 0x12, 0x04, 0xab, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x69, 0x02, 0x00, 0x05, 0x12, 0x04, 0xab, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x69, 0x02, 0x00, 0x01, 0x12, 0x04, 0xab, 0x04, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x69, 0x02, 0x00, 0x03, 0x12, 0x04, 0xab, 0x04, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x6a,
    0x12, 0x06, 0xae, 0x04, 0x00, 0xb0, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x6a, 0x01, 0x12,
    0x04, 0xae, 0x04, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6a, 0x02, 0x00, 0x12, 0x04, 0xaf,
    0x04, 0x02, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6a, 0x02, 0x00, 0x04, 0x12, 0x04, 0xaf, 0x04,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6a, 0x02, 0x00, 0x06, 0x12, 0x04, 0xaf, 0x04, 0x0b,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6a, 0x02, 0x00, 0x01, 0x12, 0x04, 0xaf, 0x04, 0x1f, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6a, 0x02, 0x00, 0x03, 0x12, 0x04, 0xaf, 0x04, 0x24, 0x25, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x6b, 0x12, 0x06, 0xb2, 0x04, 0x00, 0xb4, 0x04, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x6b, 0x01, 0x12, 0x04, 0xb2, 0x04, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6b,
    0x02, 0x00, 0x12, 0x04, 0xb3, 0x04, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6b, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xb3, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6b, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xb3, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6b, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xb3, 0x04, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6b, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xb3, 0x04, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x6c, 0x12, 0x06, 0xb6, 0x04, 0x00, 0xb8,
    0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x6c, 0x01, 0x12, 0x04, 0xb6, 0x04, 0x08, 0x26, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x6c, 0x02, 0x00, 0x12, 0x04, 0xb7, 0x04, 0x02, 0x2b, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x6c, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb7, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x6c, 0x02, 0x00, 0x06, 0x12, 0x04, 0xb7, 0x04, 0x0b, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x6c, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb7, 0x04, 0x1f, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6c,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xb7, 0x04, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x6d, 0x12,
    0x06, 0xba, 0x04, 0x00, 0xbf, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x6d, 0x01, 0x12, 0x04,
    0xba, 0x04, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6d, 0x02, 0x00, 0x12, 0x04, 0xbb, 0x04,
    0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x00, 0x04, 0x12, 0x04, 0xbb, 0x04, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x00, 0x05, 0x12, 0x04, 0xbb, 0x04, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x00, 0x01, 0x12, 0x04, 0xbb, 0x04, 0x12, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x00, 0x03, 0x12, 0x04, 0xbb, 0x04, 0x19, 0x1a, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x6d, 0x02, 0x01, 0x12, 0x04, 0xbc, 0x04, 0x02, 0x25, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x6d, 0x02, 0x01, 0x04, 0x12, 0x04, 0xbc, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x6d, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbc, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d,
    0x02, 0x01, 0x01, 0x12, 0x04, 0xbc, 0x04, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xbc, 0x04, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6d, 0x02, 0x02,
    0x12, 0x04, 0xbd, 0x04, 0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x02, 0x04, 0x12,
    0x04, 0xbd, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x02, 0x05, 0x12, 0x04,
    0xbd, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x02, 0x01, 0x12, 0x04, 0xbd,
    0x04, 0x12, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x02, 0x03, 0x12, 0x04, 0xbd, 0x04,
    0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6d, 0x02, 0x03, 0x12, 0x04, 0xbe, 0x04, 0x02, 0x2c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x03, 0x04, 0x12, 0x04, 0xbe, 0x04, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x03, 0x06, 0x12, 0x04, 0xbe, 0x04, 0x0b, 0x1b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x6d, 0x02, 0x03, 0x01, 0x12, 0x04, 0xbe, 0x04, 0x1c, 0x27, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x6d, 0x02, 0x03, 0x03, 0x12, 0x04, 0xbe, 0x04, 0x2a, 0x2b, 0x0a, 0x1d, 0x0a, 0x02,
    0x04, 0x6e, 0x12, 0x06, 0xc1, 0x04, 0x00, 0xc2, 0x04, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69,
    0x64, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x6e, 0x01, 0x12, 0x04, 0xc1, 0x04, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x6f, 0x12, 0x06,
    0xc4, 0x04, 0x00, 0xc9, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x6f, 0x01, 0x12, 0x04, 0xc4,
    0x04, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6f, 0x02, 0x00, 0x12, 0x04, 0xc5, 0x04, 0x02,
    0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc5, 0x04, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc5, 0x04, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc5, 0x04, 0x12, 0x15, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x6f, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc5, 0x04, 0x18, 0x19, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x6f, 0x02, 0x01, 0x12, 0x04, 0xc6, 0x04, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x6f, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc6, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f,
    0x02, 0x01, 0x05, 0x12, 0x04, 0xc6, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xc6, 0x04, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xc6, 0x04, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6f, 0x02, 0x02, 0x12,
    0x04, 0xc7, 0x04, 0x02, 0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x02, 0x04, 0x12, 0x04,
    0xc7, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x02, 0x05, 0x12, 0x04, 0xc7,
    0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc7, 0x04,
    0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc7, 0x04, 0x24,
    0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x02, 0x08, 0x12, 0x04, 0xc7, 0x04, 0x26, 0x34,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x02, 0x07, 0x12, 0x04, 0xc7, 0x04, 0x31, 0x33, 0x0a,
    0x2f, 0x0a, 0x04, 0x04, 0x6f, 0x02, 0x03, 0x12, 0x04, 0xc8, 0x04, 0x02, 0x2b, 0x22, 0x21, 0x20,
    0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x47, 0x52, 0x41, 0x4e, 0x44,
    0x46, 0x41, 0x54, 0x48, 0x45, 0x52, 0x5f, 0x49, 0x4e, 0x4f, 0x44, 0x45, 0x5f, 0x49, 0x44, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc8, 0x04, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x03, 0x05, 0x12, 0x04, 0xc8, 0x04, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x6f, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc8, 0x04, 0x12, 0x18, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x6f, 0x02, 0x03, 0x03, 0x12, 0x04, 0xc8, 0x04, 0x1b, 0x1c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x6f, 0x02, 0x03, 0x08, 0x12, 0x04, 0xc8, 0x04, 0x1d, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x6f, 0x02, 0x03, 0x07, 0x12, 0x04, 0xc8, 0x04, 0x28, 0x29, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x70,
    0x12, 0x06, 0xcb, 0x04, 0x00, 0xcc, 0x04, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20,
    0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x70, 0x01,
    0x12, 0x04, 0xcb, 0x04, 0x08, 0x1a, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x71, 0x12, 0x06, 0xce, 0x04,
    0x00, 0xd2, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x71, 0x01, 0x12, 0x04, 0xce, 0x04, 0x08,
    0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x71, 0x02, 0x00, 0x12, 0x04, 0xcf, 0x04, 0x02, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x71, 0x02, 0x00, 0x04, 0x12, 0x04, 0xcf, 0x04, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x71, 0x02, 0x00, 0x05, 0x12, 0x04, 0xcf, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x71, 0x02, 0x00, 0x01, 0x12, 0x04, 0xcf, 0x04, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x71, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcf, 0x04, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x71, 0x02, 0x01, 0x12, 0x04, 0xd0, 0x04, 0x02, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x71, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xd0, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x71, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xd0, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x71, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xd0, 0x04, 0x12, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x71, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xd0, 0x04, 0x1a, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x71, 0x02, 0x02, 0x12, 0x04, 0xd1,
    0x04, 0x02, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x71, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd1, 0x04,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x71, 0x02, 0x02, 0x05, 0x12, 0x04, 0xd1, 0x04, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x71, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd1, 0x04, 0x12, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x71, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd1, 0x04, 0x1a, 0x1b, 0x0a,
    0x1d, 0x0a, 0x02, 0x04, 0x72, 0x12, 0x06, 0xd4, 0x04, 0x00, 0xd5, 0x04, 0x01, 0x22, 0x0f, 0x20,
    0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x72, 0x01, 0x12, 0x04, 0xd4, 0x04, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x73, 0x12, 0x06, 0xd7, 0x04, 0x00, 0xdc, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x73, 0x01,
    0x12, 0x04, 0xd7, 0x04, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x73, 0x02, 0x00, 0x12, 0x04,
    0xd8, 0x04, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd8,
    0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd8, 0x04,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd8, 0x04, 0x12,
    0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd8, 0x04, 0x1b, 0x1c,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x73, 0x02, 0x01, 0x12, 0x04, 0xd9, 0x04, 0x02, 0x1b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x73, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd9, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x73, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd9, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x73, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd9, 0x04, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x73, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd9, 0x04, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x73,
    0x02, 0x02, 0x12, 0x04, 0xda, 0x04, 0x02, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xda, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x02, 0x06,
    0x12, 0x04, 0xda, 0x04, 0x0b, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xda, 0x04, 0x1d, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xda, 0x04, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x73, 0x02, 0x03, 0x12, 0x04, 0xdb, 0x04,
    0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x03, 0x04, 0x12, 0x04, 0xdb, 0x04, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x03, 0x05, 0x12, 0x04, 0xdb, 0x04, 0x0b, 0x0f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x03, 0x01, 0x12, 0x04, 0xdb, 0x04, 0x10, 0x1c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x03, 0x03, 0x12, 0x04, 0xdb, 0x04, 0x1f, 0x20, 0x0a, 0x1d,
    0x0a, 0x02, 0x04, 0x74, 0x12, 0x06, 0xde, 0x04, 0x00, 0xdf, 0x04, 0x01, 0x22, 0x0f, 0x20, 0x76,
    0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x74, 0x01, 0x12, 0x04, 0xde, 0x04, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x75,
    0x12, 0x06, 0xe1, 0x04, 0x00, 0xe3, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x75, 0x01, 0x12,
    0x04, 0xe1, 0x04, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x75, 0x02, 0x00, 0x12, 0x04, 0xe2,
    0x04, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x75, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe2, 0x04,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x75, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe2, 0x04, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x75, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe2, 0x04, 0x12, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x75, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe2, 0x04, 0x19, 0x1a, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x76, 0x12, 0x06, 0xe4, 0x04, 0x00, 0xe6, 0x04, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x76, 0x01, 0x12, 0x04, 0xe4, 0x04, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x76,
    0x02, 0x00, 0x12, 0x04, 0xe5, 0x04, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x76, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xe5, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x76, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xe5, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x76, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xe5, 0x04, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x76, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xe5, 0x04, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x77, 0x12, 0x06, 0xe8, 0x04, 0x00, 0xeb,
    0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x77, 0x01, 0x12, 0x04, 0xe8, 0x04, 0x08, 0x2a, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x77, 0x02, 0x00, 0x12, 0x04, 0xe9, 0x04, 0x02, 0x28, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x77, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe9, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x77, 0x02, 0x00, 0x06, 0x12, 0x04, 0xe9, 0x04, 0x0b, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x77, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe9, 0x04, 0x1e, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x77,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xe9, 0x04, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x77, 0x02,
    0x01, 0x12, 0x04, 0xea, 0x04, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x77, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xea, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x77, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xea, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x77, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xea, 0x04, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x77, 0x02, 0x01, 0x03, 0x12, 0x04, 0xea,
    0x04, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x78, 0x12, 0x06, 0xed, 0x04, 0x00, 0xef, 0x04,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x78, 0x01, 0x12, 0x04, 0xed, 0x04, 0x08, 0x2b, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x78, 0x02, 0x00, 0x12, 0x04, 0xee, 0x04, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x78, 0x02, 0x00, 0x04, 0x12, 0x04, 0xee, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x78, 0x02, 0x00, 0x06, 0x12, 0x04, 0xee, 0x04, 0x0b, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x78,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xee, 0x04, 0x1d, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x78, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xee, 0x04, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x79, 0x12, 0x06,
    0xf1, 0x04, 0x00, 0xf7, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x79, 0x01, 0x12, 0x04, 0xf1,
    0x04, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x79, 0x02, 0x00, 0x12, 0x04, 0xf2, 0x04, 0x02,
    0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf2, 0x04, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf2, 0x04, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf2, 0x04, 0x12, 0x1c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x79, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf2, 0x04, 0x1f, 0x20, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x79, 0x02, 0x01, 0x12, 0x04, 0xf3, 0x04, 0x02, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x79, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf3, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79,
    0x02, 0x01, 0x06, 0x12, 0x04, 0xf3, 0x04, 0x0b, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xf3, 0x04, 0x1e, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xf3, 0x04, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x79, 0x02, 0x02, 0x12,
    0x04, 0xf4, 0x04, 0x02, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x02, 0x04, 0x12, 0x04,
    0xf4, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x02, 0x06, 0x12, 0x04, 0xf4,
    0x04, 0x0b, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf4, 0x04,
    0x1e, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf4, 0x04, 0x29,
    0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x79, 0x02, 0x03, 0x12, 0x04, 0xf5, 0x04, 0x02, 0x28, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x03, 0x04, 0x12, 0x04, 0xf5, 0x04, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x79, 0x02, 0x03, 0x06, 0x12, 0x04, 0xf5, 0x04, 0x0b, 0x1a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x79, 0x02, 0x03, 0x01, 0x12, 0x04, 0xf5, 0x04, 0x1b, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x79, 0x02, 0x03, 0x03, 0x12, 0x04, 0xf5, 0x04, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x79, 0x02, 0x04, 0x12, 0x04, 0xf6, 0x04, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02,
    0x04, 0x04, 0x12, 0x04, 0xf6, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x04,
    0x05, 0x12, 0x04, 0xf6, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x04, 0x01,
    0x12, 0x04, 0xf6, 0x04, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x04, 0x03, 0x12,
    0x04, 0xf6, 0x04, 0x1f, 0x20, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x7a, 0x12, 0x06, 0xf9, 0x04, 0x00,
    0xfa, 0x04, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x7a, 0x01, 0x12, 0x04, 0xf9, 0x04, 0x08,
    0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x7b, 0x12, 0x06, 0xfc, 0x04, 0x00, 0xfe, 0x04, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x7b, 0x01, 0x12, 0x04, 0xfc, 0x04, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x7b, 0x02, 0x00, 0x12, 0x04, 0xfd, 0x04, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xfd, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xfd, 0x04, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xfd, 0x04, 0x11, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xfd, 0x04, 0x1d, 0x1e, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x7c, 0x12, 0x06, 0x80, 0x05,
    0x00, 0x81, 0x05, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x7c, 0x01, 0x12, 0x04, 0x80, 0x05,
    0x08, 0x29, 0x0a, 0x1d, 0x0a, 0x02, 0x04, 0x7d, 0x12, 0x06, 0x83, 0x05, 0x00, 0x84, 0x05, 0x01,
    0x22, 0x0f, 0x20, 0x6e, 0x6f, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73,
    0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x7d, 0x01, 0x12, 0x04, 0x83, 0x05, 0x08, 0x28, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x7e, 0x12, 0x06, 0x86, 0x05, 0x00, 0x88, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x7e, 0x01, 0x12, 0x04, 0x86, 0x05, 0x08, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7e, 0x02,
    0x00, 0x12, 0x04, 0x87, 0x05, 0x02, 0x38, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7e, 0x02, 0x00, 0x04,
    0x12, 0x04, 0x87, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7e, 0x02, 0x00, 0x06, 0x12,
    0x04, 0x87, 0x05, 0x0b, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7e, 0x02, 0x00, 0x01, 0x12, 0x04,
    0x87, 0x05, 0x22, 0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7e, 0x02, 0x00, 0x03, 0x12, 0x04, 0x87,
    0x05, 0x36, 0x37, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x7f, 0x12, 0x06, 0x8a, 0x05, 0x00, 0x8d, 0x05,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x7f, 0x01, 0x12, 0x04, 0x8a, 0x05, 0x08, 0x22, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x7f, 0x02, 0x00, 0x12, 0x04, 0x8b, 0x05, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x7f, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8b, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x7f, 0x02, 0x00, 0x05, 0x12, 0x04, 0x8b, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f,
    0x02, 0x00, 0x01, 0x12, 0x04, 0x8b, 0x05, 0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02,
    0x00, 0x03, 0x12, 0x04, 0x8b, 0x05, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7f, 0x02, 0x01,
    0x12, 0x04, 0x8c, 0x05, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02, 0x01, 0x04, 0x12,
    0x04, 0x8c, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02, 0x01, 0x05, 0x12, 0x04,
    0x8c, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8c,
    0x05, 0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8c, 0x05,
    0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x80, 0x01, 0x12, 0x06, 0x8f, 0x05, 0x00, 0x91, 0x05,
    0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x80, 0x01, 0x01, 0x12, 0x04, 0x8f, 0x05, 0x08, 0x23, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x80, 0x01, 0x02, 0x00, 0x12, 0x04, 0x90, 0x05, 0x02, 0x23, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x80, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0x90, 0x05, 0x02, 0x0a, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x80, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0x90, 0x05, 0x0b, 0x11, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x80, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x90, 0x05, 0x12, 0x1e, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x80, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0x90, 0x05, 0x21, 0x22, 0x0a, 0x0d,
    0x0a, 0x03, 0x04, 0x81, 0x01, 0x12, 0x06, 0x93, 0x05, 0x00, 0x97, 0x05, 0x01, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x81, 0x01, 0x01, 0x12, 0x04, 0x93, 0x05, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x81, 0x01, 0x02, 0x00, 0x12, 0x04, 0x94, 0x05, 0x02, 0x23, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81,
    0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0x94, 0x05, 0x02, 0x0a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81,
    0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0x94, 0x05, 0x0b, 0x11, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81,
    0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x94, 0x05, 0x12, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81,
    0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0x94, 0x05, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x81,
    0x01, 0x02, 0x01, 0x12, 0x04, 0x95, 0x05, 0x02, 0x26, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01,
    0x02, 0x01, 0x04, 0x12, 0x04, 0x95, 0x05, 0x02, 0x0a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01,
    0x02, 0x01, 0x05, 0x12, 0x04, 0x95, 0x05, 0x0b, 0x11, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01,
    0x02, 0x01, 0x01, 0x12, 0x04, 0x95, 0x05, 0x12, 0x21, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01,
    0x02, 0x01, 0x03, 0x12, 0x04, 0x95, 0x05, 0x24, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x81, 0x01,
    0x02, 0x02, 0x12, 0x04, 0x96, 0x05, 0x02, 0x26, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02,
    0x02, 0x04, 0x12, 0x04, 0x96, 0x05, 0x02, 0x0a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02,
    0x02, 0x05, 0x12, 0x04, 0x96, 0x05, 0x0b, 0x11, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02,
    0x02, 0x01, 0x12, 0x04, 0x96, 0x05, 0x12, 0x21, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02,
    0x02, 0x03, 0x12, 0x04, 0x96, 0x05, 0x24, 0x25, 0x0a, 0x1e, 0x0a, 0x03, 0x04, 0x82, 0x01, 0x12,
    0x06, 0x99, 0x05, 0x00, 0x9a, 0x05, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x72,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x82, 0x01, 0x01,
    0x12, 0x04, 0x99, 0x05, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x83, 0x01, 0x12, 0x06, 0x9c,
    0x05, 0x00, 0x9e, 0x05, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x83, 0x01, 0x01, 0x12, 0x04, 0x9c,
    0x05, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x83, 0x01, 0x02, 0x00, 0x12, 0x04, 0x9d, 0x05,
    0x02, 0x23, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9d, 0x05,
    0x02, 0x0a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0x9d, 0x05,
    0x0b, 0x11, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9d, 0x05,
    0x12, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9d, 0x05,
    0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x84, 0x01, 0x12, 0x06, 0xa0, 0x05, 0x00, 0xa1, 0x05,
    0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x84, 0x01, 0x01, 0x12, 0x04, 0xa0, 0x05, 0x08, 0x22, 0x0a,
    0x0d, 0x0a, 0x03, 0x04, 0x85, 0x01, 0x12, 0x06, 0xa3, 0x05, 0x00, 0xa5, 0x05, 0x01, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x85, 0x01, 0x01, 0x12, 0x04, 0xa3, 0x05, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x85, 0x01, 0x02, 0x00, 0x12, 0x04, 0xa4, 0x05, 0x02, 0x23, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x85, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa4, 0x05, 0x02, 0x0a, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x85, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa4, 0x05, 0x0b, 0x11, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x85, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa4, 0x05, 0x12, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x85, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa4, 0x05, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x03, 0x04,
    0x86, 0x01, 0x12, 0x06, 0xa7, 0x05, 0x00, 0xa8, 0x05, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x86,
    0x01, 0x01, 0x12, 0x04, 0xa7, 0x05, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x87, 0x01, 0x12,
    0x06, 0xaa, 0x05, 0x00, 0xad, 0x05, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x87, 0x01, 0x01, 0x12,
    0x04, 0xaa, 0x05, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x87, 0x01, 0x02, 0x00, 0x12, 0x04,
    0xab, 0x05, 0x02, 0x23, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x87, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xab, 0x05, 0x02, 0x0a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x87, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xab, 0x05, 0x0b, 0x11, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x87, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xab, 0x05, 0x12, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x87, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xab, 0x05, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x87, 0x01, 0x02, 0x01, 0x12, 0x04, 0xac,
    0x05, 0x02, 0x23, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x87, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xac,
    0x05, 0x02, 0x0a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x87, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xac,
    0x05, 0x0b, 0x11, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x87, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xac,
    0x05, 0x12, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x87, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xac,
    0x05, 0x21, 0x22, 0x0a, 0x1e, 0x0a, 0x03, 0x04, 0x88, 0x01, 0x12, 0x06, 0xaf, 0x05, 0x00, 0xb0,
    0x05, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x0a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x88, 0x01, 0x01, 0x12, 0x04, 0xaf, 0x05, 0x08,
    0x23, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x89, 0x01, 0x12, 0x06, 0xb2, 0x05, 0x00, 0xb5, 0x05, 0x01,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x89, 0x01, 0x01, 0x12, 0x04, 0xb2, 0x05, 0x08, 0x1f, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x89, 0x01, 0x02, 0x00, 0x12, 0x04, 0xb3, 0x05, 0x02, 0x1b, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x89, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb3, 0x05, 0x02, 0x0a, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x89, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb3, 0x05, 0x0b, 0x11, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x89, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb3, 0x05, 0x12, 0x16, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x89, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb3, 0x05, 0x19, 0x1a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x89, 0x01, 0x02, 0x01, 0x12, 0x04, 0xb4, 0x05, 0x02, 0x30, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x89, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb4, 0x05, 0x02, 0x0a, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x89, 0x01, 0x02, 0x01, 0x06, 0x12, 0x04, 0xb4, 0x05, 0x0b, 0x26, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x89, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb4, 0x05, 0x27, 0x2b, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x89, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb4, 0x05, 0x2e, 0x2f, 0x0a, 0x1e, 0x0a, 0x03,
    0x04, 0x8a, 0x01, 0x12, 0x06, 0xb7, 0x05, 0x00, 0xb8, 0x05, 0x01, 0x22, 0x0f, 0x20, 0x76, 0x6f,
    0x69, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x0a, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x8a, 0x01, 0x01, 0x12, 0x04, 0xb7, 0x05, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x8b,
    0x01, 0x12, 0x06, 0xba, 0x05, 0x00, 0xbb, 0x05, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x8b, 0x01,
    0x01, 0x12, 0x04, 0xba, 0x05, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x8c, 0x01, 0x12, 0x06,
    0xbd, 0x05, 0x00, 0xbf, 0x05, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x8c, 0x01, 0x01, 0x12, 0x04,
    0xbd, 0x05, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x8c, 0x01, 0x02, 0x00, 0x12, 0x04, 0xbe,
    0x05, 0x02, 0x1a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8c, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xbe,
    0x05, 0x02, 0x0a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8c, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xbe,
    0x05, 0x0b, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8c, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xbe,
    0x05, 0x11, 0x15, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8c, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xbe,
    0x05, 0x18, 0x19, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x8d, 0x01, 0x12, 0x06, 0xc1, 0x05, 0x00, 0xc3,
    0x05, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x8d, 0x01, 0x01, 0x12, 0x04, 0xc1, 0x05, 0x08, 0x24,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x8d, 0x01, 0x02, 0x00, 0x12, 0x04, 0xc2, 0x05, 0x02, 0x1a, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc2, 0x05, 0x02, 0x0a, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc2, 0x05, 0x0b, 0x10, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc2, 0x05, 0x11, 0x15, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc2, 0x05, 0x18, 0x19, 0x0a,
    0x0d, 0x0a, 0x03, 0x04, 0x8e, 0x01, 0x12, 0x06, 0xc5, 0x05, 0x00, 0xc7, 0x05, 0x01, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x8e, 0x01, 0x01, 0x12, 0x04, 0xc5, 0x05, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x8e, 0x01, 0x02, 0x00, 0x12, 0x04, 0xc6, 0x05, 0x02, 0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x8e, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc6, 0x05, 0x02, 0x0a, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x8e, 0x01, 0x02, 0x00, 0x06, 0x12, 0x04, 0xc6, 0x05, 0x0b, 0x1a, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x8e, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc6, 0x05, 0x1b, 0x25, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x8e, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc6, 0x05, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x02, 0x06,
    0x00, 0x12, 0x06, 0xc9, 0x05, 0x00, 0xdb, 0x06, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x06, 0x00, 0x01,
    0x12, 0x04, 0xc9, 0x05, 0x08, 0x1e, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x00, 0x12, 0x06,
    0xca, 0x05, 0x02, 0xcb, 0x05, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xca, 0x05, 0x06, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04,
    0xca, 0x05, 0x18, 0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcb,
    0x05, 0x0e, 0x2c, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x01, 0x12, 0x06, 0xcc, 0x05, 0x02,
    0xcd, 0x05, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xcc, 0x05,
    0x06, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xcc, 0x05, 0x18,
    0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xcd, 0x05, 0x0e, 0x2c,
    0x0a, 0x0c, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x02, 0x12, 0x04, 0xce, 0x05, 0x02, 0x3d, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xce, 0x05, 0x06, 0x0c, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x02, 0x02, 0x12, 0x04, 0xce, 0x05, 0x0d, 0x1f, 0x0a, 0x0d, 0x0a, 0x05,
    0x06, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xce, 0x05, 0x28, 0x3b, 0x0a, 0x0c, 0x0a, 0x04, 0x06,
    0x00, 0x02, 0x03, 0x12, 0x04, 0xcf, 0x05, 0x02, 0x3e, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xcf, 0x05, 0x06, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x03,
    0x02, 0x12, 0x04, 0xcf, 0x05, 0x0d, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x03, 0x03,
    0x12, 0x04, 0xcf, 0x05, 0x29, 0x3c, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x04, 0x12, 0x06,
    0xd0, 0x05, 0x02, 0xd1, 0x05, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x04, 0x01, 0x12,
    0x04, 0xd0, 0x05, 0x06, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x04, 0x02, 0x12, 0x04,
    0xd0, 0x05, 0x15, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0xd1,
    0x05, 0x0e, 0x29, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x05, 0x12, 0x06, 0xd2, 0x05, 0x02,
    0xd3, 0x05, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x05, 0x01, 0x12, 0x04, 0xd2, 0x05,
    0x06, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x05, 0x02, 0x12, 0x04, 0xd2, 0x05, 0x17,
    0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x05, 0x03, 0x12, 0x04, 0xd3, 0x05, 0x0e, 0x2b,
    0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x06, 0x12, 0x06, 0xd4, 0x05, 0x02, 0xd5, 0x05, 0x2f,
    0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04, 0xd4, 0x05, 0x06, 0x18, 0x0a,
    0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x06, 0x02, 0x12, 0x04, 0xd4, 0x05, 0x19, 0x37, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x06, 0x03, 0x12, 0x04, 0xd5, 0x05, 0x0e, 0x2d, 0x0a, 0x0e, 0x0a,
    0x04, 0x06, 0x00, 0x02, 0x07, 0x12, 0x06, 0xd6, 0x05, 0x02, 0xd7, 0x05, 0x2a, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x07, 0x01, 0x12, 0x04, 0xd6, 0x05, 0x06, 0x13, 0x0a, 0x0d, 0x0a, 0x05,
    0x06, 0x00, 0x02, 0x07, 0x02, 0x12, 0x04, 0xd6, 0x05, 0x14, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x06,
    0x00, 0x02, 0x07, 0x03, 0x12, 0x04, 0xd7, 0x05, 0x0e, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x06, 0x00,
    0x02, 0x08, 0x12, 0x04, 0xd8, 0x05, 0x02, 0x44, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x08,
    0x01, 0x12, 0x04, 0xd8, 0x05, 0x06, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x08, 0x02,
    0x12, 0x04, 0xd8, 0x05, 0x0f, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x08, 0x03, 0x12,
    0x04, 0xd8, 0x05, 0x2d, 0x42, 0x0a, 0x0c, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x09, 0x12, 0x04, 0xd9,
    0x05, 0x02, 0x50, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x09, 0x01, 0x12, 0x04, 0xd9, 0x05,
    0x06, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x09, 0x02, 0x12, 0x04, 0xd9, 0x05, 0x13,
    0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x09, 0x03, 0x12, 0x04, 0xd9, 0x05, 0x35, 0x4e,
    0x0a, 0x0c, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x0a, 0x12, 0x04, 0xda, 0x05, 0x02, 0x44, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xda, 0x05, 0x06, 0x0e, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x0a, 0x02, 0x12, 0x04, 0xda, 0x05, 0x0f, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x06, 0x00, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xda, 0x05, 0x2d, 0x42, 0x0a, 0x0e, 0x0a, 0x04, 0x06,
    0x00, 0x02, 0x0b, 0x12, 0x06, 0xdb, 0x05, 0x02, 0xdc, 0x05, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x06,
    0x00, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xdb, 0x05, 0x06, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00,
    0x02, 0x0b, 0x02, 0x12, 0x04, 0xdb, 0x05, 0x1c, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x0b, 0x03, 0x12, 0x04, 0xdc, 0x05, 0x0e, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x0c,
    0x12, 0x04, 0xdd, 0x05, 0x02, 0x44, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x0c, 0x01, 0x12,
    0x04, 0xdd, 0x05, 0x06, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x0c, 0x02, 0x12, 0x04,
    0xdd, 0x05, 0x0f, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xdd,
    0x05, 0x2d, 0x42, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x0d, 0x12, 0x06, 0xde, 0x05, 0x02,
    0xdf, 0x05, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x0d, 0x01, 0x12, 0x04, 0xde, 0x05,
    0x06, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x0d, 0x02, 0x12, 0x04, 0xde, 0x05, 0x16,
    0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x0d, 0x03, 0x12, 0x04, 0xdf, 0x05, 0x0e, 0x2a,
    0x0a, 0x0c, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x0e, 0x12, 0x04, 0xe0, 0x05, 0x02, 0x3e, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xe0, 0x05, 0x06, 0x0c, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x0e, 0x02, 0x12, 0x04, 0xe0, 0x05, 0x0d, 0x1f, 0x0a, 0x0d, 0x0a, 0x05,
    0x06, 0x00, 0x02, 0x0e, 0x03, 0x12, 0x04, 0xe0, 0x05, 0x29, 0x3c, 0x0a, 0x0c, 0x0a, 0x04, 0x06,
    0x00, 0x02, 0x0f, 0x12, 0x04, 0xe1, 0x05, 0x02, 0x44, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x0f, 0x01, 0x12, 0x04, 0xe1, 0x05, 0x06, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x0f,
    0x02, 0x12, 0x04, 0xe1, 0x05, 0x0f, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x0f, 0x03,
    0x12, 0x04, 0xe1, 0x05, 0x2d, 0x42, 0x0a, 0x0c, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x10, 0x12, 0x04,
    0xe2, 0x05, 0x02, 0x3e, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x10, 0x01, 0x12, 0x04, 0xe2,
    0x05, 0x06, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x10, 0x02, 0x12, 0x04, 0xe2, 0x05,
    0x0d, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x10, 0x03, 0x12, 0x04, 0xe2, 0x05, 0x29,
    0x3c, 0x0a, 0x0c, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x11, 0x12, 0x04, 0xe3, 0x05, 0x02, 0x41, 0x0a,
    0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x11, 0x01, 0x12, 0x04, 0xe3, 0x05, 0x06, 0x0d, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x11, 0x02, 0x12, 0x04, 0xe3, 0x05, 0x0e, 0x21, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x11, 0x03, 0x12, 0x04, 0xe3, 0x05, 0x2b, 0x3f, 0x0a, 0x0c, 0x0a, 0x04,
    0x06, 0x00, 0x02, 0x12, 0x12, 0x04, 0xe4, 0x05, 0x02, 0x3e, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00,
    0x02, 0x12, 0x01, 0x12, 0x04, 0xe4, 0x05, 0x06, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x12, 0x02, 0x12, 0x04, 0xe4, 0x05, 0x0d, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x12,
    0x03, 0x12, 0x04, 0xe4, 0x05, 0x29, 0x3c, 0x0a, 0x0c, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x13, 0x12,
    0x04, 0xe5, 0x05, 0x02, 0x3e, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x13, 0x01, 0x12, 0x04,
    0xe5, 0x05, 0x06, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x13, 0x02, 0x12, 0x04, 0xe5,
    0x05, 0x0d, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x13, 0x03, 0x12, 0x04, 0xe5, 0x05,
    0x29, 0x3c, 0x0a, 0x0c, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x14, 0x12, 0x04, 0xe6, 0x05, 0x02, 0x4a,
    0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x14, 0x01, 0x12, 0x04, 0xe6, 0x05, 0x06, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x14, 0x02, 0x12, 0x04, 0xe6, 0x05, 0x11, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x14, 0x03, 0x12, 0x04, 0xe6, 0x05, 0x31, 0x48, 0x0a, 0x0c, 0x0a,
    0x04, 0x06, 0x00, 0x02, 0x15, 0x12, 0x04, 0xe7, 0x05, 0x02, 0x4a, 0x0a, 0x0d, 0x0a, 0x05, 0x06,
    0x00, 0x02, 0x15, 0x01, 0x12, 0x04, 0xe7, 0x05, 0x06, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00,
    0x02, 0x15, 0x02, 0x12, 0x04, 0xe7, 0x05, 0x11, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x15, 0x03, 0x12, 0x04, 0xe7, 0x05, 0x31, 0x48, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x16,
    0x12, 0x06, 0xe8, 0x05, 0x02, 0xe9, 0x05, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x16,
    0x01, 0x12, 0x04, 0xe8, 0x05, 0x06, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x16, 0x02,
    0x12, 0x04, 0xe8, 0x05, 0x13, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x16, 0x03, 0x12,
    0x04, 0xe9, 0x05, 0x0e, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x17, 0x12, 0x04, 0xea,
    0x05, 0x02, 0x4b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x17, 0x01, 0x12, 0x04, 0xea, 0x05,
    0x06, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x17, 0x02, 0x12, 0x04, 0xea, 0x05, 0x11,
    0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x17, 0x03, 0x12, 0x04, 0xea, 0x05, 0x32, 0x49,
    0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x18, 0x12, 0x06, 0xeb, 0x05, 0x02, 0xec, 0x05, 0x2e,
    0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x18, 0x01, 0x12, 0x04, 0xeb, 0x05, 0x06, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x18, 0x02, 0x12, 0x04, 0xeb, 0x05, 0x18, 0x35, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x18, 0x03, 0x12, 0x04, 0xec, 0x05, 0x0e, 0x2c, 0x0a, 0x0e, 0x0a,
    0x04, 0x06, 0x00, 0x02, 0x19, 0x12, 0x06, 0xed, 0x05, 0x02, 0xee, 0x05, 0x35, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x19, 0x01, 0x12, 0x04, 0xed, 0x05, 0x06, 0x1e, 0x0a, 0x0d, 0x0a, 0x05,
    0x06, 0x00, 0x02, 0x19, 0x02, 0x12, 0x04, 0xed, 0x05, 0x1f, 0x43, 0x0a, 0x0d, 0x0a, 0x05, 0x06,
    0x00, 0x02, 0x19, 0x03, 0x12, 0x04, 0xee, 0x05, 0x0e, 0x33, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00,
    0x02, 0x1a, 0x12, 0x06, 0xef, 0x05, 0x02, 0xf0, 0x05, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00,
    0x02, 0x1a, 0x01, 0x12, 0x04, 0xef, 0x05, 0x06, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x1a, 0x02, 0x12, 0x04, 0xef, 0x05, 0x1c, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x1a,
    0x03, 0x12, 0x04, 0xf0, 0x05, 0x0e, 0x30, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x1b, 0x12,
    0x06, 0xf1, 0x05, 0x02, 0xf2, 0x05, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x1b, 0x01,
    0x12, 0x04, 0xf1, 0x05, 0x06, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x1b, 0x02, 0x12,
    0x04, 0xf1, 0x05, 0x12, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x1b, 0x03, 0x12, 0x04,
    0xf2, 0x05, 0x0e, 0x26, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x1c, 0x12, 0x06, 0xf3, 0x05,
    0x02, 0xf4, 0x05, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x1c, 0x01, 0x12, 0x04, 0xf3,
    0x05, 0x06, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x1c, 0x02, 0x12, 0x04, 0xf3, 0x05,
    0x14, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x1c, 0x03, 0x12, 0x04, 0xf4, 0x05, 0x0e,
    0x28, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x1d, 0x12, 0x06, 0xf5, 0x05, 0x02, 0xf6, 0x05,
    0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x1d, 0x01, 0x12, 0x04, 0xf5, 0x05, 0x06, 0x0f,
    0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x1d, 0x02, 0x12, 0x04, 0xf5, 0x05, 0x10, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x1d, 0x03, 0x12, 0x04, 0xf6, 0x05, 0x0e, 0x24, 0x0a, 0x0e,
    0x0a, 0x04, 0x06, 0x00, 0x02, 0x1e, 0x12, 0x06, 0xf7, 0x05, 0x02, 0xf8, 0x05, 0x31, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x1e, 0x01, 0x12, 0x04, 0xf7, 0x05, 0x06, 0x1a, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x1e, 0x02, 0x12, 0x04, 0xf7, 0x05, 0x1b, 0x3b, 0x0a, 0x0d, 0x0a, 0x05,
    0x06, 0x00, 0x02, 0x1e, 0x03, 0x12, 0x04, 0xf8, 0x05, 0x0e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x06,
    0x00, 0x02, 0x1f, 0x12, 0x04, 0xf9, 0x05, 0x02, 0x50, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x1f, 0x01, 0x12, 0x04, 0xf9, 0x05, 0x06, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x1f,
    0x02, 0x12, 0x04, 0xf9, 0x05, 0x13, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x1f, 0x03,
    0x12, 0x04, 0xf9, 0x05, 0x35, 0x4e, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x20, 0x12, 0x06,
    0xfa, 0x05, 0x02, 0xfb, 0x05, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x20, 0x01, 0x12,
    0x04, 0xfa, 0x05, 0x06, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x20, 0x02, 0x12, 0x04,
    0xfa, 0x05, 0x16, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x20, 0x03, 0x12, 0x04, 0xfb,
    0x05, 0x0e, 0x2a, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x21, 0x12, 0x06, 0xfc, 0x05, 0x02,
    0xfd, 0x05, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x21, 0x01, 0x12, 0x04, 0xfc, 0x05,
    0x06, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x21, 0x02, 0x12, 0x04, 0xfc, 0x05, 0x15,
    0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x21, 0x03, 0x12, 0x04, 0xfd, 0x05, 0x0e, 0x29,
    0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x22, 0x12, 0x06, 0xfe, 0x05, 0x02, 0xff, 0x05, 0x32,
    0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x22, 0x01, 0x12, 0x04, 0xfe, 0x05, 0x06, 0x1b, 0x0a,
    0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x22, 0x02, 0x12, 0x04, 0xfe, 0x05, 0x1c, 0x3d, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x22, 0x03, 0x12, 0x04, 0xff, 0x05, 0x0e, 0x30, 0x0a, 0x0c, 0x0a,
    0x04, 0x06, 0x00, 0x02, 0x23, 0x12, 0x04, 0x80, 0x06, 0x02, 0x44, 0x0a, 0x0d, 0x0a, 0x05, 0x06,
    0x00, 0x02, 0x23, 0x01, 0x12, 0x04, 0x80, 0x06, 0x06, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00,
    0x02, 0x23, 0x02, 0x12, 0x04, 0x80, 0x06, 0x0f, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x23, 0x03, 0x12, 0x04, 0x80, 0x06, 0x2d, 0x42, 0x0a, 0x0c, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x24,
    0x12, 0x04, 0x81, 0x06, 0x02, 0x4d, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x24, 0x01, 0x12,
    0x04, 0x81, 0x06, 0x06, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x24, 0x02, 0x12, 0x04,
    0x81, 0x06, 0x12, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x24, 0x03, 0x12, 0x04, 0x81,
    0x06, 0x33, 0x4b, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x25, 0x12, 0x06, 0x82, 0x06, 0x02,
    0x83, 0x06, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x25, 0x01, 0x12, 0x04, 0x82, 0x06,
    0x06, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x25, 0x02, 0x12, 0x04, 0x82, 0x06, 0x18,
    0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x25, 0x03, 0x12, 0x04, 0x83, 0x06, 0x0f, 0x2d,
    0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x26, 0x12, 0x06, 0x84, 0x06, 0x02, 0x85, 0x06, 0x32,
    0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x26, 0x01, 0x12, 0x04, 0x84, 0x06, 0x06, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x26, 0x02, 0x12, 0x04, 0x84, 0x06, 0x1b, 0x3b, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x26, 0x03, 0x12, 0x04, 0x85, 0x06, 0x0f, 0x30, 0x0a, 0x0e, 0x0a,
    0x04, 0x06, 0x00, 0x02, 0x27, 0x12, 0x06, 0x86, 0x06, 0x02, 0x87, 0x06, 0x32, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x27, 0x01, 0x12, 0x04, 0x86, 0x06, 0x06, 0x1a, 0x0a, 0x0d, 0x0a, 0x05,
    0x06, 0x00, 0x02, 0x27, 0x02, 0x12, 0x04, 0x86, 0x06, 0x1b, 0x3b, 0x0a, 0x0d, 0x0a, 0x05, 0x06,
    0x00, 0x02, 0x27, 0x03, 0x12, 0x04, 0x87, 0x06, 0x0f, 0x30, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00,
    0x02, 0x28, 0x12, 0x06, 0x88, 0x06, 0x02, 0x89, 0x06, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00,
    0x02, 0x28, 0x01, 0x12, 0x04, 0x88, 0x06, 0x06, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x28, 0x02, 0x12, 0x04, 0x88, 0x06, 0x1a, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x28,
    0x03, 0x12, 0x04, 0x89, 0x06, 0x0f, 0x2f, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x29, 0x12,
    0x06, 0x8a, 0x06, 0x02, 0x8b, 0x06, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x29, 0x01,
    0x12, 0x04, 0x8a, 0x06, 0x06, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x29, 0x02, 0x12,
    0x04, 0x8a, 0x06, 0x13, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x29, 0x03, 0x12, 0x04,
    0x8b, 0x06, 0x0e, 0x27, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x2a, 0x12, 0x06, 0x8c, 0x06,
    0x02, 0x8d, 0x06, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x2a, 0x01, 0x12, 0x04, 0x8c,
    0x06, 0x06, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x2a, 0x02, 0x12, 0x04, 0x8c, 0x06,
    0x16, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x2a, 0x03, 0x12, 0x04, 0x8d, 0x06, 0x0e,
    0x2a, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x2b, 0x12, 0x06, 0x8e, 0x06, 0x02, 0x8f, 0x06,
    0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x2b, 0x01, 0x12, 0x04, 0x8e, 0x06, 0x06, 0x15,
    0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x2b, 0x02, 0x12, 0x04, 0x8e, 0x06, 0x16, 0x31, 0x0a,
    0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x2b, 0x03, 0x12, 0x04, 0x8f, 0x06, 0x0e, 0x2a, 0x0a, 0x0e,
    0x0a, 0x04, 0x06, 0x00, 0x02, 0x2c, 0x12, 0x06, 0x90, 0x06, 0x02, 0x91, 0x06, 0x2b, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x2c, 0x01, 0x12, 0x04, 0x90, 0x06, 0x06, 0x14, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x2c, 0x02, 0x12, 0x04, 0x90, 0x06, 0x15, 0x2f, 0x0a, 0x0d, 0x0a, 0x05,
    0x06, 0x00, 0x02, 0x2c, 0x03, 0x12, 0x04, 0x91, 0x06, 0x0e, 0x29, 0x0a, 0x0e, 0x0a, 0x04, 0x06,
    0x00, 0x02, 0x2d, 0x12, 0x06, 0x92, 0x06, 0x02, 0x93, 0x06, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x06,
    0x00, 0x02, 0x2d, 0x01, 0x12, 0x04, 0x92, 0x06, 0x06, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00,
    0x02, 0x2d, 0x02, 0x12, 0x04, 0x92, 0x06, 0x16, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x2d, 0x03, 0x12, 0x04, 0x93, 0x06, 0x0e, 0x2a, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x2e,
    0x12, 0x06, 0x94, 0x06, 0x02, 0x95, 0x06, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x2e,
    0x01, 0x12, 0x04, 0x94, 0x06, 0x06, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x2e, 0x02,
    0x12, 0x04, 0x94, 0x06, 0x18, 0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x2e, 0x03, 0x12,
    0x04, 0x95, 0x06, 0x0e, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x2f, 0x12, 0x04, 0x96,
    0x06, 0x02, 0x44, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x2f, 0x01, 0x12, 0x04, 0x96, 0x06,
    0x06, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x2f, 0x02, 0x12, 0x04, 0x96, 0x06, 0x0f,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x2f, 0x03, 0x12, 0x04, 0x96, 0x06, 0x2d, 0x42,
    0x0a, 0x0c, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x30, 0x12, 0x04, 0x97, 0x06, 0x02, 0x3b, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x30, 0x01, 0x12, 0x04, 0x97, 0x06, 0x06, 0x0b, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x30, 0x02, 0x12, 0x04, 0x97, 0x06, 0x0c, 0x1d, 0x0a, 0x0d, 0x0a, 0x05,
    0x06, 0x00, 0x02, 0x30, 0x03, 0x12, 0x04, 0x97, 0x06, 0x27, 0x39, 0x0a, 0x0c, 0x0a, 0x04, 0x06,
    0x00, 0x02, 0x31, 0x12, 0x04, 0x98, 0x06, 0x02, 0x44, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x31, 0x01, 0x12, 0x04, 0x98, 0x06, 0x06, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x31,
    0x02, 0x12, 0x04, 0x98, 0x06, 0x0f, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x31, 0x03,
    0x12, 0x04, 0x98, 0x06, 0x2d, 0x42, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x32, 0x12, 0x06,
    0x99, 0x06, 0x02, 0x9a, 0x06, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x32, 0x01, 0x12,
    0x04, 0x99, 0x06, 0x06, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x32, 0x02, 0x12, 0x04,
    0x99, 0x06, 0x14, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x32, 0x03, 0x12, 0x04, 0x9a,
    0x06, 0x0e, 0x28, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x33, 0x12, 0x06, 0x9b, 0x06, 0x02,
    0x9c, 0x06, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x33, 0x01, 0x12, 0x04, 0x9b, 0x06,
    0x06, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x33, 0x02, 0x12, 0x04, 0x9b, 0x06, 0x14,
    0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x33, 0x03, 0x12, 0x04, 0x9c, 0x06, 0x0e, 0x28,
    0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x34, 0x12, 0x06, 0x9d, 0x06, 0x02, 0x9e, 0x06, 0x33,
    0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x34, 0x01, 0x12, 0x04, 0x9d, 0x06, 0x06, 0x1c, 0x0a,
    0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x34, 0x02, 0x12, 0x04, 0x9d, 0x06, 0x1d, 0x3f, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x34, 0x03, 0x12, 0x04, 0x9e, 0x06, 0x0e, 0x31, 0x0a, 0x0e, 0x0a,
    0x04, 0x06, 0x00, 0x02, 0x35, 0x12, 0x06, 0x9f, 0x06, 0x02, 0xa0, 0x06, 0x2b, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x35, 0x01, 0x12, 0x04, 0x9f, 0x06, 0x06, 0x14, 0x0a, 0x0d, 0x0a, 0x05,
    0x06, 0x00, 0x02, 0x35, 0x02, 0x12, 0x04, 0x9f, 0x06, 0x15, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x06,
    0x00, 0x02, 0x35, 0x03, 0x12, 0x04, 0xa0, 0x06, 0x0e, 0x29, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00,
    0x02, 0x36, 0x12, 0x06, 0xa1, 0x06, 0x02, 0xa2, 0x06, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00,
    0x02, 0x36, 0x01, 0x12, 0x04, 0xa1, 0x06, 0x06, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x36, 0x02, 0x12, 0x04, 0xa1, 0x06, 0x19, 0x45, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x36,
    0x03, 0x12, 0x04, 0xa2, 0x06, 0x0e, 0x3b, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x37, 0x12,
    0x06, 0xa3, 0x06, 0x02, 0xa4, 0x06, 0x3f, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x37, 0x01,
    0x12, 0x04, 0xa3, 0x06, 0x06, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x37, 0x02, 0x12,
    0x04, 0xa3, 0x06, 0x1b, 0x49, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x37, 0x03, 0x12, 0x04,
    0xa4, 0x06, 0x0e, 0x3d, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x38, 0x12, 0x06, 0xa5, 0x06,
    0x02, 0xa6, 0x06, 0x40, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x38, 0x01, 0x12, 0x04, 0xa5,
    0x06, 0x06, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x38, 0x02, 0x12, 0x04, 0xa5, 0x06,
    0x1c, 0x4b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x38, 0x03, 0x12, 0x04, 0xa6, 0x06, 0x0e,
    0x3e, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x39, 0x12, 0x06, 0xa7, 0x06, 0x02, 0xa8, 0x06,
    0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x39, 0x01, 0x12, 0x04, 0xa7, 0x06, 0x06, 0x1a,
    0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x39, 0x02, 0x12, 0x04, 0xa7, 0x06, 0x1b, 0x3b, 0x0a,
    0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x39, 0x03, 0x12, 0x04, 0xa8, 0x06, 0x0e, 0x2f, 0x0a, 0x0e,
    0x0a, 0x04, 0x06, 0x00, 0x02, 0x3a, 0x12, 0x06, 0xa9, 0x06, 0x02, 0xaa, 0x06, 0x31, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x3a, 0x01, 0x12, 0x04, 0xa9, 0x06, 0x06, 0x1a, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x3a, 0x02, 0x12, 0x04, 0xa9, 0x06, 0x1b, 0x3b, 0x0a, 0x0d, 0x0a, 0x05,
    0x06, 0x00, 0x02, 0x3a, 0x03, 0x12, 0x04, 0xaa, 0x06, 0x0e, 0x2f, 0x0a, 0x0e, 0x0a, 0x04, 0x06,
    0x00, 0x02, 0x3b, 0x12, 0x06, 0xab, 0x06, 0x02, 0xac, 0x06, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x06,
    0x00, 0x02, 0x3b, 0x01, 0x12, 0x04, 0xab, 0x06, 0x06, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00,
    0x02, 0x3b, 0x02, 0x12, 0x04, 0xab, 0x06, 0x15, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x3b, 0x03, 0x12, 0x04, 0xac, 0x06, 0x0e, 0x29, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x3c,
    0x12, 0x06, 0xad, 0x06, 0x02, 0xae, 0x06, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x3c,
    0x01, 0x12, 0x04, 0xad, 0x06, 0x06, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x3c, 0x02,
    0x12, 0x04, 0xad, 0x06, 0x15, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x3c, 0x03, 0x12,
    0x04, 0xae, 0x06, 0x0e, 0x29, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x3d, 0x12, 0x06, 0xaf,
    0x06, 0x02, 0xb0, 0x06, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x3d, 0x01, 0x12, 0x04,
    0xaf, 0x06, 0x06, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x3d, 0x02, 0x12, 0x04, 0xaf,
    0x06, 0x14, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x3d, 0x03, 0x12, 0x04, 0xb0, 0x06,
    0x0e, 0x28, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x3e, 0x12, 0x06, 0xb1, 0x06, 0x02, 0xb2,
    0x06, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x3e, 0x01, 0x12, 0x04, 0xb1, 0x06, 0x06,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x3e, 0x02, 0x12, 0x04, 0xb1, 0x06, 0x17, 0x33,
    0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x3e, 0x03, 0x12, 0x04, 0xb2, 0x06, 0x0e, 0x2b, 0x0a,
    0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x3f, 0x12, 0x06, 0xb3, 0x06, 0x02, 0xb4, 0x06, 0x37, 0x0a,
    0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x3f, 0x01, 0x12, 0x04, 0xb3, 0x06, 0x06, 0x20, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x3f, 0x02, 0x12, 0x04, 0xb3, 0x06, 0x21, 0x47, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x3f, 0x03, 0x12, 0x04, 0xb4, 0x06, 0x0e, 0x35, 0x0a, 0x0e, 0x0a, 0x04,
    0x06, 0x00, 0x02, 0x40, 0x12, 0x06, 0xb5, 0x06, 0x02, 0xb6, 0x06, 0x2b, 0x0a, 0x0d, 0x0a, 0x05,
    0x06, 0x00, 0x02, 0x40, 0x01, 0x12, 0x04, 0xb5, 0x06, 0x06, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x06,
    0x00, 0x02, 0x40, 0x02, 0x12, 0x04, 0xb5, 0x06, 0x15, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00,
    0x02, 0x40, 0x03, 0x12, 0x04, 0xb6, 0x06, 0x0e, 0x29, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02,
    0x41, 0x12, 0x06, 0xb7, 0x06, 0x02, 0xb8, 0x06, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x41, 0x01, 0x12, 0x04, 0xb7, 0x06, 0x06, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x41,
    0x02, 0x12, 0x04, 0xb7, 0x06, 0x1c, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x41, 0x03,
    0x12, 0x04, 0xb8, 0x06, 0x0e, 0x30, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x42, 0x12, 0x06,
    0xb9, 0x06, 0x02, 0xba, 0x06, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x42, 0x01, 0x12,
    0x04, 0xb9, 0x06, 0x06, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x42, 0x02, 0x12, 0x04,
    0xb9, 0x06, 0x13, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x42, 0x03, 0x12, 0x04, 0xba,
    0x06, 0x0e, 0x27, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x43, 0x12, 0x06, 0xbb, 0x06, 0x02,
    0xbc, 0x06, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x43, 0x01, 0x12, 0x04, 0xbb, 0x06,
    0x06, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x43, 0x02, 0x12, 0x04, 0xbb, 0x06, 0x17,
    0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x43, 0x03, 0x12, 0x04, 0xbc, 0x06, 0x0e, 0x2b,
    0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x44, 0x12, 0x06, 0xbd, 0x06, 0x02, 0xbe, 0x06, 0x2d,
    0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x44, 0x01, 0x12, 0x04, 0xbd, 0x06, 0x06, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x44, 0x02, 0x12, 0x04, 0xbd, 0x06, 0x17, 0x33, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x44, 0x03, 0x12, 0x04, 0xbe, 0x06, 0x0e, 0x2b, 0x0a, 0x0e, 0x0a,
    0x04, 0x06, 0x00, 0x02, 0x45, 0x12, 0x06, 0xbf, 0x06, 0x02, 0xc0, 0x06, 0x2d, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x45, 0x01, 0x12, 0x04, 0xbf, 0x06, 0x06, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x06, 0x00, 0x02, 0x45, 0x02, 0x12, 0x04, 0xbf, 0x06, 0x17, 0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x06,
    0x00, 0x02, 0x45, 0x03, 0x12, 0x04, 0xc0, 0x06, 0x0e, 0x2b, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00,
    0x02, 0x46, 0x12, 0x06, 0xc1, 0x06, 0x02, 0xc2, 0x06, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00,
    0x02, 0x46, 0x01, 0x12, 0x04, 0xc1, 0x06, 0x06, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x46, 0x02, 0x12, 0x04, 0xc1, 0x06, 0x10, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x46,
    0x03, 0x12, 0x04, 0xc2, 0x06, 0x0e, 0x24, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x47, 0x12,
    0x06, 0xc3, 0x06, 0x02, 0xc4, 0x06, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x47, 0x01,
    0x12, 0x04, 0xc3, 0x06, 0x06, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x47, 0x02, 0x12,
    0x04, 0xc3, 0x06, 0x0d, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x47, 0x03, 0x12, 0x04,
    0xc4, 0x06, 0x0e, 0x21, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x48, 0x12, 0x06, 0xc5, 0x06,
    0x02, 0xc6, 0x06, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x48, 0x01, 0x12, 0x04, 0xc5,
    0x06, 0x06, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x48, 0x02, 0x12, 0x04, 0xc5, 0x06,
    0x13, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x48, 0x03, 0x12, 0x04, 0xc6, 0x06, 0x0e,
    0x27, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x49, 0x12, 0x06, 0xc7, 0x06, 0x02, 0xc8, 0x06,
    0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x49, 0x01, 0x12, 0x04, 0xc7, 0x06, 0x06, 0x0e,
    0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x49, 0x02, 0x12, 0x04, 0xc7, 0x06, 0x0f, 0x23, 0x0a,
    0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x49, 0x03, 0x12, 0x04, 0xc8, 0x06, 0x0e, 0x23, 0x0a, 0x0e,
    0x0a, 0x04, 0x06, 0x00, 0x02, 0x4a, 0x12, 0x06, 0xc9, 0x06, 0x02, 0xca, 0x06, 0x26, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x4a, 0x01, 0x12, 0x04, 0xc9, 0x06, 0x06, 0x0f, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x4a, 0x02, 0x12, 0x04, 0xc9, 0x06, 0x10, 0x25, 0x0a, 0x0d, 0x0a, 0x05,
    0x06, 0x00, 0x02, 0x4a, 0x03, 0x12, 0x04, 0xca, 0x06, 0x0e, 0x24, 0x0a, 0x0e, 0x0a, 0x04, 0x06,
    0x00, 0x02, 0x4b, 0x12, 0x06, 0xcb, 0x06, 0x02, 0xcc, 0x06, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x06,
    0x00, 0x02, 0x4b, 0x01, 0x12, 0x04, 0xcb, 0x06, 0x06, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00,
    0x02, 0x4b, 0x02, 0x12, 0x04, 0xcb, 0x06, 0x11, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x4b, 0x03, 0x12, 0x04, 0xcc, 0x06, 0x0e, 0x25, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x4c,
    0x12, 0x06, 0xcd, 0x06, 0x02, 0xce, 0x06, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x4c,
    0x01, 0x12, 0x04, 0xcd, 0x06, 0x06, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x4c, 0x02,
    0x12, 0x04, 0xcd, 0x06, 0x12, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x4c, 0x03, 0x12,
    0x04, 0xce, 0x06, 0x0e, 0x26, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x4d, 0x12, 0x06, 0xcf,
    0x06, 0x02, 0xd0, 0x06, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x4d, 0x01, 0x12, 0x04,
    0xcf, 0x06, 0x06, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x4d, 0x02, 0x12, 0x04, 0xcf,
    0x06, 0x12, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x4d, 0x03, 0x12, 0x04, 0xd0, 0x06,
    0x0e, 0x26, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x4e, 0x12, 0x06, 0xd1, 0x06, 0x02, 0xd2,
    0x06, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x4e, 0x01, 0x12, 0x04, 0xd1, 0x06, 0x06,
    0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x4e, 0x02, 0x12, 0x04, 0xd1, 0x06, 0x1b, 0x3b,
    0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x4e, 0x03, 0x12, 0x04, 0xd2, 0x06, 0x0e, 0x2f, 0x0a,
    0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x4f, 0x12, 0x06, 0xd3, 0x06, 0x02, 0xd4, 0x06, 0x30, 0x0a,
    0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x4f, 0x01, 0x12, 0x04, 0xd3, 0x06, 0x06, 0x19, 0x0a, 0x0d,
    0x0a, 0x05, 0x06, 0x00, 0x02, 0x4f, 0x02, 0x12, 0x04, 0xd3, 0x06, 0x1a, 0x39, 0x0a, 0x0d, 0x0a,
    0x05, 0x06, 0x00, 0x02, 0x4f, 0x03, 0x12, 0x04, 0xd4, 0x06, 0x0e, 0x2e, 0x0a, 0x0e, 0x0a, 0x04,
    0x06, 0x00, 0x02, 0x50, 0x12, 0x06, 0xd5, 0x06, 0x02, 0xd6, 0x06, 0x29, 0x0a, 0x0d, 0x0a, 0x05,
    0x06, 0x00, 0x02, 0x50, 0x01, 0x12, 0x04, 0xd5, 0x06, 0x06, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x06,
    0x00, 0x02, 0x50, 0x02, 0x12, 0x04, 0xd5, 0x06, 0x13, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00,
    0x02, 0x50, 0x03, 0x12, 0x04, 0xd6, 0x06, 0x0e, 0x27, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02,
    0x51, 0x12, 0x06, 0xd7, 0x06, 0x02, 0xd8, 0x06, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02,
    0x51, 0x01, 0x12, 0x04, 0xd7, 0x06, 0x06, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x51,
    0x02, 0x12, 0x04, 0xd7, 0x06, 0x1c, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x51, 0x03,
    0x12, 0x04, 0xd8, 0x06, 0x0e, 0x30, 0x0a, 0x0e, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x52, 0x12, 0x06,
    0xd9, 0x06, 0x02, 0xda, 0x06, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x52, 0x01, 0x12,
    0x04, 0xd9, 0x06, 0x06, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x52, 0x02, 0x12, 0x04,
    0xd9, 0x06, 0x17, 0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x06, 0x00, 0x02, 0x52, 0x03, 0x12, 0x04, 0xda,
    0x06, 0x0e, 0x2b,
];

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
